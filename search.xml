<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>10.03 模拟赛 by FXT</title>
    <url>/2023/10/05/10-03-%E6%A8%A1%E6%8B%9F%E8%B5%9B-by-FXT/</url>
    <content><![CDATA[<h1 id="10-03-模拟赛"><a href="#10-03-模拟赛" class="headerlink" title="10.03 模拟赛"></a>10.03 模拟赛</h1><p>这场可能称为 CSP 模拟赛更好一点。？</p>
<h2 id="T1"><a href="#T1" class="headerlink" title="T1"></a>T1</h2><p> Ptz 2020 Winter Day 4 B QOJ 686</p>
<h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><p>签到题。对于每只虱子分开考虑。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 2000005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> put() putchar(<span class="string">&#x27;\n&#x27;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Tp template<span class="string">&lt;typename Ty&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Ts template<span class="string">&lt;typename Ty,typename... Ar&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">(<span class="type">int</span> &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> f=<span class="number">1</span>;x=<span class="number">0</span>;<span class="type">char</span> c=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (c&lt;<span class="string">&#x27;0&#x27;</span>||c&gt;<span class="string">&#x27;9&#x27;</span>) &#123;<span class="keyword">if</span> (c==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">-1</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span> (c&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;c&lt;=<span class="string">&#x27;9&#x27;</span>) &#123;x=x*<span class="number">10</span>+c-<span class="string">&#x27;0&#x27;</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> Debug&#123;</span><br><span class="line">	Tp <span class="type">void</span> _debug(<span class="type">char</span>* f,Ty t)&#123;cerr&lt;&lt;f&lt;&lt;<span class="string">&#x27;=&#x27;</span>&lt;&lt;t&lt;&lt;endl;&#125;</span><br><span class="line">	Ts <span class="type">void</span> _debug(<span class="type">char</span>* f,Ty x,Ar... y)&#123;<span class="keyword">while</span>(*f!=<span class="string">&#x27;,&#x27;</span>) cerr&lt;&lt;*f++;cerr&lt;&lt;<span class="string">&#x27;=&#x27;</span>&lt;&lt;x&lt;&lt;<span class="string">&quot;,&quot;</span>;_debug(f+<span class="number">1</span>,y...);&#125;</span><br><span class="line">	Tp ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; os,vector&lt;Ty&gt;&amp; V)&#123;os&lt;&lt;<span class="string">&quot;[&quot;</span>;<span class="keyword">for</span>(<span class="keyword">auto</span>&amp; vv:V) os&lt;&lt;vv&lt;&lt;<span class="string">&quot;,&quot;</span>;os&lt;&lt;<span class="string">&quot;]&quot;</span>;<span class="keyword">return</span> os;&#125;</span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> gdb(...) _debug((char*)#__VA_ARGS__,__VA_ARGS__)</span></span><br><span class="line">&#125;<span class="keyword">using</span> <span class="keyword">namespace</span> Debug;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mk make_pair</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">power</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y=mod<span class="number">-2</span>)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> sum=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (y) &#123;</span><br><span class="line">		<span class="keyword">if</span> (y&amp;<span class="number">1</span>) sum=sum*x%mod;</span><br><span class="line">		x=x*x%mod;y&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,m,w[maxn];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">yyy</span> &#123;</span><br><span class="line">	<span class="type">int</span> l,r;</span><br><span class="line">&#125;a[maxn],id[maxn];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;to[maxn];	</span><br><span class="line"><span class="type">int</span> d[maxn],s[maxn],s2[maxn],g[maxn],anss;</span><br><span class="line"><span class="type">int</span> Ans[maxn];</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> i,j,tot,x,y;</span><br><span class="line">	<span class="built_in">read</span>(n);<span class="built_in">read</span>(m);</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=m;i++) <span class="built_in">read</span>(w[i]);</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="built_in">read</span>(a[i].l),<span class="built_in">read</span>(a[i].r);<span class="built_in">read</span>(x);</span><br><span class="line">		<span class="keyword">while</span> (x--) &#123;</span><br><span class="line">			<span class="built_in">read</span>(y);</span><br><span class="line">			to[y].<span class="built_in">push_back</span>(i);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (j=<span class="number">1</span>;j&lt;=m;j++) &#123;</span><br><span class="line">		tot=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> y:to[j]) g[++tot]=a[y].l<span class="number">-1</span>,g[++tot]=a[y].r;</span><br><span class="line">		<span class="built_in">sort</span>(g+<span class="number">1</span>,g+<span class="number">1</span>+tot);</span><br><span class="line">		tot=<span class="built_in">unique</span>(g+<span class="number">1</span>,g+<span class="number">1</span>+tot)-g<span class="number">-1</span>;</span><br><span class="line">		<span class="type">int</span> nums=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> y:to[j]) &#123;</span><br><span class="line">			++nums;</span><br><span class="line">			id[nums].l=<span class="built_in">lower_bound</span>(g+<span class="number">1</span>,g+<span class="number">1</span>+tot,a[y].l<span class="number">-1</span>)-g;</span><br><span class="line">			id[nums].r=<span class="built_in">lower_bound</span>(g+<span class="number">1</span>,g+<span class="number">1</span>+tot,a[y].r)-g;</span><br><span class="line">			d[id[nums].l+<span class="number">1</span>]++,d[id[nums].r+<span class="number">1</span>]--;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=tot;i++) &#123;</span><br><span class="line">			d[i]+=d[i<span class="number">-1</span>];</span><br><span class="line">			s[i]=s[i<span class="number">-1</span>]+(d[i]&gt;<span class="number">0</span>)*(g[i]-g[i<span class="number">-1</span>]);</span><br><span class="line">			s2[i]=s2[i<span class="number">-1</span>]+(d[i]==<span class="number">1</span>)*(g[i]-g[i<span class="number">-1</span>]);</span><br><span class="line">		&#125;</span><br><span class="line">		nums=<span class="number">0</span>;</span><br><span class="line">		anss+=s[tot]*w[j];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> y:to[j]) &#123;</span><br><span class="line">			++nums;</span><br><span class="line">			Ans[y]-=(s2[id[nums].r]-s2[id[nums].l])*w[j];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=tot+<span class="number">5</span>;i++) d[i]=s[i]=s2[i]=<span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">printf</span>(<span class="string">&quot;%lld%c&quot;</span>,anss+Ans[i],<span class="string">&quot; \n&quot;</span>[i==n]);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="T2"><a href="#T2" class="headerlink" title="T2"></a>T2</h2><p>Ptz 2020 Winter Day 4 C QOJ 687</p>
<p>原来 $2^nn^2$ 在 $n&#x3D;20$ 是 $4\times 10^8$，我算成 $4\times 10^7$ 然后自信离场。</p>
<h3 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution"></a>Solution</h3><p>考虑状态压缩。令 $f_S$ 表示集合 $S$ 为前缀的拓扑序的方案数，$g_S$ 表示集合 $S$ 为后缀的拓扑序的方案数。两者都可以 $O(2^nn)$ 预处理出来。</p>
<p>然后是统计答案。外层枚举第 $i$ 行，令 $T&#x3D;C_U^{S\cup i}$ 先判断 $S+i+T$ 是否合法，然后让 $Ans_{x,i}\gets Ans_{x,i}+f_S\times g_S$。直接做是 $O(2^n n^2)$ 的。考虑用一个类似于懒惰标记的东西。令 $h_S$ 表示 $S$ 的方案数。如果 $S$ 中包含至少两个元素，令 $x$ 为其任意的一个元素，则 $T&#x3D;C_S^$ 则有 $h_x\gets h_S,h_{T}\gets h_S$。这样直接传下来，复杂度就是 $O(2^n n)$。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> put() putchar(<span class="string">&#x27;\n&#x27;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Tp template<span class="string">&lt;typename Ty&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Ts template<span class="string">&lt;typename Ty,typename... Ar&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">(<span class="type">int</span> &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> f=<span class="number">1</span>;x=<span class="number">0</span>;<span class="type">char</span> c=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (c&lt;<span class="string">&#x27;0&#x27;</span>||c&gt;<span class="string">&#x27;9&#x27;</span>) &#123;<span class="keyword">if</span> (c==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">-1</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span> (c&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;c&lt;=<span class="string">&#x27;9&#x27;</span>) &#123;x=x*<span class="number">10</span>+c-<span class="string">&#x27;0&#x27;</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> Debug&#123;</span><br><span class="line">	Tp <span class="type">void</span> _debug(<span class="type">char</span>* f,Ty t)&#123;cerr&lt;&lt;f&lt;&lt;<span class="string">&#x27;=&#x27;</span>&lt;&lt;t&lt;&lt;endl;&#125;</span><br><span class="line">	Ts <span class="type">void</span> _debug(<span class="type">char</span>* f,Ty x,Ar... y)&#123;<span class="keyword">while</span>(*f!=<span class="string">&#x27;,&#x27;</span>) cerr&lt;&lt;*f++;cerr&lt;&lt;<span class="string">&#x27;=&#x27;</span>&lt;&lt;x&lt;&lt;<span class="string">&quot;,&quot;</span>;_debug(f+<span class="number">1</span>,y...);&#125;</span><br><span class="line">	Tp ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; os,vector&lt;Ty&gt;&amp; V)&#123;os&lt;&lt;<span class="string">&quot;[&quot;</span>;<span class="keyword">for</span>(<span class="keyword">auto</span>&amp; vv:V) os&lt;&lt;vv&lt;&lt;<span class="string">&quot;,&quot;</span>;os&lt;&lt;<span class="string">&quot;]&quot;</span>;<span class="keyword">return</span> os;&#125;</span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> gdb(...) _debug((char*)#__VA_ARGS__,__VA_ARGS__)</span></span><br><span class="line">&#125;<span class="keyword">using</span> <span class="keyword">namespace</span> Debug;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mk make_pair</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">power</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y=mod<span class="number">-2</span>)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> sum=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (y) &#123;</span><br><span class="line">		<span class="keyword">if</span> (y&amp;<span class="number">1</span>) sum=sum*x%mod;</span><br><span class="line">		x=x*x%mod;y&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> to[<span class="number">25</span>],pre[<span class="number">25</span>],f[(<span class="number">1</span>&lt;&lt;<span class="number">20</span>)+<span class="number">5</span>],g[(<span class="number">1</span>&lt;&lt;<span class="number">20</span>)+<span class="number">5</span>],h[(<span class="number">1</span>&lt;&lt;<span class="number">20</span>)+<span class="number">5</span>];</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) ((x)&amp;(-x))</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> i,j,k,s,t,x,y,a,b;</span><br><span class="line">	<span class="built_in">read</span>(n);<span class="built_in">read</span>(m);</span><br><span class="line">	<span class="type">int</span> N=(<span class="number">1</span>&lt;&lt;n);</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;=n;i++) to[i]=pre[i]=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=m;i++) &#123;</span><br><span class="line">		<span class="built_in">read</span>(x),<span class="built_in">read</span>(y);</span><br><span class="line">		to[y<span class="number">-1</span>]|=(<span class="number">1</span>&lt;&lt;x<span class="number">-1</span>);</span><br><span class="line">		pre[x<span class="number">-1</span>]|=(<span class="number">1</span>&lt;&lt;y<span class="number">-1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;N;i++) f[i]=g[i]=<span class="number">0</span>;</span><br><span class="line">	f[<span class="number">0</span>]=g[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;N;i++)</span><br><span class="line">		<span class="keyword">for</span> (j=<span class="number">0</span>;j&lt;n;j++) &#123;</span><br><span class="line">			<span class="keyword">if</span> ((i&amp;to[j])==to[j]) f[i]+=f[i^(<span class="number">1</span>&lt;&lt;j)];</span><br><span class="line">			<span class="keyword">if</span> ((i&amp;pre[j])==pre[j]) g[i]+=g[i^(<span class="number">1</span>&lt;&lt;j)];</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">for</span> (k=<span class="number">0</span>;k&lt;n;k++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (s=<span class="number">0</span>;s&lt;N;s++) h[s]=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (s=N<span class="number">-1</span>;s&gt;=<span class="number">0</span>;s--) &#123;</span><br><span class="line">			<span class="keyword">if</span> (((s&gt;&gt;k)%<span class="number">2</span>==<span class="number">0</span>)&amp;&amp;(s&amp;to[k])==to[k]) &#123;</span><br><span class="line">				<span class="type">int</span> t=(N<span class="number">-1</span>)^(<span class="number">1</span>&lt;&lt;k)^s;</span><br><span class="line">				<span class="keyword">if</span> ((pre[k]&amp;t)==pre[k]) &#123;</span><br><span class="line">					h[s]+=f[s]*g[t];</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (s!=<span class="built_in">lowbit</span>(s)) h[s^<span class="built_in">lowbit</span>(s)]+=h[s],h[<span class="built_in">lowbit</span>(s)]+=h[s],h[s]=<span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;n;i++) <span class="built_in">printf</span>(<span class="string">&quot;%lld &quot;</span>,h[<span class="number">1</span>&lt;&lt;i]);</span><br><span class="line">		<span class="built_in">put</span>();	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> T;</span><br><span class="line">	<span class="built_in">read</span>(T);</span><br><span class="line">	<span class="keyword">while</span> (T--) <span class="built_in">solve</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="T3"><a href="#T3" class="headerlink" title="T3"></a>T3</h2><p>JOI Open 2018 T1 Bubble Sort 2 QOJ 2643</p>
<p>妙妙题。</p>
<h3 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution"></a>Solution</h3><p>首先答案具有单调性。</p>
<p>原式：<br>$$<br>\min\limits_{i&#x3D;l}^r a_i+\max\limits_{i&#x3D;l}^r a_i&gt;r-l+1<br>$$<br>考虑一个满足要求的区间 $[l,r]$，随便减去不是最大值的端点，则左式不减，右式减小。一定满足。</p>
<p>考虑一种双指针，枚举右端点 $r$，令当前的最大值为 $ans$，则 $l$ 从 $r-ans+1$ 开始向左枚举，判断合法性。</p>
<p>先不考虑判断合法性的复杂度。先考虑正确性。如果枚举到答案区间的最大值，则左端点根据单调性一定会移动答案区间的左端点。</p>
<p>然后来看端点的移动次数，每次为了保证区间的长度大于等于最大值，每次移动右端点时，左端点最多往右移动一格。左端点最多只能向左移动 $O(2n)$ 次，所以移动次数为 $O(n)$ 的。</p>
<p>现在的复杂度瓶颈在于判断区间的合法性。也就是要动态求出区间的最大值和最小值。除了四毛子树这种不可能写的东西以外。有一种神奇的东西：对顶栈。他的算法流程如下：</p>
<ul>
<li>以一个点为中心，维护前后缀的最大最小值。</li>
<li>如果加减前后首位且区间包含中心点，$O(1)$ 维护前后缀。</li>
<li>如果不包含中心点，暴力重构，取当前区间的中点作为中心点。</li>
</ul>
<p>考虑分析复杂度，如果一个长度为 $n$ 的序列被重构了，则至少操作了 $n&#x2F;2$ 次。所以复杂度是 $O(n)$，其中  $n$ 为操作次数。</p>
<p>对顶栈感觉可以适用于这种双指针强行让你 $O(n)$ 的题目中。如果预处理或者查询有一个可以做到 $O(n\log n)$ 或者以上，就没有使用的必要了，感觉不如 ST 表。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 1000005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> put() putchar(<span class="string">&#x27;\n&#x27;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Tp template<span class="string">&lt;typename Ty&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Ts template<span class="string">&lt;typename Ty,typename... Ar&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">(<span class="type">int</span> &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> f=<span class="number">1</span>;x=<span class="number">0</span>;<span class="type">char</span> c=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (c&lt;<span class="string">&#x27;0&#x27;</span>||c&gt;<span class="string">&#x27;9&#x27;</span>) &#123;<span class="keyword">if</span> (c==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">-1</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span> (c&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;c&lt;=<span class="string">&#x27;9&#x27;</span>) &#123;x=x*<span class="number">10</span>+c-<span class="string">&#x27;0&#x27;</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> Debug&#123;</span><br><span class="line">	Tp <span class="type">void</span> _debug(<span class="type">char</span>* f,Ty t)&#123;cerr&lt;&lt;f&lt;&lt;<span class="string">&#x27;=&#x27;</span>&lt;&lt;t&lt;&lt;endl;&#125;</span><br><span class="line">	Ts <span class="type">void</span> _debug(<span class="type">char</span>* f,Ty x,Ar... y)&#123;<span class="keyword">while</span>(*f!=<span class="string">&#x27;,&#x27;</span>) cerr&lt;&lt;*f++;cerr&lt;&lt;<span class="string">&#x27;=&#x27;</span>&lt;&lt;x&lt;&lt;<span class="string">&quot;,&quot;</span>;_debug(f+<span class="number">1</span>,y...);&#125;</span><br><span class="line">	Tp ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; os,vector&lt;Ty&gt;&amp; V)&#123;os&lt;&lt;<span class="string">&quot;[&quot;</span>;<span class="keyword">for</span>(<span class="keyword">auto</span>&amp; vv:V) os&lt;&lt;vv&lt;&lt;<span class="string">&quot;,&quot;</span>;os&lt;&lt;<span class="string">&quot;]&quot;</span>;<span class="keyword">return</span> os;&#125;</span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> gdb(...) _debug((char*)#__VA_ARGS__,__VA_ARGS__)</span></span><br><span class="line">&#125;<span class="keyword">using</span> <span class="keyword">namespace</span> Debug;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mk make_pair</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">power</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y=mod<span class="number">-2</span>)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> sum=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (y) &#123;</span><br><span class="line">		<span class="keyword">if</span> (y&amp;<span class="number">1</span>) sum=sum*x%mod;</span><br><span class="line">		x=x*x%mod;y&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,m,a[maxn];</span><br><span class="line"><span class="type">int</span> L,mid,R,sl[maxn],sr[maxn],ml[maxn],mr[maxn];<span class="comment">//min,max</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> L,<span class="type">int</span> R)</span> </span>&#123;</span><br><span class="line">	mid=L+R&gt;&gt;<span class="number">1</span>;<span class="type">int</span> i;</span><br><span class="line">	<span class="keyword">for</span> (sl[mid]=ml[mid]=a[mid],i=mid<span class="number">-1</span>;i&gt;=L;i--) sl[i]=<span class="built_in">min</span>(sl[i+<span class="number">1</span>],a[i]),ml[i]=<span class="built_in">max</span>(ml[i+<span class="number">1</span>],a[i]);</span><br><span class="line">	<span class="keyword">for</span> (sr[mid+<span class="number">1</span>]=mr[mid+<span class="number">1</span>]=a[mid+<span class="number">1</span>],i=mid+<span class="number">2</span>;i&lt;=R;i++) sr[i]=<span class="built_in">min</span>(sr[i<span class="number">-1</span>],a[i]),mr[i]=<span class="built_in">max</span>(mr[i<span class="number">-1</span>],a[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (l==r) <span class="keyword">return</span> <span class="number">2</span>*a[l];</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">max</span>(mr[r],ml[l])+<span class="built_in">min</span>(sr[r],sl[l]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> i,ans=<span class="number">0</span>,l=<span class="number">1</span>,r;mid=<span class="number">1</span>;sl[l]=ml[l]=a[l];</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;=n;i++) sl[i]=sr[i]=ml[i]=mr[i]=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (r=<span class="number">1</span>;r&lt;=n;r++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (r&gt;mid+<span class="number">1</span>) sr[r]=<span class="built_in">min</span>(sr[r<span class="number">-1</span>],a[r]);<span class="keyword">else</span> sr[r]=a[r];</span><br><span class="line">		<span class="keyword">if</span> (r&gt;mid+<span class="number">1</span>) mr[r]=<span class="built_in">max</span>(mr[r<span class="number">-1</span>],a[r]);<span class="keyword">else</span> mr[r]=a[r];</span><br><span class="line">		<span class="keyword">if</span> (mid&lt;l||mid&gt;=r) <span class="built_in">build</span>(l,r);</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">query</span>(l,r)&lt;=r-l+<span class="number">1</span>) l++;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			sl[l<span class="number">-1</span>]=<span class="built_in">min</span>(sl[l],a[l<span class="number">-1</span>]);</span><br><span class="line">			ml[l<span class="number">-1</span>]=<span class="built_in">max</span>(ml[l],a[l<span class="number">-1</span>]);</span><br><span class="line">			<span class="keyword">while</span> (l&gt;=<span class="number">2</span>&amp;&amp;<span class="built_in">query</span>(l<span class="number">-1</span>,r)&gt;r-l+<span class="number">2</span>) &#123;</span><br><span class="line">				l--;</span><br><span class="line">				sl[l<span class="number">-1</span>]=<span class="built_in">min</span>(sl[l],a[l<span class="number">-1</span>]);</span><br><span class="line">				ml[l<span class="number">-1</span>]=<span class="built_in">max</span>(ml[l],a[l<span class="number">-1</span>]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		ans=<span class="built_in">max</span>(ans,r-l+<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> i,x,y;</span><br><span class="line">	<span class="built_in">read</span>(n);<span class="built_in">read</span>(m);</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">read</span>(a[i]);</span><br><span class="line">	<span class="built_in">solve</span>();</span><br><span class="line">	<span class="keyword">while</span> (m--) &#123;</span><br><span class="line">		<span class="built_in">read</span>(i);</span><br><span class="line">		<span class="keyword">while</span> (i--) <span class="built_in">read</span>(x),<span class="built_in">read</span>(y),<span class="built_in">swap</span>(a[x],a[y]);</span><br><span class="line">		<span class="built_in">solve</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="T4"><a href="#T4" class="headerlink" title="T4"></a>T4</h2><p>Ptz 2022 Winter Day 1 F QOJ 2544</p>
<h3 id="Solution-3"><a href="#Solution-3" class="headerlink" title="Solution"></a>Solution</h3><p>本质上就是一个体积很大 $10^{14}$，权值只有 $0\le w\le 4$ 的 01 背包。</p>
<p>一种做法是将权值相同的内部体积从小到大排序。考虑权值为 $i$ 的向 $i+1$ 的转移，有决策单调性。分治 $O(wn\log n)$ 解决。</p>
<p>另一种做法是根据权值的特殊性，$2,4$ 分为一组合并，$1,3$ 分为一组合并，最后双指针或者三分之类的找答案。   </p>
<p>考场贪心代码，其实很优，直接过了，要卡还是能卡，但是意义不大，不贴了。</p>
]]></content>
      <tags>
        <tag>NOIP模拟赛</tag>
        <tag>对顶栈</tag>
        <tag>状压</tag>
        <tag>dp</tag>
        <tag>决策单调性</tag>
      </tags>
  </entry>
  <entry>
    <title>7.12 模拟赛</title>
    <url>/2023/07/13/7-12-%E6%A8%A1%E6%8B%9F%E8%B5%9B/</url>
    <content><![CDATA[<h1 id="7-12-模拟赛"><a href="#7-12-模拟赛" class="headerlink" title="7.12 模拟赛"></a>7.12 模拟赛</h1><p>今天 T3 没卡时，遗憾 rk3。</p>
<p><img src="https://s2.loli.net/2023/07/12/wFy7KfGXlJib964.png"></p>
<h2 id="T1-ha"><a href="#T1-ha" class="headerlink" title="T1. ha"></a>T1. ha</h2><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p><img src="https://s2.loli.net/2023/07/12/yVNuCfc5FjlUtDh.png" alt="image-20230712200555725"></p>
<p>$1\le n\le 1\times 10^5,1\le m\le 100,l1,l2,r1,r2\le m$</p>
<h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><p>这题虽然签到，但是重点在于 <strong>每次操作之后，都可以看到计数器当前的显示值</strong>。所以每一位是要单独计算的。</p>
<p>反着做，每次模拟 $i$ 这个位置两次不同效果的期望值大小。比较取大的即可。前缀和搞一下。</p>
<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> put() putchar(<span class="string">&#x27;\n&#x27;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Tp template<span class="string">&lt;typename Ty&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Ts template<span class="string">&lt;typename Ty,typename... Ar&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(<span class="type">int</span> &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> f=<span class="number">1</span>;x=<span class="number">0</span>;<span class="type">char</span> c=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (c&lt;<span class="string">&#x27;0&#x27;</span>||c&gt;<span class="string">&#x27;9&#x27;</span>) &#123;<span class="keyword">if</span> (c==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">-1</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span> (c&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;c&lt;=<span class="string">&#x27;9&#x27;</span>) &#123;x=x*<span class="number">10</span>+c-<span class="string">&#x27;0&#x27;</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> Debug&#123;</span><br><span class="line">	Tp <span class="type">void</span> _debug(<span class="type">char</span>* f,Ty t)&#123;cerr&lt;&lt;f&lt;&lt;<span class="string">&#x27;=&#x27;</span>&lt;&lt;t&lt;&lt;endl;&#125;</span><br><span class="line">	Ts <span class="type">void</span> _debug(<span class="type">char</span>* f,Ty x,Ar... y)&#123;<span class="keyword">while</span>(*f!=<span class="string">&#x27;,&#x27;</span>) cerr&lt;&lt;*f++;cerr&lt;&lt;<span class="string">&#x27;=&#x27;</span>&lt;&lt;x&lt;&lt;<span class="string">&quot;,&quot;</span>;_debug(f+<span class="number">1</span>,y...);&#125;</span><br><span class="line">	Tp ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; os,vector&lt;Ty&gt;&amp; V)&#123;os&lt;&lt;<span class="string">&quot;[&quot;</span>;<span class="keyword">for</span>(<span class="keyword">auto</span>&amp; vv:V) os&lt;&lt;vv&lt;&lt;<span class="string">&quot;,&quot;</span>;os&lt;&lt;<span class="string">&quot;]&quot;</span>;<span class="keyword">return</span> os;&#125;</span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> gdb(...) _debug((char*)#__VA_ARGS__,__VA_ARGS__)</span></span><br><span class="line">&#125;<span class="keyword">using</span> <span class="keyword">namespace</span> Debug;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> l1,r1,l2,r2;</span><br><span class="line"><span class="type">double</span> a[<span class="number">105</span>],suf[<span class="number">105</span>],suf2[<span class="number">105</span>],ans;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">  	<span class="built_in">freopen</span>(<span class="string">&quot;ha.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">  	<span class="built_in">freopen</span>(<span class="string">&quot;ha.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout);</span><br><span class="line">	<span class="type">int</span> i,j,L,R;<span class="type">double</span> sum1,sum2;</span><br><span class="line">	<span class="built_in">read</span>(n);<span class="built_in">read</span>(m);<span class="built_in">read</span>(l1);<span class="built_in">read</span>(r1);<span class="built_in">read</span>(l2);<span class="built_in">read</span>(r2);</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;m;i++) a[i]=i;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		suf[<span class="number">0</span>]=a[<span class="number">0</span>];<span class="keyword">for</span> (j=<span class="number">1</span>;j&lt;=m;j++) suf[j]=suf[j<span class="number">-1</span>]+a[j];</span><br><span class="line">		<span class="keyword">for</span> (j=<span class="number">0</span>;j&lt;m;j++) &#123;</span><br><span class="line">			sum1=sum2=<span class="number">0</span>;</span><br><span class="line">			L=((j+l1+m)%m),R=(j+r1+m)%m;</span><br><span class="line">			<span class="keyword">if</span> (L&lt;=R) &#123;</span><br><span class="line">				<span class="keyword">if</span> (!L) sum1=suf[R];</span><br><span class="line">				<span class="keyword">else</span> sum1=suf[R]-suf[L<span class="number">-1</span>]; </span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> sum1=suf[m]-suf[L<span class="number">-1</span>]+suf[R];</span><br><span class="line">			sum1/=(r1-l1+<span class="number">1</span>);</span><br><span class="line">			</span><br><span class="line">			L=((j+l2+m)%m),R=(j+r2+m)%m;</span><br><span class="line">			<span class="keyword">if</span> (L&lt;=R) &#123;</span><br><span class="line">				<span class="keyword">if</span> (!L) sum2=suf[R];</span><br><span class="line">				<span class="keyword">else</span> sum2=suf[R]-suf[L<span class="number">-1</span>]; </span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> sum2=suf[m]-suf[L<span class="number">-1</span>]+suf[R];</span><br><span class="line">			sum2/=(r2-l2+<span class="number">1</span>);</span><br><span class="line">			</span><br><span class="line">			a[j]=<span class="built_in">max</span>(sum1,sum2);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%.2lf&quot;</span>,a[<span class="number">0</span>]);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="T2-carve"><a href="#T2-carve" class="headerlink" title="T2. carve"></a>T2. carve</h2><h3 id="Description-1"><a href="#Description-1" class="headerlink" title="Description"></a>Description</h3><p><img src="https://s2.loli.net/2023/07/12/eHPcFtRwla5qjAr.png" alt="image-20230712201016534"></p>
<p>$1\le n\le 10^6,a_i\le n$</p>
<h3 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution"></a>Solution</h3><p>实际上，题目转化为有两个机器，一个机器如果新加入或者加入和上一个加入的颜色不同，则花费一点代价。求代价最小化。</p>
<p>前几天做到一个这道题的加强版。就是有划分成 $k$ 个有序集合。回到这题，考虑贪心。如果当前节点和原来机器的颜色都不一样，则贪心去<strong>机器下一个颜色一样的位置大的机器</strong>。证明略。具体看代码。</p>
<h3 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 1000005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> put() putchar(<span class="string">&#x27;\n&#x27;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Tp template<span class="string">&lt;typename Ty&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Ts template<span class="string">&lt;typename Ty,typename... Ar&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(<span class="type">int</span> &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> f=<span class="number">1</span>;x=<span class="number">0</span>;<span class="type">char</span> c=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (c&lt;<span class="string">&#x27;0&#x27;</span>||c&gt;<span class="string">&#x27;9&#x27;</span>) &#123;<span class="keyword">if</span> (c==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">-1</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span> (c&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;c&lt;=<span class="string">&#x27;9&#x27;</span>) &#123;x=x*<span class="number">10</span>+c-<span class="string">&#x27;0&#x27;</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> Debug&#123;</span><br><span class="line">	Tp <span class="type">void</span> _debug(<span class="type">char</span>* f,Ty t)&#123;cerr&lt;&lt;f&lt;&lt;<span class="string">&#x27;=&#x27;</span>&lt;&lt;t&lt;&lt;endl;&#125;</span><br><span class="line">	Ts <span class="type">void</span> _debug(<span class="type">char</span>* f,Ty x,Ar... y)&#123;<span class="keyword">while</span>(*f!=<span class="string">&#x27;,&#x27;</span>) cerr&lt;&lt;*f++;cerr&lt;&lt;<span class="string">&#x27;=&#x27;</span>&lt;&lt;x&lt;&lt;<span class="string">&quot;,&quot;</span>;_debug(f+<span class="number">1</span>,y...);&#125;</span><br><span class="line">	Tp ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; os,vector&lt;Ty&gt;&amp; V)&#123;os&lt;&lt;<span class="string">&quot;[&quot;</span>;<span class="keyword">for</span>(<span class="keyword">auto</span>&amp; vv:V) os&lt;&lt;vv&lt;&lt;<span class="string">&quot;,&quot;</span>;os&lt;&lt;<span class="string">&quot;]&quot;</span>;<span class="keyword">return</span> os;&#125;</span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> gdb(...) _debug((char*)#__VA_ARGS__,__VA_ARGS__)</span></span><br><span class="line">&#125;<span class="keyword">using</span> <span class="keyword">namespace</span> Debug;</span><br><span class="line"><span class="type">int</span> n,a[maxn];</span><br><span class="line"><span class="type">int</span> sum;</span><br><span class="line"><span class="type">int</span> id1,id2,t[maxn],nex[maxn]; </span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">  	<span class="built_in">freopen</span>(<span class="string">&quot;carve.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">  	<span class="built_in">freopen</span>(<span class="string">&quot;carve.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout);</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="built_in">read</span>(n);</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">read</span>(a[i]);</span><br><span class="line">	<span class="keyword">for</span> (i=n;i&gt;=<span class="number">1</span>;i--) nex[i]=t[a[i]]==<span class="number">0</span>?n+<span class="number">1</span>:t[a[i]],t[a[i]]=i;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (a[id1]==a[i]) id1=i;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (a[id2]==a[i]) id2=i;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (!id1) id1=i,sum++;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (!id2) id2=i,sum++;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			sum++;</span><br><span class="line">			<span class="keyword">if</span> (nex[id1]&gt;nex[id2]) id1=i;</span><br><span class="line">			<span class="keyword">else</span> id2=i;</span><br><span class="line">		&#125; </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,sum);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="T3-sword"><a href="#T3-sword" class="headerlink" title="T3. sword"></a>T3. sword</h2><h3 id="Description-2"><a href="#Description-2" class="headerlink" title="Description"></a>Description</h3><p>给定 $1$ 个长度为 $n$ 的正整数序列 $a$。每次操作可以选择 $a_i$ 加 $1$ 或者减 $1$，但需要满足 $a_i$ 为正数。</p>
<p>求让 $\gcd(a_1,a_2,a_3,…,a_n)&gt;1$ 的最少操作次数。</p>
<p>$n\le 2\times 10^5,a_i\le 1\times 10^{12}$</p>
<p>1s 512MB</p>
<h3 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution"></a>Solution</h3><p><strong>很有意思的题目！</strong></p>
<p>一种显然的想法就是枚举质数 $p$ ，如果答案为 $p$ 的倍数的最小操作次数。这样做是 $O(n)$ 的。</p>
<p>注意到 $p&#x3D;2$ 时，答案 $\le n$。</p>
<p>考虑使枚举质数 $p$ 的次数变少。观察到操作次数不超过 $1$ 的个数有至少有 $\dfrac{n}{2}$ 个。考虑随机出一个数 $a_i$，枚举 $a_i-1,a_i,a_i+1$ 三个数的质因子。多随几个，保证正确率。随机 $n$ 次的错误率是 $(1&#x2F;2)^n$。</p>
<p>我的考场做法是枚举 $[a_i-100,a_i+100]$ 的质因子。这样做效率显然是没有上面高的。但是能过&#x2F;shl</p>
<p><strong>下次随机化必写卡时，警戒</strong></p>
<h3 id="Code1-考场代码"><a href="#Code1-考场代码" class="headerlink" title="Code1 考场代码"></a>Code1 考场代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 200005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> put() putchar(<span class="string">&#x27;\n&#x27;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Tp template<span class="string">&lt;typename Ty&gt;</span>N</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Ts template<span class="string">&lt;typename Ty,typename... Ar&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(<span class="type">int</span> &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> f=<span class="number">1</span>;x=<span class="number">0</span>;<span class="type">char</span> c=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (c&lt;<span class="string">&#x27;0&#x27;</span>||c&gt;<span class="string">&#x27;9&#x27;</span>) &#123;<span class="keyword">if</span> (c==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">-1</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span> (c&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;c&lt;=<span class="string">&#x27;9&#x27;</span>) &#123;x=x*<span class="number">10</span>+c-<span class="string">&#x27;0&#x27;</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> Debug&#123;</span><br><span class="line">	Tp <span class="type">void</span> _debug(<span class="type">char</span>* f,Ty t)&#123;cerr&lt;&lt;f&lt;&lt;<span class="string">&#x27;=&#x27;</span>&lt;&lt;t&lt;&lt;endl;&#125;</span><br><span class="line">	Ts <span class="type">void</span> _debug(<span class="type">char</span>* f,Ty x,Ar... y)&#123;<span class="keyword">while</span>(*f!=<span class="string">&#x27;,&#x27;</span>) cerr&lt;&lt;*f++;cerr&lt;&lt;<span class="string">&#x27;=&#x27;</span>&lt;&lt;x&lt;&lt;<span class="string">&quot;,&quot;</span>;_debug(f+<span class="number">1</span>,y...);&#125;</span><br><span class="line">	Tp ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; os,vector&lt;Ty&gt;&amp; V)&#123;os&lt;&lt;<span class="string">&quot;[&quot;</span>;<span class="keyword">for</span>(<span class="keyword">auto</span>&amp; vv:V) os&lt;&lt;vv&lt;&lt;<span class="string">&quot;,&quot;</span>;os&lt;&lt;<span class="string">&quot;]&quot;</span>;<span class="keyword">return</span> os;&#125;</span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> gdb(...) _debug((char*)#__VA_ARGS__,__VA_ARGS__)</span></span><br><span class="line">&#125;<span class="keyword">using</span> <span class="keyword">namespace</span> Debug;</span><br><span class="line"><span class="type">int</span> n,a[maxn],Ans=<span class="number">1e9</span>,Max=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">calc</span><span class="params">(<span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> i,sum=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) </span><br><span class="line">		<span class="keyword">if</span> (a[i]&lt;k) sum+=k-a[i];</span><br><span class="line">		<span class="keyword">else</span> sum+=<span class="built_in">min</span>(a[i]-a[i]/k*k,(a[i]/k+<span class="number">1</span>)*(k)-a[i]);</span><br><span class="line">	<span class="keyword">return</span> sum; </span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> prime[<span class="number">1000005</span>],cnt,vis[<span class="number">1000005</span>];</span><br><span class="line"><span class="function">mt19937 <span class="title">rnd</span><span class="params">(time(<span class="number">0</span>))</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">	vis[<span class="number">1</span>]=<span class="number">1</span>;<span class="type">int</span> i,j;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">2</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!vis[i]) prime[++cnt]=i;</span><br><span class="line">		<span class="keyword">for</span> (j=<span class="number">1</span>;j&lt;=cnt&amp;&amp;prime[j]*i&lt;=n;j++) &#123;</span><br><span class="line">			vis[prime[j]*i]=<span class="number">1</span>;</span><br><span class="line">			<span class="keyword">if</span> (i%prime[j]==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> BL&#123;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">		<span class="type">int</span> i;</span><br><span class="line">		<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=cnt&amp;&amp;prime[i]&lt;=Max;i++) &#123;</span><br><span class="line">			Ans=<span class="built_in">min</span>(Ans,<span class="built_in">calc</span>(prime[i]));</span><br><span class="line">		&#125; </span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,Ans);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> STD&#123;</span><br><span class="line">	<span class="type">int</span> p[<span class="number">1000005</span>],tot;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">		<span class="type">int</span> i,now=x;</span><br><span class="line">		<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=cnt&amp;&amp;prime[i]*prime[i]&lt;=x;i++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (now==<span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">if</span> (now%prime[i]==<span class="number">0</span>) &#123;</span><br><span class="line">				p[++tot]=prime[i];</span><br><span class="line">				<span class="keyword">while</span> (now%prime[i]==<span class="number">0</span>) now/=prime[i];</span><br><span class="line">			&#125; </span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (now&gt;<span class="number">1</span>) p[++tot]=now;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">		<span class="type">int</span> i,id1;</span><br><span class="line">		id1=<span class="built_in">rnd</span>()%n+<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span> (i=<span class="built_in">max</span>(a[id1]<span class="number">-100</span>,<span class="number">1ll</span>);i&lt;=a[id1]+<span class="number">100</span>;i++) <span class="built_in">solve</span>(i);</span><br><span class="line">		<span class="built_in">sort</span>(p+<span class="number">1</span>,p+<span class="number">1</span>+tot);</span><br><span class="line">		tot=<span class="built_in">unique</span>(p+<span class="number">1</span>,p+<span class="number">1</span>+tot)-p<span class="number">-1</span>;</span><br><span class="line">		<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=tot;i++) Ans=<span class="built_in">min</span>(Ans,<span class="built_in">calc</span>(p[i]));</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,Ans);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;sword.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">  	<span class="built_in">freopen</span>(<span class="string">&quot;sword.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout);</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="built_in">read</span>(n);</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">read</span>(a[i]),Max=<span class="built_in">max</span>(Max,a[i]); </span><br><span class="line">	<span class="built_in">init</span>(<span class="number">1e6</span>);</span><br><span class="line">	<span class="keyword">if</span> (Max&lt;=<span class="number">1e3</span>) BL::<span class="built_in">main</span>();<span class="keyword">else</span> </span><br><span class="line">	STD::<span class="built_in">main</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Code2-std"><a href="#Code2-std" class="headerlink" title="Code2 std"></a>Code2 std</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Tp template<span class="string">&lt;typename Ty&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Ts template<span class="string">&lt;typename Ty,typename... Ar&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Reg register</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RI Reg int</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Con const</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CI Con int&amp;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I inline</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> W while</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 200000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> V 1000000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LL long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n;LL a[N+<span class="number">5</span>],p[N*<span class="number">30</span>];set&lt;LL&gt; vis;</span><br><span class="line"><span class="keyword">namespace</span> FastIO</span><br><span class="line">&#123;</span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> FS 100000</span></span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> tc() (FA==FB&amp;&amp;(FB=(FA=FI)+fread(FI,1,FS,stdin),FA==FB)?EOF:*FA++)</span></span><br><span class="line">	<span class="type">char</span> oc,FI[FS],*FA=FI,*FB=FI;</span><br><span class="line">	<span class="function">Tp I <span class="type">void</span> <span class="title">read</span><span class="params">(Ty&amp; x)</span> </span>&#123;x=<span class="number">0</span>;<span class="built_in">W</span>(!<span class="built_in">isdigit</span>(oc=<span class="built_in">tc</span>()));<span class="built_in">W</span>(x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(oc&amp;<span class="number">15</span>),<span class="built_in">isdigit</span>(oc=<span class="built_in">tc</span>()));&#125;</span><br><span class="line">	<span class="function">Ts I <span class="type">void</span> <span class="title">read</span><span class="params">(Ty&amp; x,Ar&amp;... y)</span> </span>&#123;<span class="built_in">read</span>(x),<span class="built_in">read</span>(y...);&#125;</span><br><span class="line">&#125;<span class="keyword">using</span> <span class="keyword">namespace</span> FastIO;</span><br><span class="line"><span class="type">int</span> Pt,P[V+<span class="number">5</span>];<span class="function">I <span class="type">void</span> <span class="title">Sieve</span><span class="params">()</span> </span>&#123;<span class="keyword">for</span>(RI i=<span class="number">2</span>,j;i&lt;=V;++i)</span><br><span class="line">	<span class="keyword">for</span>(!P[i]&amp;&amp;(P[++Pt]=i),j=<span class="number">1</span>;j&lt;=Pt&amp;&amp;i*P[j]&lt;=V;++j) <span class="keyword">if</span>(P[i*P[j]]=<span class="number">1</span>,!(i%P[j])) <span class="keyword">break</span>;&#125;</span><br><span class="line"><span class="type">int</span> ans;<span class="function">I <span class="type">void</span> <span class="title">Check</span><span class="params">(Con LL&amp; x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(vis.<span class="built_in">find</span>(x)!=vis.<span class="built_in">end</span>()) <span class="keyword">return</span>;vis.<span class="built_in">insert</span>(x);</span><br><span class="line">	LL res=<span class="number">0</span>;<span class="keyword">for</span>(RI i=<span class="number">1</span>;i&lt;=n&amp;&amp;res&lt;ans;++i) res+=a[i]&lt;x?x-a[i]:<span class="built_in">min</span>(a[i]%x,x-a[i]%x);</span><br><span class="line">	ans&gt;res&amp;&amp;(ans=res);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">I <span class="type">void</span> <span class="title">Work</span><span class="params">(LL x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(RI i=<span class="number">1</span>;i&lt;=Pt&amp;&amp;P[i]&lt;=x;++i) <span class="keyword">if</span>(!(x%P[i])) &#123;<span class="built_in">Check</span>(P[i]);<span class="built_in">W</span>(!(x%P[i])) x/=P[i];&#125;</span><br><span class="line">	x^<span class="number">1</span>&amp;&amp;(<span class="built_in">Check</span>(x),<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;sword.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin),<span class="built_in">freopen</span>(<span class="string">&quot;sword.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout);</span><br><span class="line">	RI T,i;LL x;<span class="keyword">for</span>(<span class="built_in">srand</span>(<span class="number">998244353</span>),<span class="built_in">Sieve</span>(),<span class="built_in">read</span>(n),i=<span class="number">1</span>;i&lt;=n;++i) <span class="built_in">read</span>(a[i]);</span><br><span class="line">	<span class="keyword">for</span>(ans=n,T=<span class="number">1</span>;T&lt;=<span class="number">30</span>;++T) x=a[<span class="number">1ull</span>*<span class="built_in">rand</span>()*<span class="built_in">rand</span>()*<span class="built_in">rand</span>()%n+<span class="number">1</span>],<span class="built_in">Work</span>(x),<span class="built_in">Work</span>(x+<span class="number">1</span>),x^<span class="number">1</span>&amp;&amp;(<span class="built_in">Work</span>(x<span class="number">-1</span>),<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans),<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="T4-war"><a href="#T4-war" class="headerlink" title="T4. war"></a>T4. war</h2><h3 id="Description-3"><a href="#Description-3" class="headerlink" title="Description"></a>Description</h3><p><img src="https://s2.loli.net/2023/07/12/uXIyD3AjgPmLxUi.png" alt="image-20230712202641404"></p>
<p>$n\le 5\times 10^5$ </p>
<p>同 <a href="https://www.luogu.com.cn/problem/CF798E">CF798E</a></p>
<p>注意空间限制。</p>
<h3 id="Solution-3"><a href="#Solution-3" class="headerlink" title="Solution"></a>Solution</h3><p>方心童说这个东西叫做 <strong>“线段树隐式建图”</strong>，反正是我没见过的。</p>
<p>空间为 $O(n^2)$ 的暴力是显然的。</p>
<h4 id="Step-1"><a href="#Step-1" class="headerlink" title="Step 1"></a>Step 1</h4><p>方便起见，将等于 $-1$ 的 $a_i$ 改成 $n+1$。同时，记 $p_x$ 为满足 $a_i&#x3D;x$ 的 $i$ （$x$ 的前驱），如果没有就记为 $n+1$。</p>
<p>注意到其实对于所有 $i$ 满足：</p>
<ul>
<li>$f_{p_i}&lt;f_i$</li>
<li>对于满足 $j&lt;a_i$ 且 $p_j&gt;i$ 的 $j$ ，$f_j&lt;f_i$</li>
</ul>
<p>注意到建出这两类有向边以后，跑拓扑排序。$f_i$ 即为其拓扑序。容易发现条件是充要的。</p>
<h4 id="Step-2"><a href="#Step-2" class="headerlink" title="Step 2"></a>Step 2</h4><p>有一个叫做 <strong>dfs 拓扑排序</strong> 的东西，过程如下：</p>
<ul>
<li><p>建反向边</p>
</li>
<li><p>从 $i$ 进入，由 $i$ 出发的反向边，搜从没有经历过的点</p>
</li>
<li><p>都搜完以后，时间戳 $t\Leftarrow t+1$，作为 $i$ 的拓扑序。</p>
</li>
</ul>
<p>正确性是显然。每条边和每个点只会经过一次，复杂度上是 $O(n+m)$ 的。</p>
<h4 id="Step-3"><a href="#Step-3" class="headerlink" title="Step 3"></a>Step 3</h4><p>考虑套用这个过程。</p>
<p>对于第一类边，只有 $O(n)$ 条，直接跑。</p>
<p>对于第二类边，每次<strong>不断</strong>找 $j&lt;a_i$ 中 $p_j$ 最大的，如果 $&gt;i$ ，则继续搜。由于一个点只会经过一次，找到 $j$ 以后删掉即可。</p>
<p>每个点只会删一次和经过一次，复杂度是 $O(n\log n)$ 的。</p>
<p>空间上，只有线段树和一些线性数组，甚至没有建边，空间复杂度是 $O(n)$ 的。这可能也是 <strong>隐式建图</strong> 的来源。</p>
<h3 id="Code-2"><a href="#Code-2" class="headerlink" title="Code"></a>Code</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 500005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> M 4000005 </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> put() putchar(<span class="string">&#x27;\n&#x27;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Tp template<span class="string">&lt;typename Ty&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Ts template<span class="string">&lt;typename Ty,typename... Ar&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(<span class="type">int</span> &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> f=<span class="number">1</span>;x=<span class="number">0</span>;<span class="type">char</span> c=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (c&lt;<span class="string">&#x27;0&#x27;</span>||c&gt;<span class="string">&#x27;9&#x27;</span>) &#123;<span class="keyword">if</span> (c==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">-1</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span> (c&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;c&lt;=<span class="string">&#x27;9&#x27;</span>) &#123;x=x*<span class="number">10</span>+c-<span class="string">&#x27;0&#x27;</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> Debug&#123;</span><br><span class="line">	Tp <span class="type">void</span> _debug(<span class="type">char</span>* f,Ty t)&#123;cerr&lt;&lt;f&lt;&lt;<span class="string">&#x27;=&#x27;</span>&lt;&lt;t&lt;&lt;endl;&#125;</span><br><span class="line">	Ts <span class="type">void</span> _debug(<span class="type">char</span>* f,Ty x,Ar... y)&#123;<span class="keyword">while</span>(*f!=<span class="string">&#x27;,&#x27;</span>) cerr&lt;&lt;*f++;cerr&lt;&lt;<span class="string">&#x27;=&#x27;</span>&lt;&lt;x&lt;&lt;<span class="string">&quot;,&quot;</span>;_debug(f+<span class="number">1</span>,y...);&#125;</span><br><span class="line">	Tp ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; os,vector&lt;Ty&gt;&amp; V)&#123;os&lt;&lt;<span class="string">&quot;[&quot;</span>;<span class="keyword">for</span>(<span class="keyword">auto</span>&amp; vv:V) os&lt;&lt;vv&lt;&lt;<span class="string">&quot;,&quot;</span>;os&lt;&lt;<span class="string">&quot;]&quot;</span>;<span class="keyword">return</span> os;&#125;</span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> gdb(...) _debug((char*)#__VA_ARGS__,__VA_ARGS__)</span></span><br><span class="line">&#125;<span class="keyword">using</span> <span class="keyword">namespace</span> Debug;</span><br><span class="line"><span class="type">int</span> n,b[maxn];</span><br><span class="line"><span class="type">int</span> in[maxn],Ans[maxn],times;</span><br><span class="line"><span class="type">int</span> pre[maxn],f[maxn&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Pushup</span><span class="params">(<span class="type">int</span> rt)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!f[rt&lt;&lt;<span class="number">1</span>]||!f[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]) f[rt]=f[rt&lt;&lt;<span class="number">1</span>]+f[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>];</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (pre[f[rt&lt;&lt;<span class="number">1</span>]]&gt;pre[f[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]]) f[rt]=f[rt&lt;&lt;<span class="number">1</span>];</span><br><span class="line">		<span class="keyword">else</span> f[rt]=f[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]; </span><br><span class="line">	&#125;  </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Update</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> rt,<span class="type">int</span> head,<span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (l==r) <span class="keyword">return</span> f[rt]=k,<span class="built_in">void</span>();</span><br><span class="line">	<span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span> (head&lt;=mid) <span class="built_in">Update</span>(l,mid,rt&lt;&lt;<span class="number">1</span>,head,k);</span><br><span class="line">	<span class="keyword">else</span> <span class="built_in">Update</span>(mid+<span class="number">1</span>,r,rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,head,k);</span><br><span class="line">	<span class="built_in">Pushup</span>(rt);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">Query</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> rt,<span class="type">int</span> head,<span class="type">int</span> tail)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (head&lt;=l&amp;&amp;r&lt;=tail) <span class="keyword">return</span> f[rt];</span><br><span class="line">	<span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>,tmp1=<span class="number">0</span>,tmp2=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (head&lt;=mid) tmp1=<span class="built_in">Query</span>(l,mid,rt&lt;&lt;<span class="number">1</span>,head,tail);</span><br><span class="line">	<span class="keyword">if</span> (tail&gt;mid)  tmp2=<span class="built_in">Query</span>(mid+<span class="number">1</span>,r,rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,head,tail);</span><br><span class="line">	<span class="keyword">if</span> (tmp1&amp;&amp;tmp2) &#123;</span><br><span class="line">		<span class="keyword">if</span> (pre[tmp1]&gt;pre[tmp2]) <span class="keyword">return</span> tmp1;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">return</span> tmp2;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> tmp1+tmp2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> vis[maxn];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (Ans[x]||vis[x]) <span class="keyword">return</span> ;</span><br><span class="line">	<span class="type">int</span> tmp;vis[x]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span> (pre[x]&lt;=n) <span class="built_in">dfs</span>(pre[x]);</span><br><span class="line">	<span class="keyword">if</span> (b[x]&gt;<span class="number">1</span>) &#123;</span><br><span class="line">		<span class="keyword">while</span> ((tmp=<span class="built_in">Query</span>(<span class="number">1</span>,n,<span class="number">1</span>,<span class="number">1</span>,b[x]<span class="number">-1</span>))&amp;&amp;pre[tmp]&gt;x) &#123;</span><br><span class="line">			<span class="built_in">Update</span>(<span class="number">1</span>,n,<span class="number">1</span>,tmp,<span class="number">0</span>);</span><br><span class="line">			<span class="built_in">dfs</span>(tmp);</span><br><span class="line">		&#125;	</span><br><span class="line">	&#125;</span><br><span class="line">	Ans[x]=++times;</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line"> 	<span class="built_in">freopen</span>(<span class="string">&quot;war.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">  	<span class="built_in">freopen</span>(<span class="string">&quot;war.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout);</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="built_in">read</span>(n);</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) pre[i]=n+<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="built_in">read</span>(b[i]);</span><br><span class="line">		<span class="keyword">if</span> (b[i]!=<span class="number">-1</span>) pre[b[i]]=i;<span class="keyword">else</span> b[i]=n+<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">Update</span>(<span class="number">1</span>,n,<span class="number">1</span>,i,i);</span><br><span class="line">	<span class="built_in">gdb</span>(n);</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) <span class="keyword">if</span> (!Ans[i]) <span class="built_in">dfs</span>(i); </span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,Ans[i]);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>NOIP模拟赛</tag>
        <tag>线段树优化建图</tag>
        <tag>随机化</tag>
      </tags>
  </entry>
  <entry>
    <title>7.13 模拟赛T3</title>
    <url>/2023/09/20/7-13-%E6%A8%A1%E6%8B%9F%E8%B5%9BT3/</url>
    <content><![CDATA[<h1 id="7-13-模拟赛-T3"><a href="#7-13-模拟赛-T3" class="headerlink" title="7.13 模拟赛 T3"></a>7.13 模拟赛 T3</h1><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p><img src="https://s2.loli.net/2023/09/20/6zqhUCZ2RD3EVPo.png" alt="image-20230920165751994"></p>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>令 $f_S,g_S$ 表示从 $1$ 和 $2$ 恰好到达点集 $S$ 的方案数，注意此方案只定 $S$ 内部的边。令 $s_S$ 表示点集 $S$ 内部的点。</p>
<p>考虑容斥，先令 $f_S&#x3D;2^{s_S}$，表示内部随意定向，外部点指向 $S$ 。然后减去到达不了的个数。</p>
<p>考虑经典容斥（<a href="https://wgyhm.top/2023/08/30/P3343-ZJOI2015-%E5%9C%B0%E9%9C%87%E5%90%8E%E7%9A%84%E5%B9%BB%E6%83%B3%E4%B9%A1/">地震后的幻想乡？</a>)，枚举包含 $1$ 的可以到达的点集 $S’$，然后钦定外部点内部随意，最外层都指向 $S’$，也就是减去 $f_{S’}\times2^{s_{S-S’}}$。</p>
<p>$g$ 同理。</p>
<p>后考虑算出答案。还是用容斥，令 $ans&#x3D;2^m$。减去 $1$ 和 $2$ 到达的点不相交的数量。考虑枚举 $1$ 到达的点集 $S$，$2$ 到达的点集 $T$。注意此时 $S$ 相邻的点集 $h_S$ 和 $T$ 不能相交，不然交集的定向会与定义矛盾。而剩下情况都可以满足，乘上 $S,T$ 之外的点内部随意定向即可。</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> put() putchar(<span class="string">&#x27;\n&#x27;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Tp template<span class="string">&lt;typename Ty&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Ts template<span class="string">&lt;typename Ty,typename... Ar&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(<span class="type">int</span> &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> f=<span class="number">1</span>;x=<span class="number">0</span>;<span class="type">char</span> c=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (c&lt;<span class="string">&#x27;0&#x27;</span>||c&gt;<span class="string">&#x27;9&#x27;</span>) &#123;<span class="keyword">if</span> (c==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">-1</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span> (c&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;c&lt;=<span class="string">&#x27;9&#x27;</span>) &#123;x=x*<span class="number">10</span>+c-<span class="string">&#x27;0&#x27;</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> Debug&#123;</span><br><span class="line">	Tp <span class="type">void</span> _debug(<span class="type">char</span>* f,Ty t)&#123;cerr&lt;&lt;f&lt;&lt;<span class="string">&#x27;=&#x27;</span>&lt;&lt;t&lt;&lt;endl;&#125;</span><br><span class="line">	Ts <span class="type">void</span> _debug(<span class="type">char</span>* f,Ty x,Ar... y)&#123;<span class="keyword">while</span>(*f!=<span class="string">&#x27;,&#x27;</span>) cerr&lt;&lt;*f++;cerr&lt;&lt;<span class="string">&#x27;=&#x27;</span>&lt;&lt;x&lt;&lt;<span class="string">&quot;,&quot;</span>;_debug(f+<span class="number">1</span>,y...);&#125;</span><br><span class="line">	Tp ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; os,vector&lt;Ty&gt;&amp; V)&#123;os&lt;&lt;<span class="string">&quot;[&quot;</span>;<span class="keyword">for</span>(<span class="keyword">auto</span>&amp; vv:V) os&lt;&lt;vv&lt;&lt;<span class="string">&quot;,&quot;</span>;os&lt;&lt;<span class="string">&quot;]&quot;</span>;<span class="keyword">return</span> os;&#125;</span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> gdb(...) _debug((char*)#__VA_ARGS__,__VA_ARGS__)</span></span><br><span class="line">&#125;<span class="keyword">using</span> <span class="keyword">namespace</span> Debug;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">998244353</span>;</span><br><span class="line"><span class="type">int</span> f[(<span class="number">1</span>&lt;&lt;<span class="number">17</span>)+<span class="number">5</span>],g[(<span class="number">1</span>&lt;&lt;<span class="number">17</span>)+<span class="number">5</span>],s[(<span class="number">1</span>&lt;&lt;<span class="number">17</span>)+<span class="number">5</span>],h[(<span class="number">1</span>&lt;&lt;<span class="number">17</span>)+<span class="number">5</span>];</span><br><span class="line"><span class="type">int</span> n,m,pw[<span class="number">505</span>],ans;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">yyy</span>&#123;</span><br><span class="line">	<span class="type">int</span> x,y;</span><br><span class="line">&#125;e[<span class="number">505</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> &amp;x,<span class="type">int</span> y)</span> </span>&#123;x=(x+y)%mod;&#125;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;to[<span class="number">17</span>];</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;silver.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">  	<span class="built_in">freopen</span>(<span class="string">&quot;silver.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout);</span><br><span class="line">	<span class="type">int</span> i,j;</span><br><span class="line">	<span class="built_in">read</span>(n);<span class="built_in">read</span>(m);</span><br><span class="line">	<span class="keyword">for</span> (pw[<span class="number">0</span>]=<span class="number">1</span>,i=<span class="number">1</span>;i&lt;=m;i++) pw[i]=pw[i<span class="number">-1</span>]*<span class="number">2</span>%mod;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=m;i++) &#123;</span><br><span class="line">		<span class="built_in">read</span>(e[i].x),<span class="built_in">read</span>(e[i].y);</span><br><span class="line">		e[i].x--;e[i].y--;</span><br><span class="line">		to[e[i].x].<span class="built_in">push_back</span>(e[i].y);</span><br><span class="line">		to[e[i].y].<span class="built_in">push_back</span>(e[i].x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line">		h[<span class="number">1</span>&lt;&lt;i]=(<span class="number">1</span>&lt;&lt;i);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> y:to[i]) h[<span class="number">1</span>&lt;&lt;i]|=(<span class="number">1</span>&lt;&lt;y);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> N=(<span class="number">1</span>&lt;&lt;n);</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;N;i++) &#123;</span><br><span class="line">		<span class="type">int</span> tmp=__builtin_ctzll(i);</span><br><span class="line">		h[i]=h[i^(<span class="number">1</span>&lt;&lt;tmp)]|h[<span class="number">1</span>&lt;&lt;tmp];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;N;i++) &#123;</span><br><span class="line">		<span class="type">int</span> tmp=__builtin_ctzll(i);</span><br><span class="line">		s[i]+=s[i^(<span class="number">1</span>&lt;&lt;tmp)];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> y:to[tmp]) <span class="keyword">if</span> ((i&gt;&gt;y)&amp;<span class="number">1</span>) s[i]++;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;N;i+=<span class="number">4</span>) <span class="keyword">if</span> (i&amp;<span class="number">1</span>) &#123;</span><br><span class="line">		f[i]=pw[s[i]];</span><br><span class="line">		<span class="keyword">for</span> (j=i&amp;(i<span class="number">-1</span>);j;j=(j<span class="number">-1</span>)&amp;i) <span class="keyword">if</span> (j&amp;<span class="number">1</span>) <span class="built_in">add</span>(f[i],mod-f[j]*pw[s[i^j]]%mod);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">2</span>;i&lt;N;i+=<span class="number">4</span>) <span class="keyword">if</span> ((i&gt;&gt;<span class="number">1</span>)&amp;<span class="number">1</span>) &#123;</span><br><span class="line">		g[i]=pw[s[i]];</span><br><span class="line">		<span class="keyword">for</span> (j=i&amp;(i<span class="number">-1</span>);j;j=(j<span class="number">-1</span>)&amp;i) <span class="keyword">if</span> ((j&gt;&gt;<span class="number">1</span>)&amp;<span class="number">1</span>) <span class="built_in">add</span>(g[i],mod-g[j]*pw[s[i^j]]%mod);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;N;i++) <span class="keyword">if</span> (i&amp;<span class="number">1</span>)&#123;</span><br><span class="line">		<span class="type">int</span> tmp=(i^(N<span class="number">-1</span>));</span><br><span class="line">		<span class="keyword">for</span> (j=tmp&amp;(tmp<span class="number">-1</span>);j;j=(j<span class="number">-1</span>)&amp;tmp) &#123;</span><br><span class="line">			<span class="type">int</span> T=j;</span><br><span class="line">			<span class="keyword">if</span> ((T&gt;&gt;<span class="number">1</span>)%<span class="number">2</span>&amp;&amp;(h[i]&amp;T)==<span class="number">0</span>) &#123;</span><br><span class="line">				<span class="built_in">add</span>(ans,f[i]*g[T]%mod*pw[s[(N<span class="number">-1</span>)^i^T]]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,(pw[m]-ans+mod)%mod);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>NOIP模拟赛</tag>
        <tag>dp</tag>
        <tag>容斥</tag>
      </tags>
  </entry>
  <entry>
    <title>10.04 模拟赛 by FXT&#39;</title>
    <url>/2023/10/05/10-04-%E6%A8%A1%E6%8B%9F%E8%B5%9B-by-FXT/</url>
    <content><![CDATA[<h1 id="10-04-模拟赛"><a href="#10-04-模拟赛" class="headerlink" title="10.04 模拟赛"></a>10.04 模拟赛</h1><p>抵制打包，抵制打包，抵制打包！</p>
<h2 id="T1"><a href="#T1" class="headerlink" title="T1"></a>T1</h2><p>JOISC 2022 D3T2 Sprinkler</p>
<p><a href="https://loj.ac/p/3692">https://loj.ac/p/3692</a></p>
<h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><p>观察到模数不是质数，像点分树一样，如果到这个点的意义是距离小于等于这个点 $d$ 乘上 $x$，把距离这个点为 $d,d-1$ 的打上标记，然后往上继续做。观察到如果一个点在范围里，那么有且仅有会被乘上一次。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 400505</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> put() putchar(<span class="string">&#x27;\n&#x27;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Tp template<span class="string">&lt;typename Ty&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Ts template<span class="string">&lt;typename Ty,typename... Ar&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">(<span class="type">int</span> &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> f=<span class="number">1</span>;x=<span class="number">0</span>;<span class="type">char</span> c=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (c&lt;<span class="string">&#x27;0&#x27;</span>||c&gt;<span class="string">&#x27;9&#x27;</span>) &#123;<span class="keyword">if</span> (c==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">-1</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span> (c&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;c&lt;=<span class="string">&#x27;9&#x27;</span>) &#123;x=x*<span class="number">10</span>+c-<span class="string">&#x27;0&#x27;</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> Debug&#123;</span><br><span class="line">	Tp <span class="type">void</span> _debug(<span class="type">char</span>* f,Ty t)&#123;cerr&lt;&lt;f&lt;&lt;<span class="string">&#x27;=&#x27;</span>&lt;&lt;t&lt;&lt;endl;&#125;</span><br><span class="line">	Ts <span class="type">void</span> _debug(<span class="type">char</span>* f,Ty x,Ar... y)&#123;<span class="keyword">while</span>(*f!=<span class="string">&#x27;,&#x27;</span>) cerr&lt;&lt;*f++;cerr&lt;&lt;<span class="string">&#x27;=&#x27;</span>&lt;&lt;x&lt;&lt;<span class="string">&quot;,&quot;</span>;_debug(f+<span class="number">1</span>,y...);&#125;</span><br><span class="line">	Tp ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; os,vector&lt;Ty&gt;&amp; V)&#123;os&lt;&lt;<span class="string">&quot;[&quot;</span>;<span class="keyword">for</span>(<span class="keyword">auto</span>&amp; vv:V) os&lt;&lt;vv&lt;&lt;<span class="string">&quot;,&quot;</span>;os&lt;&lt;<span class="string">&quot;]&quot;</span>;<span class="keyword">return</span> os;&#125;</span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> gdb(...) _debug((char*)#__VA_ARGS__,__VA_ARGS__)</span></span><br><span class="line">&#125;<span class="keyword">using</span> <span class="keyword">namespace</span> Debug;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mk make_pair</span></span><br><span class="line"><span class="type">int</span> mod;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">power</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y=mod<span class="number">-2</span>)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> sum=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (y) &#123;</span><br><span class="line">		<span class="keyword">if</span> (y&amp;<span class="number">1</span>) sum=sum*x%mod;</span><br><span class="line">		x=x*x%mod;y&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,p;</span><br><span class="line"><span class="type">int</span> fa[maxn];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;to[maxn];</span><br><span class="line"><span class="type">int</span> w[maxn][<span class="number">41</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> pre)</span> </span>&#123;</span><br><span class="line">	fa[x]=pre;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> y:to[x]) <span class="keyword">if</span> (y^pre) &#123;</span><br><span class="line">		<span class="built_in">dfs1</span>(y,x);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> i,x,y,op,val,d,j,q;</span><br><span class="line">	<span class="built_in">read</span>(n);<span class="built_in">read</span>(mod);</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;n;i++) &#123;</span><br><span class="line">		<span class="built_in">read</span>(x),<span class="built_in">read</span>(y);</span><br><span class="line">		to[x].<span class="built_in">push_back</span>(y);</span><br><span class="line">		to[y].<span class="built_in">push_back</span>(x);</span><br><span class="line">	&#125;</span><br><span class="line">	to[n+<span class="number">1</span>].<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span> (i=n+<span class="number">2</span>;i&lt;=n+<span class="number">40</span>;i++) to[i].<span class="built_in">push_back</span>(i<span class="number">-1</span>);</span><br><span class="line">	<span class="type">int</span> root=n+<span class="number">40</span>;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=root;i++) <span class="keyword">for</span> (j=<span class="number">0</span>;j&lt;=<span class="number">40</span>;j++) w[i][j]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">read</span>(w[i][<span class="number">0</span>]);</span><br><span class="line">	<span class="built_in">dfs1</span>(root,<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">read</span>(q);</span><br><span class="line">	<span class="keyword">while</span> (q--) &#123;</span><br><span class="line">		<span class="built_in">read</span>(op);<span class="built_in">read</span>(x);</span><br><span class="line">		<span class="keyword">if</span> (op==<span class="number">1</span>) &#123;</span><br><span class="line">			<span class="built_in">read</span>(d);<span class="built_in">read</span>(val);</span><br><span class="line">			<span class="type">int</span> dis=<span class="number">0</span>,res=d;</span><br><span class="line">			<span class="keyword">for</span> (x;res&gt;=<span class="number">0</span>;dis++,x=fa[x]) &#123;</span><br><span class="line">				w[x][res]=w[x][res]*val%mod;</span><br><span class="line">				<span class="keyword">if</span> (res) w[x][res<span class="number">-1</span>]=w[x][res<span class="number">-1</span>]*val%mod;</span><br><span class="line">				res--;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="type">int</span> ans=<span class="number">1</span>,dis=<span class="number">0</span>;</span><br><span class="line">			<span class="keyword">for</span> (;dis&lt;=<span class="number">40</span>;dis++,x=fa[x]) ans=ans*w[x][dis]%mod;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="T2"><a href="#T2" class="headerlink" title="T2"></a>T2</h2><p>JOISC 2023 D4T3 Bitaro’s travel QOJ 6343</p>
<h3 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution"></a>Solution</h3><p>观察到如果拐一次弯，那么走过的区间长度至少乘 $2$，所以转弯次数是 $O(\log v)$ 次的。</p>
<p>然后我们就想到怎么暴力找到拐弯的地方。令 $r_x$ 表示如果区间左端点在 $x$，右端点最多在 $r_x$ 时，都往右边走。然后每次枚举转向二分一下就好了。区间询问 $r$ 预处理出来。向左也是一样。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 200005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> put() putchar(<span class="string">&#x27;\n&#x27;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Tp template<span class="string">&lt;typename Ty&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Ts template<span class="string">&lt;typename Ty,typename... Ar&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">(<span class="type">int</span> &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> f=<span class="number">1</span>;x=<span class="number">0</span>;<span class="type">char</span> c=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (c&lt;<span class="string">&#x27;0&#x27;</span>||c&gt;<span class="string">&#x27;9&#x27;</span>) &#123;<span class="keyword">if</span> (c==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">-1</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span> (c&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;c&lt;=<span class="string">&#x27;9&#x27;</span>) &#123;x=x*<span class="number">10</span>+c-<span class="string">&#x27;0&#x27;</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> Debug&#123;</span><br><span class="line">	Tp <span class="type">void</span> _debug(<span class="type">char</span>* f,Ty t)&#123;cerr&lt;&lt;f&lt;&lt;<span class="string">&#x27;=&#x27;</span>&lt;&lt;t&lt;&lt;endl;&#125;</span><br><span class="line">	Ts <span class="type">void</span> _debug(<span class="type">char</span>* f,Ty x,Ar... y)&#123;<span class="keyword">while</span>(*f!=<span class="string">&#x27;,&#x27;</span>) cerr&lt;&lt;*f++;cerr&lt;&lt;<span class="string">&#x27;=&#x27;</span>&lt;&lt;x&lt;&lt;<span class="string">&quot;,&quot;</span>;_debug(f+<span class="number">1</span>,y...);&#125;</span><br><span class="line">	Tp ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; os,vector&lt;Ty&gt;&amp; V)&#123;os&lt;&lt;<span class="string">&quot;[&quot;</span>;<span class="keyword">for</span>(<span class="keyword">auto</span>&amp; vv:V) os&lt;&lt;vv&lt;&lt;<span class="string">&quot;,&quot;</span>;os&lt;&lt;<span class="string">&quot;]&quot;</span>;<span class="keyword">return</span> os;&#125;</span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> gdb(...) _debug((char*)#__VA_ARGS__,__VA_ARGS__)</span></span><br><span class="line">&#125;<span class="keyword">using</span> <span class="keyword">namespace</span> Debug;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mk make_pair</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">power</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y=mod<span class="number">-2</span>)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> sum=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (y) &#123;</span><br><span class="line">		<span class="keyword">if</span> (y&amp;<span class="number">1</span>) sum=sum*x%mod;</span><br><span class="line">		x=x*x%mod;y&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,a[maxn],lg[maxn];</span><br><span class="line"><span class="type">int</span> q;</span><br><span class="line"><span class="type">int</span> fr[maxn][<span class="number">21</span>],rs[maxn];</span><br><span class="line"><span class="type">int</span> fl[maxn][<span class="number">21</span>],ls[maxn];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">queryr</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (l&gt;r) <span class="keyword">return</span> <span class="number">-1e9</span>;</span><br><span class="line">	<span class="type">int</span> z=lg[r-l+<span class="number">1</span>];</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">max</span>(fr[l][z],fr[r-(<span class="number">1</span>&lt;&lt;z)+<span class="number">1</span>][z]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">queryl</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (l&gt;r) <span class="keyword">return</span> <span class="number">1e9</span>;</span><br><span class="line">	<span class="type">int</span> z=lg[r-l+<span class="number">1</span>];</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">min</span>(fl[l][z],fl[r-(<span class="number">1</span>&lt;&lt;z)+<span class="number">1</span>][z]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> i,j,x,pus;</span><br><span class="line">	<span class="built_in">read</span>(n);</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">read</span>(a[i]);a[<span class="number">0</span>]=<span class="number">-1e10</span>,a[n+<span class="number">1</span>]=<span class="number">1e10</span>;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">2</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		rs[i]=<span class="built_in">lower_bound</span>(a+<span class="number">1</span>,a+<span class="number">1</span>+n,a[i]+a[i]-a[i<span class="number">-1</span>])-a<span class="number">-1</span>;</span><br><span class="line">		fr[i][<span class="number">0</span>]=rs[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;n;i++) &#123;</span><br><span class="line">		ls[i]=<span class="built_in">lower_bound</span>(a+<span class="number">1</span>,a+<span class="number">1</span>+n,a[i]-(a[i+<span class="number">1</span>]-a[i]))-a;</span><br><span class="line">		fl[i][<span class="number">0</span>]=ls[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (j=<span class="number">1</span>;j&lt;=<span class="number">20</span>;j++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (i=<span class="number">1</span>;i+(<span class="number">1</span>&lt;&lt;j)<span class="number">-1</span>&lt;=n;i++) &#123;</span><br><span class="line">			fr[i][j]=<span class="built_in">max</span>(fr[i][j<span class="number">-1</span>],fr[i+(<span class="number">1</span>&lt;&lt;j<span class="number">-1</span>)][j<span class="number">-1</span>]);</span><br><span class="line">			fl[i][j]=<span class="built_in">min</span>(fl[i][j<span class="number">-1</span>],fl[i+(<span class="number">1</span>&lt;&lt;j<span class="number">-1</span>)][j<span class="number">-1</span>]);</span><br><span class="line">		&#125; </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">2</span>;i&lt;=n;i++) lg[i]=lg[i/<span class="number">2</span>]+<span class="number">1</span>;</span><br><span class="line">	<span class="built_in">read</span>(q);</span><br><span class="line">	<span class="keyword">while</span> (q--) &#123;</span><br><span class="line">		<span class="built_in">read</span>(pus);</span><br><span class="line">		<span class="keyword">if</span> (n==<span class="number">1</span>) &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,<span class="built_in">abs</span>(a[<span class="number">1</span>]-pus));</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		x=<span class="built_in">lower_bound</span>(a+<span class="number">1</span>,a+<span class="number">1</span>+n,pus)-a;</span><br><span class="line">		<span class="type">int</span> ans=<span class="number">0</span>,l=x,r=x,flag=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span> (pus==a[x]) &#123;</span><br><span class="line">			<span class="keyword">if</span> (a[x]-a[x<span class="number">-1</span>]&lt;=a[x+<span class="number">1</span>]-a[x]) l=x<span class="number">-1</span>,r=x,ans=pus-a[x<span class="number">-1</span>],flag=<span class="number">1</span>;</span><br><span class="line">			<span class="keyword">else</span> l=x,r=x+<span class="number">1</span>,ans=a[x+<span class="number">1</span>]-a[x],flag=<span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (pus-a[x<span class="number">-1</span>]&lt;=a[x]-pus) l=r=x<span class="number">-1</span>,ans=pus-a[x<span class="number">-1</span>],flag=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">else</span> l=r=x,ans=a[x]-pus,flag=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span> (l&gt;<span class="number">1</span>||r&lt;n) &#123;</span><br><span class="line">			<span class="keyword">if</span> (l==<span class="number">1</span>) &#123;</span><br><span class="line">				<span class="keyword">if</span> (flag) ans+=a[n]-a[<span class="number">1</span>];</span><br><span class="line">				<span class="keyword">else</span> ans+=a[n]-a[r];</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (r==n) &#123;</span><br><span class="line">				<span class="keyword">if</span> (flag) ans+=a[l]-a[<span class="number">1</span>];</span><br><span class="line">				<span class="keyword">else</span> ans+=a[n]-a[<span class="number">1</span>];</span><br><span class="line">				<span class="keyword">break</span>; </span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (flag) &#123;</span><br><span class="line">				<span class="type">int</span> L=<span class="number">0</span>,R=l+<span class="number">1</span>,mid;</span><br><span class="line">				<span class="keyword">while</span> (L+<span class="number">1</span>&lt;R) &#123;</span><br><span class="line">					<span class="type">int</span> mid=L+R&gt;&gt;<span class="number">1</span>;</span><br><span class="line">					<span class="keyword">if</span> (<span class="built_in">queryr</span>(mid+<span class="number">1</span>,l)&gt;r) L=mid;</span><br><span class="line">					<span class="keyword">else</span> R=mid;</span><br><span class="line">				&#125;</span><br><span class="line">				ans+=a[l]-a[R]+a[r+<span class="number">1</span>]-a[R];</span><br><span class="line">				l=R,r++;flag^=<span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="type">int</span> L=r<span class="number">-1</span>,R=n+<span class="number">1</span>,mid;</span><br><span class="line">				<span class="keyword">while</span> (L+<span class="number">1</span>&lt;R) &#123;</span><br><span class="line">					<span class="type">int</span> mid=L+R&gt;&gt;<span class="number">1</span>;</span><br><span class="line">					<span class="keyword">if</span> (<span class="built_in">queryl</span>(r,mid<span class="number">-1</span>)&lt;l) R=mid;</span><br><span class="line">					<span class="keyword">else</span> L=mid;  </span><br><span class="line">				&#125;</span><br><span class="line">				ans+=a[L]-a[r]+a[L]-a[l<span class="number">-1</span>];</span><br><span class="line">				r=L,l--,flag^=<span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>今天 T2 100-&gt;20 的原因是 $n&#x3D;1$ 判挂了，之前改读入变量之后忘记再改特判了。</p>
<p>从自身的角度想，没有再测一遍样例，是我太懒了。</p>
<p>但从这个 jb 赛制的角度想，如果不是打包，那么 $n&#x3D;1$ 的点最多最多一两个吧，分数也是可观的。</p>
<h2 id="T3"><a href="#T3" class="headerlink" title="T3"></a>T3</h2><p>JOI Open 2018 T1 Bubble Sort 2 QOJ 2643</p>
<h3 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution"></a>Solution</h3><p>令 $d_i$ 表示 $\sum_{j&lt;i} [a_j&gt;a_i]$ 的值，则冒泡排序的次数就是 $\max d_i$。</p>
<p>先钦定所有数都是不同的。如果存在数值相同的点选标号最大的那个就行。</p>
<p>观察到答案<strong>一定</strong>在下凸包上，令点 $x$ 是其中的一个点，则 $d_x&#x3D;x-\sum_{1\le j\le n} [a_j&lt;a_x]$ 。</p>
<p>而如果答案不在下凸包上，$d_x&gt;x-\sum_{1\le j\le n} [a_j&lt;a_x]$，因为可能减掉标号比 $x$ 大的点。但是无关紧要，即使右边等于左边，他也不能作为答案，</p>
<p>所以只需要维护每个值的 $d_x&#x3D;x-\sum_{1\le j\le n} [a_j&lt;a_x]$ 的最大值即可。用权值线段树，复杂度 $O(n\log n)$。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 1000005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> put() putchar(<span class="string">&#x27;\n&#x27;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Tp template<span class="string">&lt;typename Ty&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Ts template<span class="string">&lt;typename Ty,typename... Ar&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">(<span class="type">int</span> &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> f=<span class="number">1</span>;x=<span class="number">0</span>;<span class="type">char</span> c=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (c&lt;<span class="string">&#x27;0&#x27;</span>||c&gt;<span class="string">&#x27;9&#x27;</span>) &#123;<span class="keyword">if</span> (c==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">-1</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span> (c&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;c&lt;=<span class="string">&#x27;9&#x27;</span>) &#123;x=x*<span class="number">10</span>+c-<span class="string">&#x27;0&#x27;</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> Debug&#123;</span><br><span class="line">	Tp <span class="type">void</span> _debug(<span class="type">char</span>* f,Ty t)&#123;cerr&lt;&lt;f&lt;&lt;<span class="string">&#x27;=&#x27;</span>&lt;&lt;t&lt;&lt;endl;&#125;</span><br><span class="line">	Ts <span class="type">void</span> _debug(<span class="type">char</span>* f,Ty x,Ar... y)&#123;<span class="keyword">while</span>(*f!=<span class="string">&#x27;,&#x27;</span>) cerr&lt;&lt;*f++;cerr&lt;&lt;<span class="string">&#x27;=&#x27;</span>&lt;&lt;x&lt;&lt;<span class="string">&quot;,&quot;</span>;_debug(f+<span class="number">1</span>,y...);&#125;</span><br><span class="line">	Tp ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; os,vector&lt;Ty&gt;&amp; V)&#123;os&lt;&lt;<span class="string">&quot;[&quot;</span>;<span class="keyword">for</span>(<span class="keyword">auto</span>&amp; vv:V) os&lt;&lt;vv&lt;&lt;<span class="string">&quot;,&quot;</span>;os&lt;&lt;<span class="string">&quot;]&quot;</span>;<span class="keyword">return</span> os;&#125;</span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> gdb(...) _debug((char*)#__VA_ARGS__,__VA_ARGS__)</span></span><br><span class="line">&#125;<span class="keyword">using</span> <span class="keyword">namespace</span> Debug;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mk make_pair</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">power</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y=mod<span class="number">-2</span>)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> sum=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (y) &#123;</span><br><span class="line">		<span class="keyword">if</span> (y&amp;<span class="number">1</span>) sum=sum*x%mod;</span><br><span class="line">		x=x*x%mod;y&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,q,a[maxn];</span><br><span class="line"><span class="type">int</span> d[maxn];</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) ((x)&amp;(-x))</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">	<span class="type">int</span> ls,rs,Max,lazy,siz;</span><br><span class="line">&#125;f[<span class="number">10000005</span>];</span><br><span class="line"><span class="type">int</span> cnt=<span class="number">1</span>,root=<span class="number">1</span>,tot;</span><br><span class="line">pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;o[maxn];</span><br><span class="line">set&lt;<span class="type">int</span>&gt;t[maxn];</span><br><span class="line"><span class="type">int</span> g[maxn];</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf=<span class="number">1e9</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> rt)</span> </span>&#123;</span><br><span class="line">	f[rt].Max=<span class="built_in">max</span>(f[f[rt].ls].Max,f[f[rt].rs].Max);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> rt)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (f[rt].lazy) &#123;</span><br><span class="line">		<span class="type">int</span> k=f[rt].lazy;f[rt].lazy=<span class="number">0</span>;</span><br><span class="line">		f[f[rt].ls].lazy+=k,f[f[rt].rs].lazy+=k;</span><br><span class="line">		f[f[rt].ls].Max+=k,f[f[rt].rs].Max+=k;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> &amp;rt,<span class="type">int</span> head,<span class="type">int</span> k,<span class="type">int</span> siz)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!rt) rt=++cnt,f[rt].Max=-inf,f[rt].lazy=<span class="number">0</span>,f[rt].siz=<span class="number">0</span>;</span><br><span class="line">	f[rt].siz+=siz;</span><br><span class="line">	<span class="keyword">if</span> (l==r) &#123;</span><br><span class="line">		f[rt].Max=k;</span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;<span class="built_in">pushdown</span>(rt);</span><br><span class="line">	<span class="keyword">if</span> (head&lt;=mid) <span class="built_in">modify</span>(l,mid,f[rt].ls,head,k,siz);</span><br><span class="line">	<span class="keyword">else</span> <span class="built_in">modify</span>(mid+<span class="number">1</span>,r,f[rt].rs,head,k,siz);</span><br><span class="line">	<span class="built_in">pushup</span>(rt); </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Update</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> &amp;rt,<span class="type">int</span> head,<span class="type">int</span> tail,<span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(head&gt;tail) <span class="keyword">return</span> ;</span><br><span class="line">	<span class="keyword">if</span> (!rt) rt=++cnt,f[rt].Max=-inf,f[rt].lazy=<span class="number">0</span>,f[rt].siz=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (head&lt;=l&amp;&amp;r&lt;=tail) <span class="keyword">return</span> f[rt].Max+=k,f[rt].lazy+=k,<span class="built_in">void</span>();</span><br><span class="line">	<span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;<span class="built_in">pushdown</span>(rt);</span><br><span class="line">	<span class="keyword">if</span> (head&lt;=mid) <span class="built_in">Update</span>(l,mid,f[rt].ls,head,tail,k);</span><br><span class="line">	<span class="keyword">if</span> (tail&gt;mid)  <span class="built_in">Update</span>(mid+<span class="number">1</span>,r,f[rt].rs,head,tail,k);</span><br><span class="line">	<span class="built_in">pushup</span>(rt);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Query</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> rt,<span class="type">int</span> head,<span class="type">int</span> tail)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!rt) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (head&lt;=l&amp;&amp;r&lt;=tail) <span class="keyword">return</span> f[rt].siz;</span><br><span class="line">	<span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>,sum=<span class="number">0</span>;<span class="built_in">pushdown</span>(rt);</span><br><span class="line">	<span class="keyword">if</span> (head&lt;=mid) sum+=<span class="built_in">Query</span>(l,mid,f[rt].ls,head,tail);</span><br><span class="line">	<span class="keyword">if</span> (tail&gt;mid)  sum+=<span class="built_in">Query</span>(mid+<span class="number">1</span>,r,f[rt].rs,head,tail);</span><br><span class="line">	<span class="keyword">return</span> sum; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> rt,<span class="type">int</span> head,<span class="type">int</span> tail)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!rt) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (head&lt;=l&amp;&amp;r&lt;=tail) <span class="keyword">return</span> f[rt].Max;</span><br><span class="line">	<span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>,sum=<span class="number">0</span>;<span class="built_in">pushdown</span>(rt);</span><br><span class="line">	<span class="keyword">if</span> (head&lt;=mid) sum+=<span class="built_in">query</span>(l,mid,f[rt].ls,head,tail);</span><br><span class="line">	<span class="keyword">if</span> (tail&gt;mid)  sum+=<span class="built_in">query</span>(mid+<span class="number">1</span>,r,f[rt].rs,head,tail);</span><br><span class="line">	<span class="keyword">return</span> sum; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> i,x,y,j,tmp,ans;</span><br><span class="line">	<span class="built_in">read</span>(n);<span class="built_in">read</span>(q);</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">read</span>(a[i]);</span><br><span class="line">	f[<span class="number">0</span>].Max=-inf;</span><br><span class="line">	tot=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) g[++tot]=a[i];</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=q;i++) &#123;</span><br><span class="line">		<span class="built_in">read</span>(x),<span class="built_in">read</span>(y),x++,o[i]=<span class="built_in">mk</span>(x,y);</span><br><span class="line">		g[++tot]=y;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">sort</span>(g+<span class="number">1</span>,g+<span class="number">1</span>+tot);</span><br><span class="line">	tot=<span class="built_in">unique</span>(g+<span class="number">1</span>,g+<span class="number">1</span>+tot)-g<span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		a[i]=<span class="built_in">lower_bound</span>(g+<span class="number">1</span>,g+<span class="number">1</span>+tot,a[i])-g;</span><br><span class="line">		t[a[i]].<span class="built_in">insert</span>(i);</span><br><span class="line">		<span class="built_in">modify</span>(<span class="number">1</span>,tot,root,a[i],-inf,<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="built_in">modify</span>(<span class="number">1</span>,tot,root,a[i],i-<span class="built_in">Query</span>(<span class="number">1</span>,tot,<span class="number">1</span>,<span class="number">1</span>,a[i]),<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=q;i++) &#123;</span><br><span class="line">		x=o[i].fi,y=o[i].se;</span><br><span class="line">		y=<span class="built_in">lower_bound</span>(g+<span class="number">1</span>,g+<span class="number">1</span>+tot,y)-g;</span><br><span class="line">		t[a[x]].<span class="built_in">erase</span>(x);</span><br><span class="line">		<span class="built_in">modify</span>(<span class="number">1</span>,tot,root,a[x],-inf,<span class="number">-1</span>);</span><br><span class="line">		<span class="keyword">if</span> (t[a[x]].<span class="built_in">begin</span>()!=t[a[x]].<span class="built_in">end</span>()) &#123;</span><br><span class="line">			<span class="type">int</span> tmp=*(--t[a[x]].<span class="built_in">end</span>());</span><br><span class="line">			<span class="built_in">modify</span>(<span class="number">1</span>,tot,root,a[x],tmp-<span class="built_in">Query</span>(<span class="number">1</span>,tot,<span class="number">1</span>,<span class="number">1</span>,a[x]),<span class="number">0</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">Update</span>(<span class="number">1</span>,tot,root,a[x]+<span class="number">1</span>,tot,<span class="number">1</span>);</span><br><span class="line">		</span><br><span class="line">		a[x]=y;</span><br><span class="line">		t[a[x]].<span class="built_in">insert</span>(x);</span><br><span class="line">		<span class="built_in">modify</span>(<span class="number">1</span>,tot,root,a[x],-inf,<span class="number">1</span>);</span><br><span class="line">		<span class="type">int</span> tmp=*(--t[a[x]].<span class="built_in">end</span>()),z=tmp-<span class="built_in">Query</span>(<span class="number">1</span>,tot,<span class="number">1</span>,<span class="number">1</span>,a[x]);</span><br><span class="line">		<span class="built_in">modify</span>(<span class="number">1</span>,tot,root,a[x],tmp-<span class="built_in">Query</span>(<span class="number">1</span>,tot,<span class="number">1</span>,<span class="number">1</span>,a[x]),<span class="number">0</span>);</span><br><span class="line">		<span class="built_in">Update</span>(<span class="number">1</span>,tot,root,a[x]+<span class="number">1</span>,tot,<span class="number">-1</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">max</span>(<span class="number">1</span>,f[<span class="number">1</span>].Max));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="T4"><a href="#T4" class="headerlink" title="T4"></a>T4</h2><p>CF1804H Code Lock</p>
<p>感觉是高端搜索。</p>
<p>不会。</p>
]]></content>
      <tags>
        <tag>NOIP模拟赛</tag>
        <tag>线段树</tag>
        <tag>二分</tag>
        <tag>点分树</tag>
      </tags>
  </entry>
  <entry>
    <title>7.14 模拟赛</title>
    <url>/2023/07/14/7-14-%E6%A8%A1%E6%8B%9F%E8%B5%9B/</url>
    <content><![CDATA[<h1 id="7-14-模拟赛"><a href="#7-14-模拟赛" class="headerlink" title="7.14 模拟赛"></a>7.14 模拟赛</h1><p>四题都是 1s 512MB</p>
<h2 id="T1-A"><a href="#T1-A" class="headerlink" title="T1. A"></a>T1. A</h2><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>给定一个自然数 $N$，找出一个 $M$，使得 $M &gt; 0$ 且 $M$ 是 $N$ 的倍数，并且 $M$ 的 10 进制表示只包含 $0$ 或 $1$。求最小的 $M$。<br>如果无解，则输出 $-1$。</p>
<p>$N\le 10^6$</p>
<h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><p>首先一定不存在 $-1$ 的情况。考虑 $1,11,111…$ 模 $N$ 一定存在相同的两个。相减就是答案。</p>
<p>然后 bfs。这里不想写了。就贺了一发翔哥的。</p>
<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e6</span> + <span class="number">9</span>;</span><br><span class="line"><span class="type">int</span> n,t;</span><br><span class="line"><span class="type">bool</span> vis[N];</span><br><span class="line"><span class="type">int</span> bfs[N],la[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> nxt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">putchar</span>(<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(la[i],i);</span><br><span class="line">    <span class="keyword">if</span>(bfs[i]*<span class="number">10</span>%n==bfs[nxt])<span class="built_in">putchar</span>(<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">putchar</span>(<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;-1\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    t=<span class="number">1</span>;</span><br><span class="line">    vis[<span class="number">1</span>]=<span class="literal">true</span>;bfs[<span class="number">1</span>]=<span class="number">1</span>;la[<span class="number">1</span>]=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=t;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(bfs[i]==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">dfs</span>(la[i],i);</span><br><span class="line">            <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!vis[bfs[i]*<span class="number">10</span>%n])&#123;</span><br><span class="line">            la[++t]=i;</span><br><span class="line">            bfs[t]=bfs[i]*<span class="number">10</span>%n;</span><br><span class="line">            vis[bfs[i]*<span class="number">10</span>%n]=<span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!vis[(bfs[i]*<span class="number">10</span>+<span class="number">1</span>)%n])&#123;</span><br><span class="line">            la[++t]=i;</span><br><span class="line">            bfs[t]=(bfs[i]*<span class="number">10</span>+<span class="number">1</span>)%n;</span><br><span class="line">            vis[(bfs[i]*<span class="number">10</span>+<span class="number">1</span>)%n]=<span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;-1&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="T2-B"><a href="#T2-B" class="headerlink" title="T2. B"></a>T2. B</h2><h3 id="Description-1"><a href="#Description-1" class="headerlink" title="Description"></a>Description</h3><p>两个串的相似值为，如果两个串在第 $i$ 位是一样的，那么他们的相似值要加上 $w_i$。<br>现在给你个长度为 $n$ 的串，然后有 $q$ 个询问，每一次给定一个长度为的$n$ 串，和一个值 $k$。求在这个串中，有多少个串和他的相似值不超过 $k$。</p>
<p>$n\le 15,m,q\le 5\times 10^5,w_i,k\le 30$</p>
<h3 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution"></a>Solution</h3><p>观察到 $k$ 很小，答案只有 $2^nk$ 种情况。</p>
<p>令 $f[i][j]$ 为这个数为 $i$ ，有 $f[i][j]$ 个串和其相似值恰好等于 $k$。</p>
<p>考虑位从小到大枚举 $k$，$f[i][j]\Leftarrow f[i\bigoplus 2^k][j-w_i]$</p>
<p>注意枚举顺序和 $w_i&#x3D;0$ 的情况。  </p>
<h3 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 500005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> put() putchar(<span class="string">&#x27;\n&#x27;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Tp template<span class="string">&lt;typename Ty&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Ts template<span class="string">&lt;typename Ty,typename... Ar&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(<span class="type">int</span> &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> f=<span class="number">1</span>;x=<span class="number">0</span>;<span class="type">char</span> c=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (c&lt;<span class="string">&#x27;0&#x27;</span>||c&gt;<span class="string">&#x27;9&#x27;</span>) &#123;<span class="keyword">if</span> (c==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">-1</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span> (c&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;c&lt;=<span class="string">&#x27;9&#x27;</span>) &#123;x=x*<span class="number">10</span>+c-<span class="string">&#x27;0&#x27;</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> Debug&#123;</span><br><span class="line">	Tp <span class="type">void</span> _debug(<span class="type">char</span>* f,Ty t)&#123;cerr&lt;&lt;f&lt;&lt;<span class="string">&#x27;=&#x27;</span>&lt;&lt;t&lt;&lt;endl;&#125;</span><br><span class="line">	Ts <span class="type">void</span> _debug(<span class="type">char</span>* f,Ty x,Ar... y)&#123;<span class="keyword">while</span>(*f!=<span class="string">&#x27;,&#x27;</span>) cerr&lt;&lt;*f++;cerr&lt;&lt;<span class="string">&#x27;=&#x27;</span>&lt;&lt;x&lt;&lt;<span class="string">&quot;,&quot;</span>;_debug(f+<span class="number">1</span>,y...);&#125;</span><br><span class="line">	Tp ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; os,vector&lt;Ty&gt;&amp; V)&#123;os&lt;&lt;<span class="string">&quot;[&quot;</span>;<span class="keyword">for</span>(<span class="keyword">auto</span>&amp; vv:V) os&lt;&lt;vv&lt;&lt;<span class="string">&quot;,&quot;</span>;os&lt;&lt;<span class="string">&quot;]&quot;</span>;<span class="keyword">return</span> os;&#125;</span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> gdb(...) _debug((char*)#__VA_ARGS__,__VA_ARGS__)</span></span><br><span class="line">&#125;<span class="keyword">using</span> <span class="keyword">namespace</span> Debug;</span><br><span class="line"><span class="type">int</span> n,m,q,w[<span class="number">25</span>];</span><br><span class="line"><span class="type">int</span> a[maxn]; </span><br><span class="line"><span class="type">int</span> b[(<span class="number">1</span>&lt;&lt;<span class="number">15</span>)+<span class="number">5</span>];</span><br><span class="line"><span class="type">int</span> nums[<span class="number">40005</span>][<span class="number">35</span>],g[<span class="number">40005</span>][<span class="number">35</span>];</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) ((x)&amp;(-x))</span></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> i,j,x,k,sum;<span class="type">char</span> ch;</span><br><span class="line">	<span class="built_in">read</span>(n);<span class="built_in">read</span>(m);<span class="built_in">read</span>(q);</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;n;i++) <span class="built_in">read</span>(w[i]);</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=m;i++) &#123;</span><br><span class="line">		ch=<span class="built_in">getchar</span>();<span class="keyword">while</span> (ch!=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch!=<span class="string">&#x27;1&#x27;</span>) ch=<span class="built_in">getchar</span>();</span><br><span class="line">		<span class="keyword">for</span> (j=<span class="number">0</span>;j&lt;n;j++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (ch==<span class="string">&#x27;1&#x27;</span>) a[i]|=(<span class="number">1</span>&lt;&lt;j);</span><br><span class="line">			ch=<span class="built_in">getchar</span>();</span><br><span class="line">		&#125;</span><br><span class="line">		b[a[i]]++; </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> N=(<span class="number">1</span>&lt;&lt;n);</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;N;i++) nums[i][<span class="number">0</span>]=b[(N<span class="number">-1</span>)^i];</span><br><span class="line">	<span class="keyword">for</span> (k=<span class="number">0</span>;k&lt;n;k++) &#123;</span><br><span class="line">		<span class="built_in">memcpy</span>(g,nums,<span class="built_in">sizeof</span>(g));<span class="comment">//w=0</span></span><br><span class="line">		<span class="keyword">for</span> (j=<span class="number">30</span>;j&gt;=<span class="number">0</span>;j--) &#123;</span><br><span class="line">			<span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">				<span class="keyword">if</span> (j&gt;=w[k]) nums[i][j]+=g[i^(<span class="number">1</span>&lt;&lt;k)][j-w[k]];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (q--) &#123;</span><br><span class="line">		x=<span class="number">0</span>;</span><br><span class="line">		ch=<span class="built_in">getchar</span>();<span class="keyword">while</span> (ch!=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch!=<span class="string">&#x27;1&#x27;</span>) ch=<span class="built_in">getchar</span>();</span><br><span class="line">		<span class="keyword">for</span> (j=<span class="number">0</span>;j&lt;n;j++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (ch==<span class="string">&#x27;1&#x27;</span>) x|=(<span class="number">1</span>&lt;&lt;j);</span><br><span class="line">			ch=<span class="built_in">getchar</span>();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">read</span>(k);sum=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;=k;i++) sum+=nums[x][i];</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,sum);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="T3-C"><a href="#T3-C" class="headerlink" title="T3. C"></a>T3. C</h2><h3 id="Decription"><a href="#Decription" class="headerlink" title="Decription"></a>Decription</h3><p><img src="https://s2.loli.net/2023/07/14/xD5EuoCQtnO4jV7.png" alt="image-20230714201906721"></p>
<p>$t\le 10^6$</p>
<h3 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution"></a>Solution</h3><p>枚举矩阵较短的一边 $n$，这里是 $t$ 的因数，枚举的复杂度是 $O(t^{1&#x2F;3})$ 。</p>
<p>然后根据最大值的个数（最大值一定在角落），确定 $0$ 的位置，然后直接暴力判断。</p>
<p>总复杂度 $O(n^{4&#x2F;3})$ ，实际上远远达不到。有点细节。</p>
<h3 id="Code-2"><a href="#Code-2" class="headerlink" title="Code"></a>Code</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 1000005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> put() putchar(<span class="string">&#x27;\n&#x27;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Tp template<span class="string">&lt;typename Ty&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Ts template<span class="string">&lt;typename Ty,typename... Ar&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(<span class="type">int</span> &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> f=<span class="number">1</span>;x=<span class="number">0</span>;<span class="type">char</span> c=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (c&lt;<span class="string">&#x27;0&#x27;</span>||c&gt;<span class="string">&#x27;9&#x27;</span>) &#123;<span class="keyword">if</span> (c==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">-1</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span> (c&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;c&lt;=<span class="string">&#x27;9&#x27;</span>) &#123;x=x*<span class="number">10</span>+c-<span class="string">&#x27;0&#x27;</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> Debug&#123;</span><br><span class="line">	Tp <span class="type">void</span> _debug(<span class="type">char</span>* f,Ty t)&#123;cerr&lt;&lt;f&lt;&lt;<span class="string">&#x27;=&#x27;</span>&lt;&lt;t&lt;&lt;endl;&#125;</span><br><span class="line">	Ts <span class="type">void</span> _debug(<span class="type">char</span>* f,Ty x,Ar... y)&#123;<span class="keyword">while</span>(*f!=<span class="string">&#x27;,&#x27;</span>) cerr&lt;&lt;*f++;cerr&lt;&lt;<span class="string">&#x27;=&#x27;</span>&lt;&lt;x&lt;&lt;<span class="string">&quot;,&quot;</span>;_debug(f+<span class="number">1</span>,y...);&#125;</span><br><span class="line">	Tp ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; os,vector&lt;Ty&gt;&amp; V)&#123;os&lt;&lt;<span class="string">&quot;[&quot;</span>;<span class="keyword">for</span>(<span class="keyword">auto</span>&amp; vv:V) os&lt;&lt;vv&lt;&lt;<span class="string">&quot;,&quot;</span>;os&lt;&lt;<span class="string">&quot;]&quot;</span>;<span class="keyword">return</span> os;&#125;</span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> gdb(...) _debug((char*)#__VA_ARGS__,__VA_ARGS__)</span></span><br><span class="line">&#125;<span class="keyword">using</span> <span class="keyword">namespace</span> Debug;</span><br><span class="line"><span class="type">int</span> t[maxn],K,Max;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">calc</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> m,<span class="type">int</span> tmpx,<span class="type">int</span> tmpy,<span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> sum=<span class="number">0</span>,tmp1,tmp2,tmp3,tmp4,tmp5,tmp6,tmp7,tmp8;</span><br><span class="line">	<span class="keyword">if</span> (tmpx&gt;i) tmp1=tmp2=tmpy,sum--;</span><br><span class="line">	<span class="keyword">else</span> tmp1=tmpy-(i-tmpx+<span class="number">1</span>),tmp2=tmpy+(i-tmpx+<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">if</span> (tmpx+i&lt;=n) tmp3=tmp4=tmpy,sum--;</span><br><span class="line">	<span class="keyword">else</span> tmp3=tmpy-(i-n+tmpx),tmp4=tmpy+(i-n+tmpx);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> (tmpy&gt;i) tmp5=tmp6=tmpy-i,sum--;</span><br><span class="line">	<span class="keyword">else</span> tmp5=tmp6=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span> (tmpy+i&lt;=m) tmp7=tmp8=tmpy+i,sum--;</span><br><span class="line">	<span class="keyword">else</span> tmp7=tmp8=m;</span><br><span class="line"><span class="comment">//	gdb(sum,tmp1,tmp5,tmp2,tmp7,tmp3,tmp6,tmp4,tmp8);</span></span><br><span class="line">	<span class="keyword">if</span> (tmp1&gt;=tmp5) sum+=tmp1-tmp5+<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span> (tmp2&lt;=tmp7) sum+=tmp7-tmp2+<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span> (tmp3&gt;=tmp6) sum+=tmp3-tmp6+<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span> (tmp4&lt;=tmp8) sum+=tmp8-tmp4+<span class="number">1</span>; </span><br><span class="line">	<span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> m)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (Max&gt;n+m<span class="number">-2</span>) <span class="keyword">return</span> ;</span><br><span class="line">	<span class="type">int</span> i,j,tmpx=<span class="number">0</span>,tmpy=<span class="number">0</span>,flag=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (t[Max]==<span class="number">4</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (n%<span class="number">2</span>==<span class="number">1</span>&amp;&amp;m%<span class="number">2</span>==<span class="number">1</span>) &#123;</span><br><span class="line">			tmpx=n/<span class="number">2</span>+<span class="number">1</span>,tmpy=m/<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">			<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;Max;i++) <span class="keyword">if</span> (<span class="built_in">calc</span>(n,m,tmpx,tmpy,i)!=t[i]) <span class="keyword">return</span> ;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%d %d\n%d %d&quot;</span>,n,m,tmpx,tmpy);<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (t[Max]==<span class="number">3</span>||t[Max]&gt;<span class="number">4</span>) <span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (t[Max]==<span class="number">2</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (n%<span class="number">2</span>==<span class="number">0</span>&amp;&amp;m%<span class="number">2</span>==<span class="number">0</span>) <span class="keyword">return</span> ;</span><br><span class="line">		<span class="keyword">if</span> (m%<span class="number">2</span>==<span class="number">1</span>) &#123;</span><br><span class="line">			tmpy=(m+<span class="number">1</span>)/<span class="number">2</span>;tmpx=n-(Max-tmpy+<span class="number">1</span>);flag=<span class="number">0</span>;</span><br><span class="line">			<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;Max;i++) <span class="keyword">if</span> (<span class="built_in">calc</span>(n,m,tmpx,tmpy,i)!=t[i]) &#123;flag=<span class="number">1</span>;<span class="keyword">break</span>;&#125;</span><br><span class="line">			<span class="keyword">if</span> (!flag) &#123;<span class="built_in">printf</span>(<span class="string">&quot;%d %d\n%d %d&quot;</span>,n,m,tmpx,tmpy);<span class="built_in">exit</span>(<span class="number">0</span>) ;&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (n%<span class="number">2</span>==<span class="number">1</span>) &#123;</span><br><span class="line">			tmpx=(n+<span class="number">1</span>)/<span class="number">2</span>,tmpy=m-(Max-tmpx+<span class="number">1</span>);flag=<span class="number">0</span>;</span><br><span class="line">			<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;Max;i++) <span class="keyword">if</span> (<span class="built_in">calc</span>(n,m,tmpx,tmpy,i)!=t[i]) &#123;flag=<span class="number">1</span>;<span class="keyword">break</span>;&#125;</span><br><span class="line">			<span class="keyword">if</span> (!flag) &#123;<span class="built_in">printf</span>(<span class="string">&quot;%d %d\n%d %d&quot;</span>,n,m,tmpx,tmpy);<span class="built_in">exit</span>(<span class="number">0</span>) ;&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (t[Max]==<span class="number">1</span>) &#123;</span><br><span class="line">		<span class="keyword">for</span> (j=n-Max;j&lt;=(n+<span class="number">1</span>)/<span class="number">2</span>;j++) &#123;</span><br><span class="line">			tmpx=j,tmpy=m+n-Max-j;flag=<span class="number">0</span>;</span><br><span class="line">			<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=Max;i++) <span class="keyword">if</span> (<span class="built_in">calc</span>(n,m,tmpx,tmpy,i)!=t[i]) &#123;flag=<span class="number">1</span>;<span class="keyword">break</span>;&#125;</span><br><span class="line">			<span class="keyword">if</span> (!flag) &#123;<span class="built_in">printf</span>(<span class="string">&quot;%d %d\n%d %d&quot;</span>,n,m,tmpx,tmpy);<span class="built_in">exit</span>(<span class="number">0</span>) ;&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> i,j,x;</span><br><span class="line">	<span class="built_in">read</span>(K);</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=K;i++) &#123;</span><br><span class="line">		<span class="built_in">read</span>(x);</span><br><span class="line">		<span class="keyword">if</span> (x&gt;K<span class="number">-1</span>) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>),<span class="number">0</span>;</span><br><span class="line">		t[x]++;Max=<span class="built_in">max</span>(Max,x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i*i&lt;=K;i++) <span class="keyword">if</span> (K%i==<span class="number">0</span>) &#123;</span><br><span class="line">		<span class="built_in">solve</span>(i,K/i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="T4-D"><a href="#T4-D" class="headerlink" title="T4. D"></a>T4. D</h2><h3 id="Description-2"><a href="#Description-2" class="headerlink" title="Description"></a>Description</h3><p>给定 $n$ 个数，判断 $a_i$ 是否存在 $j$ 满足 $a_i&amp;a_j&#x3D;0$。</p>
<p>$n,a_i\le 10^6$</p>
<h3 id="Solution-3"><a href="#Solution-3" class="headerlink" title="Solution"></a>Solution</h3><p>SOSdp 板子。</p>
<h3 id="Code-3"><a href="#Code-3" class="headerlink" title="Code"></a>Code</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 2000005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> put() putchar(<span class="string">&#x27;\n&#x27;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Tp template<span class="string">&lt;typename Ty&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Ts template<span class="string">&lt;typename Ty,typename... Ar&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(<span class="type">int</span> &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> f=<span class="number">1</span>;x=<span class="number">0</span>;<span class="type">char</span> c=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (c&lt;<span class="string">&#x27;0&#x27;</span>||c&gt;<span class="string">&#x27;9&#x27;</span>) &#123;<span class="keyword">if</span> (c==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">-1</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span> (c&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;c&lt;=<span class="string">&#x27;9&#x27;</span>) &#123;x=x*<span class="number">10</span>+c-<span class="string">&#x27;0&#x27;</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> Debug&#123;</span><br><span class="line">	Tp <span class="type">void</span> _debug(<span class="type">char</span>* f,Ty t)&#123;cerr&lt;&lt;f&lt;&lt;<span class="string">&#x27;=&#x27;</span>&lt;&lt;t&lt;&lt;endl;&#125;</span><br><span class="line">	Ts <span class="type">void</span> _debug(<span class="type">char</span>* f,Ty x,Ar... y)&#123;<span class="keyword">while</span>(*f!=<span class="string">&#x27;,&#x27;</span>) cerr&lt;&lt;*f++;cerr&lt;&lt;<span class="string">&#x27;=&#x27;</span>&lt;&lt;x&lt;&lt;<span class="string">&quot;,&quot;</span>;_debug(f+<span class="number">1</span>,y...);&#125;</span><br><span class="line">	Tp ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; os,vector&lt;Ty&gt;&amp; V)&#123;os&lt;&lt;<span class="string">&quot;[&quot;</span>;<span class="keyword">for</span>(<span class="keyword">auto</span>&amp; vv:V) os&lt;&lt;vv&lt;&lt;<span class="string">&quot;,&quot;</span>;os&lt;&lt;<span class="string">&quot;]&quot;</span>;<span class="keyword">return</span> os;&#125;</span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> gdb(...) _debug((char*)#__VA_ARGS__,__VA_ARGS__)</span></span><br><span class="line">&#125;<span class="keyword">using</span> <span class="keyword">namespace</span> Debug;</span><br><span class="line"><span class="type">int</span> n,a[maxn];</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> base=<span class="number">20</span>;</span><br><span class="line"><span class="type">int</span> f[maxn],Max; </span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> i,j;</span><br><span class="line">	<span class="built_in">read</span>(n);</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">read</span>(a[i]),f[a[i]]=<span class="number">1</span>,Max=<span class="built_in">max</span>(Max,a[i]);</span><br><span class="line">	<span class="keyword">for</span> (j=<span class="number">0</span>;j&lt;=base;j++)</span><br><span class="line">		<span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;=(<span class="number">1</span>&lt;&lt;base);i++) <span class="keyword">if</span> ((i&gt;&gt;j)&amp;<span class="number">1</span>) &#123;</span><br><span class="line">			f[i]|=f[i^(<span class="number">1</span>&lt;&lt;j)];</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="type">int</span> N=<span class="number">1</span>&lt;&lt;base;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,f[N<span class="number">-1</span>^a[i]]);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>NOIP模拟赛</tag>
      </tags>
  </entry>
  <entry>
    <title>7.16 模拟赛</title>
    <url>/2023/07/18/7-16-%E6%A8%A1%E6%8B%9F%E8%B5%9B/</url>
    <content><![CDATA[<h1 id="7-16-模拟赛"><a href="#7-16-模拟赛" class="headerlink" title="7.16 模拟赛"></a>7.16 模拟赛</h1><h2 id="T1-park"><a href="#T1-park" class="headerlink" title="T1. park"></a>T1. park</h2><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p><img src="https://s2.loli.net/2023/07/17/s4eBJL7FtuOYNlf.png"></p>
<p>$n\le 10^6$</p>
<p>1s 512MB</p>
<h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><p>优先队列模拟。复杂度 $O(n\log n)$。</p>
<p>由于题目的特殊性，取值最多只有 $O(\log n)$ 个，大概可以 $O(n)$。</p>
<p>第一次指导优先队列的常数比 set 小很多。</p>
<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 10000005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> put() putchar(<span class="string">&#x27;\n&#x27;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Tp template<span class="string">&lt;typename Ty&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Ts template<span class="string">&lt;typename Ty,typename... Ar&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(<span class="type">int</span> &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> f=<span class="number">1</span>;x=<span class="number">0</span>;<span class="type">char</span> c=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (c&lt;<span class="string">&#x27;0&#x27;</span>||c&gt;<span class="string">&#x27;9&#x27;</span>) &#123;<span class="keyword">if</span> (c==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">-1</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span> (c&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;c&lt;=<span class="string">&#x27;9&#x27;</span>) &#123;x=x*<span class="number">10</span>+c-<span class="string">&#x27;0&#x27;</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> Debug&#123;</span><br><span class="line">	Tp <span class="type">void</span> _debug(<span class="type">char</span>* f,Ty t)&#123;cerr&lt;&lt;f&lt;&lt;<span class="string">&#x27;=&#x27;</span>&lt;&lt;t&lt;&lt;endl;&#125;</span><br><span class="line">	Ts <span class="type">void</span> _debug(<span class="type">char</span>* f,Ty x,Ar... y)&#123;<span class="keyword">while</span>(*f!=<span class="string">&#x27;,&#x27;</span>) cerr&lt;&lt;*f++;cerr&lt;&lt;<span class="string">&#x27;=&#x27;</span>&lt;&lt;x&lt;&lt;<span class="string">&quot;,&quot;</span>;_debug(f+<span class="number">1</span>,y...);&#125;</span><br><span class="line">	Tp ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; os,vector&lt;Ty&gt;&amp; V)&#123;os&lt;&lt;<span class="string">&quot;[&quot;</span>;<span class="keyword">for</span>(<span class="keyword">auto</span>&amp; vv:V) os&lt;&lt;vv&lt;&lt;<span class="string">&quot;,&quot;</span>;os&lt;&lt;<span class="string">&quot;]&quot;</span>;<span class="keyword">return</span> os;&#125;</span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> gdb(...) _debug((char*)#__VA_ARGS__,__VA_ARGS__)</span></span><br><span class="line">&#125;<span class="keyword">using</span> <span class="keyword">namespace</span> Debug;</span><br><span class="line"><span class="type">int</span> n,m,a[maxn],ans;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf=<span class="number">1e12</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">	<span class="type">int</span> l,r;</span><br><span class="line">	<span class="built_in">node</span>(<span class="type">int</span> a=<span class="number">0</span>,<span class="type">int</span> b=<span class="number">0</span>) &#123;l=a;r=b;&#125;</span><br><span class="line">	<span class="type">bool</span> <span class="keyword">operator</span> &lt;(<span class="type">const</span> node &amp;x) <span class="type">const</span> &#123;<span class="keyword">return</span> r-l==x.r-x.l?l&lt;x.l:r-l&gt;x.r-x.l;&#125;</span><br><span class="line">&#125;b[maxn];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">cmp</span><span class="params">(node x,node y)</span> </span>&#123;<span class="keyword">return</span> x.l&lt;y.l;&#125;</span><br><span class="line">set&lt;node&gt;t; </span><br><span class="line"><span class="type">int</span> head,tail;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;park.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">  	<span class="built_in">freopen</span>(<span class="string">&quot;park.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout);</span><br><span class="line">	<span class="type">int</span> i,j;</span><br><span class="line">	<span class="built_in">read</span>(n);<span class="built_in">read</span>(m);</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=m;i++) <span class="built_in">read</span>(a[i]);</span><br><span class="line">	t.<span class="built_in">insert</span>(<span class="built_in">node</span>(<span class="number">0</span>,n+<span class="number">1</span>));</span><br><span class="line">	<span class="keyword">for</span> (j=<span class="number">1</span>;j&lt;=m;j++) &#123;</span><br><span class="line">		node tmp=*t.<span class="built_in">begin</span>();t.<span class="built_in">erase</span>(t.<span class="built_in">begin</span>());</span><br><span class="line">		<span class="type">int</span> id=(tmp.r+tmp.l)/<span class="number">2</span>;</span><br><span class="line">		b[j].l=id,b[j].r=a[j];</span><br><span class="line">		t.<span class="built_in">insert</span>(<span class="built_in">node</span>(tmp.l,id));</span><br><span class="line">		t.<span class="built_in">insert</span>(<span class="built_in">node</span>(id,tmp.r));</span><br><span class="line">	&#125;</span><br><span class="line">	b[m+<span class="number">1</span>]=inf;b[<span class="number">0</span>]=-inf;</span><br><span class="line">	<span class="built_in">sort</span>(b+<span class="number">1</span>,b+<span class="number">1</span>+m,cmp);</span><br><span class="line">	<span class="keyword">for</span> (j=<span class="number">1</span>;j&lt;=m;j++) <span class="keyword">if</span> (<span class="built_in">min</span>(b[j].l-b[j<span class="number">-1</span>].l,b[j+<span class="number">1</span>].l-b[j].l)&lt;=b[j].r) ans+=<span class="number">1</span>-<span class="built_in">min</span>(b[j].l-b[j<span class="number">-1</span>].l,b[j+<span class="number">1</span>].l-b[j].l)+b[j].r;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,ans); </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="T2-monster"><a href="#T2-monster" class="headerlink" title="T2. monster"></a>T2. monster</h2><h3 id="Description-1"><a href="#Description-1" class="headerlink" title="Description"></a>Description</h3><p><img src="https://s2.loli.net/2023/07/17/vbEftXyrzHs8ZDj.png" alt="image-20230717201205457">$n\le 10^5,a,b\le 10^9$</p>
<p>1s 512MB</p>
<h3 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution"></a>Solution</h3><p>感觉很妙的一道题。</p>
<p>假设我们以此打了$(a_{p1},b_{p2}),(a_{p1},b_{p2}),(a_{p3},b_{p3}),…(a_{pn},b_{pn})$。初始血量为任意时刻血量最小值的相反数。</p>
<p>因此目标最大化 $\min\sum\limits_{j&#x3D;1}^{i-1}(b_{pj}-a_{pj})-a_{i}$。假如先打 $(a_i,b_i)$，再打 $(a_j,b_j)$，根据最大化原则，我们可以合并两个点：</p>
<ul>
<li>若 $a_i&lt;a_i-b_i+a_j$，则合并为 $(a_i-b_i+a_j,b_j) $</li>
<li>若 $a_i\ge a_i-b_i+a_j$，则合并为 $(a_i,b_i-a_j+b_j)$</li>
</ul>
<p>之后考虑选择进攻点的顺序，对于 $(a_i,b_i)$ 和 $(a_j,b_j)$：</p>
<ul>
<li>如果 $a_i\le b_i$ ，$a_j\ge b_j$ ，则优先 $i$</li>
<li>如果 $a_i\le b_i,a_j\le b_j$，则优先 $a$ 小的</li>
<li>如果 $a_i\le b_i,a_j\le b_j$ ，则优先 $b$ 大的</li>
</ul>
<p>考虑用优先队列维护这个关系。</p>
<p>在树结构中，假设已经知道了 $x$ 的儿子 $y_1,y_2,…,y_k$ 的攻击序列，且儿子的攻击序列均已有序。</p>
<p>那么显然，$x$ 只需要把所有的攻击序列归并一下就完事了。</p>
<p>但是，此时需要在序列的最开头加入 $x$，可能会破坏原来的顺序。则 $x$ 依次合并比其小的点。说明攻击完 $x$ 后，马上攻击比 $x$ 还要优的怪。</p>
<p>写法上，启发式合并是 $O(n\log ^2n)$，可并堆是 $O(n\log n)$。下面代码实现的第一种。</p>
<h3 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 100005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> put() putchar(<span class="string">&#x27;\n&#x27;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Tp template<span class="string">&lt;typename Ty&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Ts template<span class="string">&lt;typename Ty,typename... Ar&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(<span class="type">int</span> &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> f=<span class="number">1</span>;x=<span class="number">0</span>;<span class="type">char</span> c=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (c&lt;<span class="string">&#x27;0&#x27;</span>||c&gt;<span class="string">&#x27;9&#x27;</span>) &#123;<span class="keyword">if</span> (c==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">-1</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span> (c&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;c&lt;=<span class="string">&#x27;9&#x27;</span>) &#123;x=x*<span class="number">10</span>+c-<span class="string">&#x27;0&#x27;</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> Debug&#123;</span><br><span class="line">	Tp <span class="type">void</span> _debug(<span class="type">char</span>* f,Ty t)&#123;cerr&lt;&lt;f&lt;&lt;<span class="string">&#x27;=&#x27;</span>&lt;&lt;t&lt;&lt;endl;&#125;</span><br><span class="line">	Ts <span class="type">void</span> _debug(<span class="type">char</span>* f,Ty x,Ar... y)&#123;<span class="keyword">while</span>(*f!=<span class="string">&#x27;,&#x27;</span>) cerr&lt;&lt;*f++;cerr&lt;&lt;<span class="string">&#x27;=&#x27;</span>&lt;&lt;x&lt;&lt;<span class="string">&quot;,&quot;</span>;_debug(f+<span class="number">1</span>,y...);&#125;</span><br><span class="line">	Tp ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; os,vector&lt;Ty&gt;&amp; V)&#123;os&lt;&lt;<span class="string">&quot;[&quot;</span>;<span class="keyword">for</span>(<span class="keyword">auto</span>&amp; vv:V) os&lt;&lt;vv&lt;&lt;<span class="string">&quot;,&quot;</span>;os&lt;&lt;<span class="string">&quot;]&quot;</span>;<span class="keyword">return</span> os;&#125;</span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> gdb(...) _debug((char*)#__VA_ARGS__,__VA_ARGS__)</span></span><br><span class="line">&#125;<span class="keyword">using</span> <span class="keyword">namespace</span> Debug;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">	<span class="type">int</span> a,b;</span><br><span class="line">	<span class="built_in">node</span>(<span class="type">int</span> x=<span class="number">0</span>,<span class="type">int</span> y=<span class="number">0</span>) &#123;a=x;b=y;&#125;</span><br><span class="line">	node <span class="keyword">operator</span> +(<span class="type">const</span> node &amp;x) <span class="type">const</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (x.a&gt;b) <span class="keyword">return</span> <span class="built_in">node</span>(a+x.a-b,x.b);</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">node</span>(a,b+x.b-x.a);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">bool</span> <span class="keyword">operator</span> &lt;(<span class="type">const</span> node &amp;x) <span class="type">const</span> &#123;</span><br><span class="line">		<span class="type">int</span> t1=a&lt;=b,t2=x.a&lt;=x.b;</span><br><span class="line">		<span class="keyword">if</span> (t1^t2) <span class="keyword">return</span> t1;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (t1) <span class="keyword">return</span> a&lt;x.a;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">return</span> b&gt;x.b;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">bool</span> <span class="keyword">operator</span> &gt;(<span class="type">const</span> node &amp;x) <span class="type">const</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> x&lt;*<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;a[maxn]; </span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">priority_queue&lt;node,vector&lt;node&gt;,greater&lt;node&gt; &gt;q[maxn];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;to[maxn];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> pre)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> y:to[x]) <span class="keyword">if</span> (y^pre) &#123;</span><br><span class="line">		<span class="built_in">dfs</span>(y,x);</span><br><span class="line">		<span class="keyword">if</span> (q[y].<span class="built_in">size</span>()&gt;=q[x].<span class="built_in">size</span>()) q[x].<span class="built_in">swap</span>(q[y]);</span><br><span class="line">		<span class="keyword">while</span> (!q[y].<span class="built_in">empty</span>()) q[x].<span class="built_in">push</span>(q[y].<span class="built_in">top</span>()),q[y].<span class="built_in">pop</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (!q[x].<span class="built_in">empty</span>()&amp;&amp;q[x].<span class="built_in">top</span>()&lt;a[x]) &#123;</span><br><span class="line">		a[x]=a[x]+q[x].<span class="built_in">top</span>(),q[x].<span class="built_in">pop</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	q[x].<span class="built_in">push</span>(a[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;monster.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">  	<span class="built_in">freopen</span>(<span class="string">&quot;monster.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout);</span><br><span class="line">	<span class="type">int</span> i,x,y;</span><br><span class="line">	<span class="built_in">read</span>(n);</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">2</span>;i&lt;=n;i++) <span class="built_in">read</span>(a[i].a),<span class="built_in">read</span>(a[i].b);</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;n;i++) <span class="built_in">read</span>(x),<span class="built_in">read</span>(y),to[x].<span class="built_in">push_back</span>(y),to[y].<span class="built_in">push_back</span>(x);</span><br><span class="line">	<span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">	node ans=<span class="built_in">node</span>(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">while</span> (!q[<span class="number">1</span>].<span class="built_in">empty</span>()) ans=ans+q[<span class="number">1</span>].<span class="built_in">top</span>(),q[<span class="number">1</span>].<span class="built_in">pop</span>();</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,ans.a);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="T3-monster"><a href="#T3-monster" class="headerlink" title="T3. monster"></a>T3. monster</h2><h3 id="Description-2"><a href="#Description-2" class="headerlink" title="Description"></a>Description</h3><p>P8511</p>
<h3 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution"></a>Solution</h3><p>观察到样例相同的答案很多。我们事先用 01trie 求出全局异或最大的点对 $x,y$。除了子树中包含 $x$ 或者 $y$ ，其余答案皆为这个最大值。具体的，就是 $x$ 和 $y$ 的祖先。这里是 $O(n\log w)$ 的。</p>
<p>之后只需要从根到 $x$ 依次暴力加入 $x$ 的祖先，求答案即可。$y$ 同理。这里同样是 $O(n\log w)$ 的。</p>
<h3 id="Code-2"><a href="#Code-2" class="headerlink" title="Code"></a>Code</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 500005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> put() putchar(<span class="string">&#x27;\n&#x27;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Tp template<span class="string">&lt;typename Ty&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Ts template<span class="string">&lt;typename Ty,typename... Ar&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(<span class="type">int</span> &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> f=<span class="number">1</span>;x=<span class="number">0</span>;<span class="type">char</span> c=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (c&lt;<span class="string">&#x27;0&#x27;</span>||c&gt;<span class="string">&#x27;9&#x27;</span>) &#123;<span class="keyword">if</span> (c==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">-1</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span> (c&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;c&lt;=<span class="string">&#x27;9&#x27;</span>) &#123;x=x*<span class="number">10</span>+c-<span class="string">&#x27;0&#x27;</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> Debug&#123;</span><br><span class="line">	Tp <span class="type">void</span> _debug(<span class="type">char</span>* f,Ty t)&#123;cerr&lt;&lt;f&lt;&lt;<span class="string">&#x27;=&#x27;</span>&lt;&lt;t&lt;&lt;endl;&#125;</span><br><span class="line">	Ts <span class="type">void</span> _debug(<span class="type">char</span>* f,Ty x,Ar... y)&#123;<span class="keyword">while</span>(*f!=<span class="string">&#x27;,&#x27;</span>) cerr&lt;&lt;*f++;cerr&lt;&lt;<span class="string">&#x27;=&#x27;</span>&lt;&lt;x&lt;&lt;<span class="string">&quot;,&quot;</span>;_debug(f+<span class="number">1</span>,y...);&#125;</span><br><span class="line">	Tp ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; os,vector&lt;Ty&gt;&amp; V)&#123;os&lt;&lt;<span class="string">&quot;[&quot;</span>;<span class="keyword">for</span>(<span class="keyword">auto</span>&amp; vv:V) os&lt;&lt;vv&lt;&lt;<span class="string">&quot;,&quot;</span>;os&lt;&lt;<span class="string">&quot;]&quot;</span>;<span class="keyword">return</span> os;&#125;</span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> gdb(...) _debug((char*)#__VA_ARGS__,__VA_ARGS__)</span></span><br><span class="line">&#125;<span class="keyword">using</span> <span class="keyword">namespace</span> Debug;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;to[maxn];</span><br><span class="line"><span class="type">int</span> root,cnt,n;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">yyy</span>&#123;</span><br><span class="line">	<span class="type">int</span> ls,rs,siz;</span><br><span class="line">&#125;f[maxn*<span class="number">62</span>];</span><br><span class="line"><span class="type">const</span> ll base=<span class="number">61</span>,N=(<span class="number">1ll</span>&lt;&lt;(base+<span class="number">1</span>))<span class="number">-1</span>;</span><br><span class="line">ll a[maxn];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">insert</span><span class="params">(ll l,ll r,<span class="type">int</span> &amp;rt,ll k,<span class="type">int</span> deep)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!rt) rt=++cnt,f[rt].siz=f[rt].ls=f[rt].rs=<span class="number">0</span>;</span><br><span class="line">	f[rt].siz++;</span><br><span class="line">	<span class="keyword">if</span> (l==r) <span class="keyword">return</span> ;</span><br><span class="line">	ll mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span> ((k&gt;&gt;deep)&amp;<span class="number">1</span>) <span class="built_in">insert</span>(mid+<span class="number">1</span>,r,f[rt].rs,k,deep<span class="number">-1</span>);</span><br><span class="line">	<span class="keyword">else</span> <span class="built_in">insert</span>(l,mid,f[rt].ls,k,deep<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> fa[maxn];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">query</span><span class="params">(ll l,ll r,<span class="type">int</span> &amp;rt,ll k,<span class="type">int</span> deep)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!rt) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (l==r) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	ll mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span> ((k&gt;&gt;deep)%<span class="number">2</span>==<span class="number">1</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (f[f[rt].ls].siz) <span class="keyword">return</span> (<span class="number">1ll</span>&lt;&lt;deep)+<span class="built_in">query</span>(l,mid,f[rt].ls,k,deep<span class="number">-1</span>);</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">query</span>(mid+<span class="number">1</span>,r,f[rt].rs,k,deep<span class="number">-1</span>);</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (f[f[rt].rs].siz) <span class="built_in">return</span> (<span class="number">1ll</span>&lt;&lt;deep)+<span class="built_in">query</span>(mid+<span class="number">1</span>,r,f[rt].rs,k,deep<span class="number">-1</span>);</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">query</span>(l,mid,f[rt].ls,k,deep<span class="number">-1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">ll Max,Ans[maxn],b[maxn],ans;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">clear</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">	root=cnt=ans=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">	ans=<span class="built_in">max</span>(ans,<span class="built_in">query</span>(<span class="number">0ll</span>,N,root,a[x],base));</span><br><span class="line">	<span class="built_in">insert</span>(<span class="number">0</span>,N,root,a[x],base);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> y:to[x]) <span class="built_in">add</span>(y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> pre)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (x!=<span class="number">1</span>) <span class="built_in">dfs</span>(fa[x],x);</span><br><span class="line">	Ans[x]=ans;</span><br><span class="line">	ans=<span class="built_in">max</span>(ans,<span class="built_in">query</span>(<span class="number">0</span>,N,root,a[x],base));</span><br><span class="line">	<span class="built_in">insert</span>(<span class="number">0</span>,N,root,a[x],base);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> y:to[x]) <span class="keyword">if</span> (y^pre) <span class="built_in">add</span>(y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;xor.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin); </span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;xor.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout);</span><br><span class="line">	<span class="type">int</span> i,x,j,tmpx,tmpy;</span><br><span class="line">	<span class="built_in">read</span>(n);</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">2</span>;i&lt;=n;i++) <span class="built_in">read</span>(x),to[x].<span class="built_in">push_back</span>(i),fa[i]=x;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;a[i]);</span><br><span class="line">		b[i]=<span class="built_in">query</span>(<span class="number">0</span>,N,root,a[i],base);</span><br><span class="line">		<span class="built_in">insert</span>(<span class="number">0</span>,N,root,a[i],base);</span><br><span class="line">		Max=<span class="built_in">max</span>(b[i],Max);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) <span class="keyword">if</span> (Max==b[i]) &#123;</span><br><span class="line">		tmpx=i;</span><br><span class="line">		<span class="keyword">for</span> (j=<span class="number">1</span>;j&lt;i;j++) <span class="keyword">if</span> ((a[i]^a[j])==Max) &#123;tmpy=j;<span class="keyword">break</span>;&#125; </span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">memset</span>(Ans,<span class="number">-1</span>,<span class="built_in">sizeof</span>(Ans));</span><br><span class="line">	<span class="built_in">clear</span>();<span class="built_in">dfs</span>(tmpx,<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">clear</span>();<span class="built_in">dfs</span>(tmpy,<span class="number">0</span>);</span><br><span class="line">	Ans[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) <span class="keyword">if</span> (Ans[i]&gt;=<span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,Ans[i]);<span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,Max);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Hint"><a href="#Hint" class="headerlink" title="Hint"></a>Hint</h3><p><strong>不要左移 $63$ 位，会爆 long long！！！</strong></p>
<h2 id="T4-boxing"><a href="#T4-boxing" class="headerlink" title="T4. boxing"></a>T4. boxing</h2><h3 id="Description-3"><a href="#Description-3" class="headerlink" title="Description"></a>Description</h3><p><img src="https://s2.loli.net/2023/07/18/PoKFufvWizSw9ht.png" alt="image-20230718074834660"></p>
<p>$n\le 9,k\le 16,k\le n$</p>
<p>1s 512MB</p>
<h3 id="Solution-3"><a href="#Solution-3" class="headerlink" title="Solution"></a>Solution</h3><p>dp 套 dp</p>
<p>先不考虑 $k$ 的限制。不妨先将 $m_i$ 个选手升序排序。令 $f[i][j]$ 表示前 $i$ 个选手，位置状态为 $j$ 。根据每个人选或者不选，排列一下。</p>
<p>考虑 LIS 的限制，有一个<strong>经典套路</strong>就是维护 $[1,i]$ （不一定以 $i$ 结尾）的最长上升子序列长度 ，差分一下，显然所有的值只有 $0,1$。维护的时候，按权值从小到大加入，加入第 $i$ 个位置的数时，只需要将第 $i$ 个点的位置改为 $1$ ，之后的第一个 $1$ 改为 $0$ ，如果后面没有 $1$ 则不修改。</p>
<p>这里的转移可以预处理。复杂度 $O(nm2^n\cdot 2^n)$ 。</p>
<p>令位置的状态 $S$， LIS 的状态 $T\subseteq S$，所以复杂度可以变为 $O(nm3^n)$</p>
<h3 id="Code-3"><a href="#Code-3" class="headerlink" title="Code"></a>Code</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">9</span>,M=<span class="number">17</span>,K=<span class="number">1</span>&lt;&lt;N,P=K+<span class="number">10</span>,mod=<span class="number">998244353</span>;</span><br><span class="line"><span class="type">int</span> n,m,k,a[M];</span><br><span class="line"><span class="type">int</span> f[M][K][K],trs[K][N];</span><br><span class="line"><span class="type">int</span> C[P][P],fac[P];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">   	<span class="built_in">freopen</span>(<span class="string">&quot;boxing.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin); </span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;boxing.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;P;i++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=C[i][<span class="number">0</span>]=<span class="number">1</span>;j&lt;=i;j++)&#123;</span><br><span class="line">			C[i][j]=(C[i<span class="number">-1</span>][j<span class="number">-1</span>]+C[i<span class="number">-1</span>][j])%mod;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=fac[<span class="number">0</span>]=<span class="number">1</span>;i&lt;P;i++)fac[i]=<span class="number">1ll</span>*fac[i<span class="number">-1</span>]*i%mod;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;m&gt;&gt;k;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)cin&gt;&gt;a[i];</span><br><span class="line">	<span class="built_in">sort</span>(a+<span class="number">1</span>,a+<span class="number">1</span>+m);</span><br><span class="line">	<span class="type">int</span> U=(<span class="number">1</span>&lt;&lt;n)<span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> S=<span class="number">0</span>;S&lt;=U;S++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)<span class="keyword">if</span>(~S&gt;&gt;i&amp;<span class="number">1</span>)&#123;</span><br><span class="line">			trs[S][i]=S|(<span class="number">1</span>&lt;&lt;i);</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;n;j++)<span class="keyword">if</span>(S&gt;&gt;j&amp;<span class="number">1</span>)&#123;</span><br><span class="line">				trs[S][i]^=<span class="number">1</span>&lt;&lt;j;<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	f[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> S=<span class="number">0</span>;S&lt;=U;S++)&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> T=<span class="number">0</span>;T&lt;=U;T++)&#123;</span><br><span class="line">				<span class="keyword">if</span>(!f[i<span class="number">-1</span>][S][T])<span class="keyword">continue</span>;</span><br><span class="line">				(f[i][S][T]+=f[i<span class="number">-1</span>][S][T])%=mod;</span><br><span class="line">				<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j++)<span class="keyword">if</span>(~S&gt;&gt;j&amp;<span class="number">1</span>)&#123;</span><br><span class="line">					<span class="type">int</span> &amp;nex=f[i][S|(<span class="number">1</span>&lt;&lt;j)][trs[T][j]];</span><br><span class="line">					<span class="keyword">if</span>(a[i]-S<span class="number">-2</span>&lt;<span class="number">0</span>)<span class="keyword">continue</span>;</span><br><span class="line">					nex=(nex+<span class="number">1ll</span>*f[i<span class="number">-1</span>][S][T]*C[a[i]-S<span class="number">-2</span>][(<span class="number">1</span>&lt;&lt;j)<span class="number">-1</span>])%mod;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> T=<span class="number">0</span>;T&lt;=U;T++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(__builtin_popcount(T)&lt;k)<span class="keyword">continue</span>;</span><br><span class="line">		(ans+=f[m][U][T])%=mod;</span><br><span class="line">	&#125;</span><br><span class="line">	ans=(<span class="number">1ll</span>&lt;&lt;n)*ans%mod;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)ans=<span class="number">1ll</span>*ans*fac[<span class="number">1</span>&lt;&lt;i]%mod;</span><br><span class="line">	cout&lt;&lt;ans;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>NOIP模拟赛</tag>
        <tag>dp套dp</tag>
        <tag>01trie</tag>
      </tags>
  </entry>
  <entry>
    <title>7.6 模拟赛</title>
    <url>/2023/07/07/7-6-%E6%A8%A1%E6%8B%9F%E8%B5%9B/</url>
    <content><![CDATA[<h1 id="Day-3"><a href="#Day-3" class="headerlink" title="Day 3"></a>Day 3</h1><h2 id="T1-rail"><a href="#T1-rail" class="headerlink" title="T1. rail"></a>T1. rail</h2><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p><img src="https://s2.loli.net/2023/07/07/LDj5cd6tn1UJvfP.png"></p>
<p>$n,m\le 10^5$ </p>
<p>1s 512MB</p>
<h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><p>正着做会有问题，考虑反着做。（有人可能会问为什么有问题？找几个刁钻数据手玩一下，我不想写了）</p>
<p>记录每个区间向左一步可以到达（即右端点在这个区间内的）的最左端。然后倍增。倒数第二步的时候特判。细节看代码。</p>
<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 200005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> put() putchar(<span class="string">&#x27;\n&#x27;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Tp template<span class="string">&lt;typename Ty&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Ts template<span class="string">&lt;typename Ty,typename... Ar&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(<span class="type">int</span> &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> f=<span class="number">1</span>;x=<span class="number">0</span>;<span class="type">char</span> c=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (c&lt;<span class="string">&#x27;0&#x27;</span>||c&gt;<span class="string">&#x27;9&#x27;</span>) &#123;<span class="keyword">if</span> (c==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">-1</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span> (c&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;c&lt;=<span class="string">&#x27;9&#x27;</span>) &#123;x=x*<span class="number">10</span>+c-<span class="string">&#x27;0&#x27;</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> Debug&#123;</span><br><span class="line">	Tp <span class="type">void</span> _debug(<span class="type">char</span>* f,Ty t)&#123;cerr&lt;&lt;f&lt;&lt;<span class="string">&#x27;=&#x27;</span>&lt;&lt;t&lt;&lt;endl;&#125;</span><br><span class="line">	Ts <span class="type">void</span> _debug(<span class="type">char</span>* f,Ty x,Ar... y)&#123;<span class="keyword">while</span>(*f!=<span class="string">&#x27;,&#x27;</span>) cerr&lt;&lt;*f++;cerr&lt;&lt;<span class="string">&#x27;=&#x27;</span>&lt;&lt;x&lt;&lt;<span class="string">&quot;,&quot;</span>;_debug(f+<span class="number">1</span>,y...);&#125;</span><br><span class="line">	Tp ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; os,vector&lt;Ty&gt;&amp; V)&#123;os&lt;&lt;<span class="string">&quot;[&quot;</span>;<span class="keyword">for</span>(<span class="keyword">auto</span>&amp; vv:V) os&lt;&lt;vv&lt;&lt;<span class="string">&quot;,&quot;</span>;os&lt;&lt;<span class="string">&quot;]&quot;</span>;<span class="keyword">return</span> os;&#125;</span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> gdb(...) _debug((char*)#__VA_ARGS__,__VA_ARGS__)</span></span><br><span class="line">&#125;<span class="keyword">using</span> <span class="keyword">namespace</span> Debug;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> f[maxn][<span class="number">21</span>];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">	<span class="type">int</span> l,r,id;</span><br><span class="line">&#125;a[maxn],b[maxn];  </span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">cmp</span><span class="params">(node x,node y)</span> </span>&#123;<span class="keyword">return</span> x.l&lt;y.l;&#125;</span><br><span class="line"><span class="type">int</span> minn[maxn][<span class="number">21</span>],g[maxn],tot,lg[maxn];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> z=lg[r-l+<span class="number">1</span>];</span><br><span class="line">	<span class="keyword">if</span> (b[minn[l][z]].l&lt;b[minn[r-(<span class="number">1</span>&lt;&lt;z)+<span class="number">1</span>][z]].l) <span class="keyword">return</span> minn[l][z];</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> minn[r-(<span class="number">1</span>&lt;&lt;z)+<span class="number">1</span>][z];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">  	<span class="built_in">freopen</span>(<span class="string">&quot;rail.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;rail.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout);</span><br><span class="line">	<span class="type">int</span> i,j,x,y,tmp1,tmp2;</span><br><span class="line">	<span class="built_in">read</span>(n);<span class="built_in">read</span>(m);</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="built_in">read</span>(a[i].l),<span class="built_in">read</span>(a[i].r),a[i].id=i;</span><br><span class="line">		g[++tot]=a[i].l;g[++tot]=a[i].r;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">sort</span>(g+<span class="number">1</span>,g+<span class="number">1</span>+tot);</span><br><span class="line">	tot=<span class="built_in">unique</span>(g+<span class="number">1</span>,g+<span class="number">1</span>+tot)-g<span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) a[i].l=<span class="built_in">lower_bound</span>(g+<span class="number">1</span>,g+<span class="number">1</span>+tot,a[i].l)-g,a[i].r=<span class="built_in">lower_bound</span>(g+<span class="number">1</span>,g+<span class="number">1</span>+tot,a[i].r)-g;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) b[i]=a[i];</span><br><span class="line">	b[<span class="number">0</span>].l=<span class="number">1e9</span>;</span><br><span class="line">	<span class="built_in">sort</span>(a+<span class="number">1</span>,a+<span class="number">1</span>+n,cmp);</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) </span><br><span class="line">		<span class="keyword">if</span> (b[minn[a[i].r][<span class="number">0</span>]].l&gt;a[i].l) minn[a[i].r][<span class="number">0</span>]=a[i].id;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">2</span>;i&lt;=tot;i++) lg[i]=lg[i/<span class="number">2</span>]+<span class="number">1</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> (j=<span class="number">1</span>;j&lt;=<span class="number">20</span>;j++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (i=<span class="number">1</span>;i+(<span class="number">1</span>&lt;&lt;j)<span class="number">-1</span>&lt;=tot;i++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (b[minn[i][j<span class="number">-1</span>]].l&lt;b[minn[i+(<span class="number">1</span>&lt;&lt;j<span class="number">-1</span>)][j<span class="number">-1</span>]].l) minn[i][j]=minn[i][j<span class="number">-1</span>];</span><br><span class="line">			<span class="keyword">else</span> minn[i][j]=minn[i+(<span class="number">1</span>&lt;&lt;j<span class="number">-1</span>)][j<span class="number">-1</span>];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="type">int</span> x=<span class="built_in">query</span>(a[i].l,a[i].r);</span><br><span class="line">		<span class="keyword">if</span> (x&lt;<span class="number">0</span>||a[i].l&lt;=b[x].l) f[a[i].id][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">else</span> f[a[i].id][<span class="number">0</span>]=x;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (j=<span class="number">1</span>;j&lt;=<span class="number">20</span>;j++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">			f[i][j]=f[f[i][j<span class="number">-1</span>]][j<span class="number">-1</span>];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (m--) &#123;</span><br><span class="line">		<span class="built_in">read</span>(x),<span class="built_in">read</span>(y);</span><br><span class="line">		<span class="keyword">if</span> (b[y].r&lt;b[x].r) &#123;<span class="built_in">puts</span>(<span class="string">&quot;impossible&quot;</span>);<span class="keyword">continue</span>;&#125;</span><br><span class="line">		<span class="keyword">if</span> (x==y) &#123;<span class="built_in">puts</span>(<span class="string">&quot;0&quot;</span>);<span class="keyword">continue</span>;&#125; </span><br><span class="line">		<span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">20</span>;i&gt;=<span class="number">0</span>;i--) &#123;</span><br><span class="line">			<span class="keyword">if</span> (f[y][i]&amp;&amp;b[f[y][i]].l&gt;b[x].l) y=f[y][i],ans+=(<span class="number">1</span>&lt;&lt;i);</span><br><span class="line">		&#125;</span><br><span class="line"><span class="comment">//		gdb(f[y][0],b[f[y][0]].l,b[x].l,b[x].r);</span></span><br><span class="line"><span class="comment">//      y=(1 3) x=(2 3) 根本没有 f[y][0] 就ji了 </span></span><br><span class="line"><span class="comment">//		if (b[f[y][0]].l&gt;b[x].r) &#123;puts(&quot;impossible&quot;);continue;&#125;</span></span><br><span class="line">		<span class="keyword">if</span> (b[y].r&gt;=b[x].r&amp;&amp;b[y].l&lt;=b[x].r) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans+<span class="number">1</span>);</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			y=f[y][<span class="number">0</span>];</span><br><span class="line">			<span class="keyword">if</span> (b[y].r&gt;=b[x].r&amp;&amp;b[y].l&lt;=b[x].r) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans+<span class="number">2</span>);</span><br><span class="line">			<span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;impossible&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="T2-wifi"><a href="#T2-wifi" class="headerlink" title="T2. wifi"></a>T2. wifi</h2><h3 id="Description-1"><a href="#Description-1" class="headerlink" title="Description"></a>Description</h3><p>有 $n$ 个点，每个点的权值为 $w_i$。可以选择一些点。每个点的贡献是<strong>左右两个最近的被选的点</strong>的权值和。求权值和最大。</p>
<p>$n\le 2\times 10^6$</p>
<p>1s 512MB</p>
<h3 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution"></a>Solution</h3><p>很妙的一道题。</p>
<p>考虑 $n^2$ dp，$f[i]&#x3D;\max f_i+(i-j)*(w_i+w_j)$，$1$ 和 $n$ 必须选。</p>
<p>观察到本质上是把每个点抽象成 $(i,w_i)$ ，选出一些点，求相邻两个与 $x$ 轴构成的梯形的面积之和最大。模拟一下，这些点即为原图的上凸包。</p>
<h3 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 2000005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> put() putchar(<span class="string">&#x27;\n&#x27;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Tp template<span class="string">&lt;typename Ty&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Ts template<span class="string">&lt;typename Ty,typename... Ar&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(<span class="type">int</span> &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> f=<span class="number">1</span>;x=<span class="number">0</span>;<span class="type">char</span> c=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (c&lt;<span class="string">&#x27;0&#x27;</span>||c&gt;<span class="string">&#x27;9&#x27;</span>) &#123;<span class="keyword">if</span> (c==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">-1</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span> (c&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;c&lt;=<span class="string">&#x27;9&#x27;</span>) &#123;x=x*<span class="number">10</span>+c-<span class="string">&#x27;0&#x27;</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> Debug&#123;</span><br><span class="line">	Tp <span class="type">void</span> _debug(<span class="type">char</span>* f,Ty t)&#123;cerr&lt;&lt;f&lt;&lt;<span class="string">&#x27;=&#x27;</span>&lt;&lt;t&lt;&lt;endl;&#125;</span><br><span class="line">	Ts <span class="type">void</span> _debug(<span class="type">char</span>* f,Ty x,Ar... y)&#123;<span class="keyword">while</span>(*f!=<span class="string">&#x27;,&#x27;</span>) cerr&lt;&lt;*f++;cerr&lt;&lt;<span class="string">&#x27;=&#x27;</span>&lt;&lt;x&lt;&lt;<span class="string">&quot;,&quot;</span>;_debug(f+<span class="number">1</span>,y...);&#125;</span><br><span class="line">	Tp ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; os,vector&lt;Ty&gt;&amp; V)&#123;os&lt;&lt;<span class="string">&quot;[&quot;</span>;<span class="keyword">for</span>(<span class="keyword">auto</span>&amp; vv:V) os&lt;&lt;vv&lt;&lt;<span class="string">&quot;,&quot;</span>;os&lt;&lt;<span class="string">&quot;]&quot;</span>;<span class="keyword">return</span> os;&#125;</span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> gdb(...) _debug((char*)#__VA_ARGS__,__VA_ARGS__)</span></span><br><span class="line">&#125;<span class="keyword">using</span> <span class="keyword">namespace</span> Debug;</span><br><span class="line"><span class="type">int</span> f[maxn],w[maxn],n,ans;</span><br><span class="line"><span class="keyword">namespace</span> STD&#123;</span><br><span class="line">	<span class="type">int</span> q[maxn],head,tail;</span><br><span class="line">	<span class="type">int</span> ans;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">		<span class="type">int</span> x,y;</span><br><span class="line">	&#125;a[maxn];</span><br><span class="line">	<span class="type">int</span> stac[maxn];</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">double</span> <span class="title">cross</span><span class="params">(node x,node y)</span> </span>&#123;<span class="keyword">return</span> <span class="number">1.0</span>*(x.y-y.y)/(x.x-y.x);&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">		<span class="type">int</span> i;</span><br><span class="line">		<span class="type">int</span> tot=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) a[i].x=i,a[i].y=w[i];</span><br><span class="line">		<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">			<span class="keyword">while</span> (tot&gt;=<span class="number">2</span>&amp;&amp;<span class="built_in">cross</span>(a[stac[tot]],a[stac[tot<span class="number">-1</span>]])&lt;<span class="built_in">cross</span>(a[i],a[stac[tot]])) tot--;</span><br><span class="line">			stac[++tot]=i;</span><br><span class="line">		&#125; </span><br><span class="line">		<span class="keyword">for</span> (i=<span class="number">2</span>;i&lt;=tot;i++) ans+=(a[stac[i]].x-a[stac[i<span class="number">-1</span>]].x)*(a[stac[i]].y+a[stac[i<span class="number">-1</span>]].y);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,ans); </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">  	<span class="built_in">freopen</span>(<span class="string">&quot;wifi.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;wifi.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout); </span><br><span class="line">	<span class="type">int</span> i,j;</span><br><span class="line">	<span class="built_in">read</span>(n);</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">read</span>(w[i]);</span><br><span class="line">	STD::<span class="built_in">main</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="T3-chatnoi"><a href="#T3-chatnoi" class="headerlink" title="T3. chatnoi"></a>T3. chatnoi</h2><h3 id="Description-2"><a href="#Description-2" class="headerlink" title="Description"></a>Description</h3><p><img src="https://s2.loli.net/2023/07/07/1FbmaKvweyRA367.png"></p>
<p>$n,q\le 5\times 10^5,k\le 10$</p>
<p>3s , 512MB</p>
<h3 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution"></a>Solution</h3><p>把每连续 $k$ 个单词抽象成一个点，每个似然度为一条边。后面加一个单词为一个转移。这样建出来一张图。</p>
<p>对于每一次询问，就是从这个点（没有点就是 $0$）出发，至少经过 $m$ 条边的路径上的最小值的最大值。如果在一个大小不为 $1$ 的强连通分量（或者有自环），就可以走无数次。</p>
<p>一个很重要的性质，就是所有边的边权之和为 $n$。这种边的种类只有 $\sqrt n$ 种。对每种边的边权构成的图跑答案。查询时二分即可。这样的复杂度为 $O(n\sqrt n)$</p>
<p>另外的一种想法，就是大于等于 $i$ 的边权最多只有 $\dfrac{n}{i}$ 种，复杂度是调和级数 $O(n\log n)$。</p>
<p>但事实上，上面的跑不满，所以跑的更快。</p>
<h3 id="Code-2"><a href="#Code-2" class="headerlink" title="Code"></a>Code</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 500005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> put() putchar(<span class="string">&#x27;\n&#x27;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Tp template<span class="string">&lt;typename Ty&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Ts template<span class="string">&lt;typename Ty,typename... Ar&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(<span class="type">int</span> &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> f=<span class="number">1</span>;x=<span class="number">0</span>;<span class="type">char</span> c=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (c&lt;<span class="string">&#x27;0&#x27;</span>||c&gt;<span class="string">&#x27;9&#x27;</span>) &#123;<span class="keyword">if</span> (c==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">-1</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span> (c&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;c&lt;=<span class="string">&#x27;9&#x27;</span>) &#123;x=x*<span class="number">10</span>+c-<span class="string">&#x27;0&#x27;</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> Debug&#123;</span><br><span class="line">	Tp <span class="type">void</span> _debug(<span class="type">char</span>* f,Ty t)&#123;cerr&lt;&lt;f&lt;&lt;<span class="string">&#x27;=&#x27;</span>&lt;&lt;t&lt;&lt;endl;&#125;</span><br><span class="line">	Ts <span class="type">void</span> _debug(<span class="type">char</span>* f,Ty x,Ar... y)&#123;<span class="keyword">while</span>(*f!=<span class="string">&#x27;,&#x27;</span>) cerr&lt;&lt;*f++;cerr&lt;&lt;<span class="string">&#x27;=&#x27;</span>&lt;&lt;x&lt;&lt;<span class="string">&quot;,&quot;</span>;_debug(f+<span class="number">1</span>,y...);&#125;</span><br><span class="line">	Tp ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; os,vector&lt;Ty&gt;&amp; V)&#123;os&lt;&lt;<span class="string">&quot;[&quot;</span>;<span class="keyword">for</span>(<span class="keyword">auto</span>&amp; vv:V) os&lt;&lt;vv&lt;&lt;<span class="string">&quot;,&quot;</span>;os&lt;&lt;<span class="string">&quot;]&quot;</span>;<span class="keyword">return</span> os;&#125;</span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> gdb(...) _debug((char*)#__VA_ARGS__,__VA_ARGS__)</span></span><br><span class="line">&#125;<span class="keyword">using</span> <span class="keyword">namespace</span> Debug;</span><br><span class="line"><span class="type">int</span> n,k,q;</span><br><span class="line">string s;</span><br><span class="line">map&lt;string,<span class="type">int</span>&gt;mp;</span><br><span class="line"><span class="type">int</span> w[maxn],cnt,cnt2;</span><br><span class="line">map&lt;<span class="type">int</span>,<span class="type">int</span>&gt;O[maxn];</span><br><span class="line">map&lt;pair&lt;ll,ll&gt;,<span class="type">int</span>&gt;g;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>,base=<span class="number">37</span>,base2=<span class="number">41</span>,mod2=<span class="number">998244353</span>;</span><br><span class="line"><span class="type">int</span> head=<span class="number">1</span>,h[maxn];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">yyy</span>&#123;</span><br><span class="line">	<span class="type">int</span> to,z;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">		to=y;z=h[x];h[x]=head;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;a[maxn*<span class="number">2</span>];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edges</span>&#123;<span class="type">int</span> x,y,w;&#125;e[maxn];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">cmp</span><span class="params">(edges x,edges y)</span> </span>&#123;<span class="keyword">return</span> x.w&gt;y.w;&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="type">int</span> enums,now;</span><br><span class="line"><span class="type">int</span> dfn[maxn],low[maxn],stac[maxn],tot,vis[maxn],times;</span><br><span class="line"><span class="type">int</span> v[maxn],id[maxn],idnum;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;to[maxn];</span><br><span class="line"><span class="type">int</span> dccnums,dcc[maxn],siz[maxn],f[maxn],Max[maxn];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">tarjan</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> pre)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	dfn[x]=low[x]=++times;vis[x]=<span class="number">1</span>;stac[++tot]=x;</span><br><span class="line">	<span class="keyword">for</span> (i=h[x];i;i=a[i].z)  &#123;</span><br><span class="line">		<span class="keyword">if</span> (!dfn[a[i].to]) &#123;</span><br><span class="line">			<span class="built_in">tarjan</span>(a[i].to,x);</span><br><span class="line">			low[x]=<span class="built_in">min</span>(low[a[i].to],low[x]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (vis[a[i].to]) low[x]=<span class="built_in">min</span>(dfn[a[i].to],low[x]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (low[x]==dfn[x]) &#123;</span><br><span class="line">		++dccnums;</span><br><span class="line">		<span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">			vis[stac[tot]]=<span class="number">0</span>;</span><br><span class="line">			dcc[stac[tot]]=dccnums;</span><br><span class="line">			siz[dccnums]++;</span><br><span class="line">			<span class="keyword">if</span> (stac[tot--]==x) <span class="keyword">return</span> ;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;<span class="keyword">if</span> (!v[x]) id[++idnum]=x,v[x]=<span class="number">1</span>;&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">	<span class="type">int</span> x,w;</span><br><span class="line">	<span class="type">bool</span> <span class="keyword">operator</span> &lt;(<span class="type">const</span> node &amp;a) <span class="type">const</span> &#123;<span class="keyword">return</span> w&lt;a.w;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;node&gt;Ans[maxn];</span><br><span class="line"><span class="type">int</span> len[maxn],flag[maxn];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> minn)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> i,x,j;</span><br><span class="line">	<span class="type">int</span> las=now; </span><br><span class="line">	<span class="keyword">while</span> (now&lt;enums&amp;&amp;e[now+<span class="number">1</span>].w&gt;=minn) now++,a[++head].<span class="built_in">add</span>(e[now].x,e[now].y),<span class="built_in">add</span>(e[now].x),<span class="built_in">add</span>(e[now].y);</span><br><span class="line">	<span class="keyword">if</span> (now==las) <span class="keyword">return</span> ;</span><br><span class="line">	dccnums=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=idnum;i++) &#123;</span><br><span class="line">		x=id[i];</span><br><span class="line">		dfn[x]=low[x]=vis[x]=dcc[x]=stac[i]=<span class="number">0</span>;</span><br><span class="line">		siz[i]=f[i]=<span class="number">0</span>;to[i].<span class="built_in">clear</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=idnum;i++) <span class="keyword">if</span> (!dfn[id[i]]) <span class="built_in">tarjan</span>(id[i],<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=idnum;i++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (j=h[id[i]];j;j=a[j].z) </span><br><span class="line">			<span class="keyword">if</span> (id[i]==a[j].to) siz[dcc[id[i]]]++;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (dcc[id[i]]!=dcc[a[j].to]) </span><br><span class="line">				to[dcc[a[j].to]].<span class="built_in">push_back</span>(dcc[id[i]]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=dccnums;i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (siz[i]&gt;<span class="number">1</span>) f[i]=<span class="number">5e5</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> y:to[i]) f[y]=<span class="built_in">max</span>(f[y],f[i]+<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=idnum;i++) &#123;</span><br><span class="line">		x=id[i];</span><br><span class="line">		Ans[x].<span class="built_in">push_back</span>((node)&#123;minn,f[dcc[x]]&#125;),len[x]++;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">pair&lt;ll,ll&gt;c[maxn];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;cc;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line"><span class="comment">//	freopen(&quot;GB-04.in&quot;,&quot;r&quot;,stdin);</span></span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;chatnoi.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">  	<span class="built_in">freopen</span>(<span class="string">&quot;chatnoi.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout);</span><br><span class="line">	<span class="type">int</span> i,j,nums,tmp;ll sum1,sum2,sum;</span><br><span class="line">	cin.<span class="built_in">tie</span>(<span class="number">0</span>);std::ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		cin&gt;&gt;s;</span><br><span class="line">		<span class="keyword">if</span> (!mp[s]) mp[s]=++cnt;</span><br><span class="line">		w[i]=mp[s];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n-k+<span class="number">1</span>;i++) &#123;</span><br><span class="line">		sum1=<span class="number">0</span>,sum2=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (sum=<span class="number">0</span>,j=i;j&lt;=i+k<span class="number">-1</span>;j++) sum1=(sum1*base+w[j])%mod,sum2=(sum2*base2+w[j])%mod2;</span><br><span class="line">		c[i]=<span class="built_in">make_pair</span>(sum1,sum2);</span><br><span class="line">		<span class="keyword">if</span> (!g[c[i]]) g[c[i]]=++cnt2;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n-k;i++) O[g[c[i]]][g[c[i+<span class="number">1</span>]]]++;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=cnt2;i++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> tmp:O[i]) &#123;</span><br><span class="line">			++enums;</span><br><span class="line">			e[enums].x=i;</span><br><span class="line">			e[enums].y=tmp.fi;</span><br><span class="line">			e[enums].w=tmp.se;</span><br><span class="line">		&#125; </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">sort</span>(e+<span class="number">1</span>,e+<span class="number">1</span>+enums,cmp);</span><br><span class="line">	<span class="keyword">for</span> (i=n;i&gt;=<span class="number">1</span>;i--) <span class="built_in">solve</span>(i);</span><br><span class="line">	cin&gt;&gt;q;</span><br><span class="line">	<span class="keyword">while</span> (q--) &#123;</span><br><span class="line">		cin&gt;&gt;nums;sum=<span class="number">0</span>;</span><br><span class="line">		sum1=<span class="number">0</span>,sum2=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=k;i++) cin&gt;&gt;s,sum1=(sum1*base+mp[s])%mod,sum2=(sum2*base2+mp[s])%mod2;</span><br><span class="line">		sum=g[<span class="built_in">make_pair</span>(sum1,sum2)];</span><br><span class="line">		<span class="keyword">if</span> (sum==<span class="number">0</span>) &#123;<span class="built_in">puts</span>(<span class="string">&quot;0&quot;</span>);<span class="keyword">continue</span>;&#125;</span><br><span class="line">		<span class="keyword">auto</span> it=<span class="built_in">lower_bound</span>(Ans[sum].<span class="built_in">begin</span>(),Ans[sum].<span class="built_in">end</span>(),(node)&#123;<span class="number">0</span>,nums&#125;);</span><br><span class="line">		<span class="keyword">if</span> (it==Ans[sum].<span class="built_in">end</span>()) <span class="built_in">puts</span>(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,(*it).x); </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="T4-snow"><a href="#T4-snow" class="headerlink" title="T4. snow"></a>T4. snow</h2><p>P8182 有点难，待补。</p>
]]></content>
      <tags>
        <tag>NOIP模拟赛</tag>
        <tag>dp</tag>
        <tag>倍增</tag>
        <tag>凸包</tag>
        <tag>tarjan</tag>
      </tags>
  </entry>
  <entry>
    <title>7.7 模拟赛</title>
    <url>/2023/07/07/7-7-%E6%A8%A1%E6%8B%9F%E8%B5%9B/</url>
    <content><![CDATA[<h1 id="Day-4"><a href="#Day-4" class="headerlink" title="Day 4"></a>Day 4</h1><h2 id="T1-match"><a href="#T1-match" class="headerlink" title="T1. match"></a>T1. match</h2><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>在一个长度位 $2n$ 的序列中，有 $n$ 个黑点和白点。你需要将黑白点连线。每个黑点或白点只能连一条。$i$ 和 $j$ 连线起来的代价是 $|i-j|$。求最小代价。</p>
<p>$1\le n\le 10^5$</p>
<p>1s ,512MB</p>
<h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><p>算是这几天最简单的 T1 了。直接栈模拟和最近的点配对即可。</p>
<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 200005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> put() putchar(<span class="string">&#x27;\n&#x27;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Tp template<span class="string">&lt;typename Ty&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Ts template<span class="string">&lt;typename Ty,typename... Ar&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(<span class="type">int</span> &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> f=<span class="number">1</span>;x=<span class="number">0</span>;<span class="type">char</span> c=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (c&lt;<span class="string">&#x27;0&#x27;</span>||c&gt;<span class="string">&#x27;9&#x27;</span>) &#123;<span class="keyword">if</span> (c==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">-1</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span> (c&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;c&lt;=<span class="string">&#x27;9&#x27;</span>) &#123;x=x*<span class="number">10</span>+c-<span class="string">&#x27;0&#x27;</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> Debug&#123;</span><br><span class="line">	Tp <span class="type">void</span> _debug(<span class="type">char</span>* f,Ty t)&#123;cerr&lt;&lt;f&lt;&lt;<span class="string">&#x27;=&#x27;</span>&lt;&lt;t&lt;&lt;endl;&#125;</span><br><span class="line">	Ts <span class="type">void</span> _debug(<span class="type">char</span>* f,Ty x,Ar... y)&#123;<span class="keyword">while</span>(*f!=<span class="string">&#x27;,&#x27;</span>) cerr&lt;&lt;*f++;cerr&lt;&lt;<span class="string">&#x27;=&#x27;</span>&lt;&lt;x&lt;&lt;<span class="string">&quot;,&quot;</span>;_debug(f+<span class="number">1</span>,y...);&#125;</span><br><span class="line">	Tp ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; os,vector&lt;Ty&gt;&amp; V)&#123;os&lt;&lt;<span class="string">&quot;[&quot;</span>;<span class="keyword">for</span>(<span class="keyword">auto</span>&amp; vv:V) os&lt;&lt;vv&lt;&lt;<span class="string">&quot;,&quot;</span>;os&lt;&lt;<span class="string">&quot;]&quot;</span>;<span class="keyword">return</span> os;&#125;</span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> gdb(...) _debug((char*)#__VA_ARGS__,__VA_ARGS__)</span></span><br><span class="line">&#125;<span class="keyword">using</span> <span class="keyword">namespace</span> Debug;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> a[maxn];</span><br><span class="line"><span class="type">int</span> stac[maxn],tot,ans;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;match.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;match.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout);</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="built_in">read</span>(n);</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n*<span class="number">2</span>;i++) <span class="built_in">read</span>(a[i]);</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n*<span class="number">2</span>;i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!tot) stac[++tot]=i;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (a[i]!=a[stac[<span class="number">1</span>]]) ans+=i-stac[tot],tot--;</span><br><span class="line">		<span class="keyword">else</span> stac[++tot]=i;</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="T2-photo"><a href="#T2-photo" class="headerlink" title="T2. photo"></a>T2. photo</h2><h3 id="Description-1"><a href="#Description-1" class="headerlink" title="Description"></a>Description</h3><p><img src="https://s2.loli.net/2023/07/07/372fHAvKighOSkc.png"></p>
<p>$n,m\le 1000$</p>
<p>2s 512MB</p>
<h3 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution"></a>Solution</h3><p>问到连通块个数，容易联想到欧拉平面图定理。$\text{点}-\text{边}+{面}-1&#x3D;\text{连通块个数}$。</p>
<p>其中面的个数是包含最外面的一个的。</p>
<p>根据启望的线性性，每个分开计算期望。</p>
<p>观察到<strong>颜色为黑色的点的连通块只有一个</strong>，所以我们统计白色连通块即可。应该是简单的。</p>
<h3 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 1005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> put() putchar(<span class="string">&#x27;\n&#x27;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Tp template<span class="string">&lt;typename Ty&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Ts template<span class="string">&lt;typename Ty,typename... Ar&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(<span class="type">int</span> &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> f=<span class="number">1</span>;x=<span class="number">0</span>;<span class="type">char</span> c=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (c&lt;<span class="string">&#x27;0&#x27;</span>||c&gt;<span class="string">&#x27;9&#x27;</span>) &#123;<span class="keyword">if</span> (c==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">-1</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span> (c&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;c&lt;=<span class="string">&#x27;9&#x27;</span>) &#123;x=x*<span class="number">10</span>+c-<span class="string">&#x27;0&#x27;</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> Debug&#123;</span><br><span class="line">	Tp <span class="type">void</span> _debug(<span class="type">char</span>* f,Ty t)&#123;cerr&lt;&lt;f&lt;&lt;<span class="string">&#x27;=&#x27;</span>&lt;&lt;t&lt;&lt;endl;&#125;</span><br><span class="line">	Ts <span class="type">void</span> _debug(<span class="type">char</span>* f,Ty x,Ar... y)&#123;<span class="keyword">while</span>(*f!=<span class="string">&#x27;,&#x27;</span>) cerr&lt;&lt;*f++;cerr&lt;&lt;<span class="string">&#x27;=&#x27;</span>&lt;&lt;x&lt;&lt;<span class="string">&quot;,&quot;</span>;_debug(f+<span class="number">1</span>,y...);&#125;</span><br><span class="line">	Tp ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; os,vector&lt;Ty&gt;&amp; V)&#123;os&lt;&lt;<span class="string">&quot;[&quot;</span>;<span class="keyword">for</span>(<span class="keyword">auto</span>&amp; vv:V) os&lt;&lt;vv&lt;&lt;<span class="string">&quot;,&quot;</span>;os&lt;&lt;<span class="string">&quot;]&quot;</span>;<span class="keyword">return</span> os;&#125;</span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> gdb(...) _debug((char*)#__VA_ARGS__,__VA_ARGS__)</span></span><br><span class="line">&#125;<span class="keyword">using</span> <span class="keyword">namespace</span> Debug;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">998244353</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> &amp;x,<span class="type">int</span> y)</span> </span>&#123;x=(x+(y%mod+mod))%mod;&#125;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> p[maxn][maxn],q[maxn][maxn],sufp[maxn][maxn],sufq[maxn][maxn];</span><br><span class="line"><span class="type">int</span> ans1,ans2,ans3;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">solve1</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> i,j;</span><br><span class="line">	<span class="built_in">add</span>(ans1,n+m+<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">2</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (j=<span class="number">2</span>;j&lt;=m;j++) &#123;</span><br><span class="line">			<span class="built_in">add</span>(ans1,sufp[i][j<span class="number">-1</span>]*sufq[i<span class="number">-1</span>][j]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">solve2</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> i,j;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">2</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (j=<span class="number">2</span>;j&lt;=m;j++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (j&lt;m) <span class="built_in">add</span>(ans2,sufp[i][j<span class="number">-1</span>]*sufq[i<span class="number">-1</span>][j]%mod*sufq[i<span class="number">-1</span>][j+<span class="number">1</span>]);</span><br><span class="line">			<span class="keyword">else</span> <span class="built_in">add</span>(ans2,sufp[i][j<span class="number">-1</span>]*sufq[i<span class="number">-1</span>][j]);</span><br><span class="line">			<span class="keyword">if</span> (i&lt;n) <span class="built_in">add</span>(ans2,sufq[i<span class="number">-1</span>][j]*sufp[i][j<span class="number">-1</span>]%mod*sufp[i+<span class="number">1</span>][j<span class="number">-1</span>]);</span><br><span class="line">			<span class="keyword">else</span> <span class="built_in">add</span>(ans2,sufq[i<span class="number">-1</span>][j]*sufp[i][j<span class="number">-1</span>]%mod);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">add</span>(ans2,n+m);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">solve3</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> i,j;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) sufq[i][m+<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=m;i++) sufp[n+<span class="number">1</span>][i]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">2</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (j=<span class="number">2</span>;j&lt;=m;j++) &#123;</span><br><span class="line">			<span class="built_in">add</span>(ans3,sufp[i][j<span class="number">-1</span>]*sufp[i+<span class="number">1</span>][j<span class="number">-1</span>]%mod*sufq[i<span class="number">-1</span>][j]%mod*sufq[i<span class="number">-1</span>][j+<span class="number">1</span>]%mod);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">  <span class="built_in">freopen</span>(<span class="string">&quot;photo.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">  	<span class="built_in">freopen</span>(<span class="string">&quot;photo.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout);</span><br><span class="line">	<span class="type">int</span> i,j;</span><br><span class="line">	<span class="built_in">read</span>(n);<span class="built_in">read</span>(m);</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) <span class="keyword">for</span> (j=<span class="number">1</span>;j&lt;=m;j++) <span class="built_in">read</span>(p[i][j]);</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) <span class="keyword">for</span> (j=<span class="number">1</span>;j&lt;=m;j++) <span class="built_in">read</span>(q[i][j]);</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n+<span class="number">2</span>;i++) <span class="keyword">for</span> (j=<span class="number">1</span>;j&lt;=m+<span class="number">2</span>;j++) <span class="built_in">add</span>(sufp[i][j],sufp[i][j<span class="number">-1</span>]+p[i][j]),<span class="built_in">add</span>(sufq[i][j],sufq[i<span class="number">-1</span>][j]+q[i][j]);</span><br><span class="line">	<span class="built_in">solve1</span>();<span class="comment">//dian</span></span><br><span class="line">	<span class="built_in">solve2</span>();<span class="comment">//bian</span></span><br><span class="line">	<span class="built_in">solve3</span>();<span class="comment">//mian</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,(<span class="number">1</span>+ans1-ans2+ans3+mod)%mod);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="T3-cover"><a href="#T3-cover" class="headerlink" title="T3. cover"></a>T3. cover</h2><h3 id="Description-2"><a href="#Description-2" class="headerlink" title="Description"></a>Description</h3><p><img src="https://s2.loli.net/2023/07/07/ligvIDZdTxEUQyS.png"></p>
<p>$n,q\le 2\times 10^6,m\le 2\times 10^5$</p>
<h3 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution"></a>Solution</h3><p>考虑先预处理出每个位置为左端点能到达的最右端的位置 $f_i$。用线段树维护是 $O(m\log n)$ 的，只有一次查询，查询的复杂度是 $O(n)$。</p>
<p>以 $(i,f_i)$ 为边建树。查询 $x,y$ 的时候，一个简单的想法是 $x$ 上不断向祖先跳，直到比 $y$ 大。可以用倍增处理，但这样查询的复杂度是 $O(q\log n)$，不是很好过。但是常数小的树剖表现的不错。</p>
<p>其实查询答案的时候，每次从 $x$ 跳到与 $y$ 深度相同的点 $z$，如果 $z&lt;y$ ，则答案为 $deep_y-deep_x+1$，否则为 $deep_y-deep_x$。</p>
<p>离线下来用 dfs 处理。复杂度 $O(m\log n +n +q)$，但是实现比书剖还慢，大概是 vector 的问题。</p>
<h3 id="Code-2"><a href="#Code-2" class="headerlink" title="Code"></a>Code</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 2000005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> put() putchar(<span class="string">&#x27;\n&#x27;</span>)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; </span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(<span class="type">int</span> &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> f=<span class="number">1</span>;x=<span class="number">0</span>;<span class="type">char</span> c=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (c&lt;<span class="string">&#x27;0&#x27;</span>||c&gt;<span class="string">&#x27;9&#x27;</span>) &#123;<span class="keyword">if</span> (c==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">-1</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span> (c&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;c&lt;=<span class="string">&#x27;9&#x27;</span>) &#123;x=x*<span class="number">10</span>+c-<span class="string">&#x27;0&#x27;</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Tp template<span class="string">&lt;typename Ty&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Ts template<span class="string">&lt;typename Ty,typename... Ar&gt;</span></span></span><br><span class="line"><span class="keyword">namespace</span> Debug&#123;</span><br><span class="line">	Tp <span class="type">void</span> _debug(<span class="type">char</span>* f,Ty t)&#123;cerr&lt;&lt;f&lt;&lt;<span class="string">&#x27;=&#x27;</span>&lt;&lt;t&lt;&lt;endl;&#125;</span><br><span class="line">	Ts <span class="type">void</span> _debug(<span class="type">char</span>* f,Ty x,Ar... y)&#123;<span class="keyword">while</span>(*f!=<span class="string">&#x27;,&#x27;</span>) cerr&lt;&lt;*f++;cerr&lt;&lt;<span class="string">&#x27;=&#x27;</span>&lt;&lt;x&lt;&lt;<span class="string">&quot;,&quot;</span>;_debug(f+<span class="number">1</span>,y...);&#125;</span><br><span class="line">	Tp ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; os,vector&lt;Ty&gt;&amp; V)&#123;os&lt;&lt;<span class="string">&quot;[&quot;</span>;<span class="keyword">for</span>(<span class="keyword">auto</span>&amp; vv:V) os&lt;&lt;vv&lt;&lt;<span class="string">&quot;,&quot;</span>;os&lt;&lt;<span class="string">&quot;]&quot;</span>;<span class="keyword">return</span> os;&#125;</span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> gdb(...) _debug((char*)#__VA_ARGS__,__VA_ARGS__)</span></span><br><span class="line">&#125;<span class="keyword">using</span> <span class="keyword">namespace</span> Debug;</span><br><span class="line"><span class="keyword">namespace</span> RD &#123;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="title">splitmix64</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> x)</span> </span>&#123;</span><br><span class="line">        x += <span class="number">0x9e3779b97f4a7c15</span>;</span><br><span class="line">        x = (x ^ (x &gt;&gt; <span class="number">30</span>)) * <span class="number">0xbf58476d1ce4e5b9</span>;</span><br><span class="line">        x = (x ^ (x &gt;&gt; <span class="number">27</span>)) * <span class="number">0x94d049bb133111eb</span>;</span><br><span class="line">        <span class="keyword">return</span> x ^ (x &gt;&gt; <span class="number">31</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> n, s;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> N, <span class="type">int</span> S)</span> </span>&#123;</span><br><span class="line">        n = N - <span class="number">1</span>, s = S;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; <span class="title">getquery</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        s = <span class="built_in">splitmix64</span>(s);</span><br><span class="line">        <span class="type">int</span> l = (s &gt;&gt; <span class="number">32</span>) % n;</span><br><span class="line">        <span class="type">int</span> r = (s &amp; (~(<span class="type">unsigned</span>)<span class="number">0</span>)) % n;</span><br><span class="line">        <span class="keyword">if</span> (l &gt; r)</span><br><span class="line">            <span class="built_in">swap</span>(l, r);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">pair</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt;(l + <span class="number">1</span>, r + <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,m,q,fa[maxn],lg[maxn];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">yyy</span>&#123;</span><br><span class="line">	<span class="type">int</span> lazy,L;</span><br><span class="line">&#125;f[maxn&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Update1</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> rt,<span class="type">int</span> head,<span class="type">int</span> tail,<span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (head&lt;=l&amp;&amp;r&lt;=tail) <span class="keyword">return</span> f[rt].lazy=<span class="built_in">max</span>(f[rt].lazy,k),<span class="built_in">void</span>();</span><br><span class="line">	<span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span> (head&lt;=mid) <span class="built_in">Update1</span>(l,mid,rt&lt;&lt;<span class="number">1</span>,head,tail,k);</span><br><span class="line">	<span class="keyword">if</span> (tail&gt;mid)  <span class="built_in">Update1</span>(mid+<span class="number">1</span>,r,rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,head,tail,k);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Update2</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> rt,<span class="type">int</span> head,<span class="type">int</span> tail)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (head&lt;=l&amp;&amp;r&lt;=tail) <span class="keyword">return</span> f[rt].L=<span class="built_in">max</span>(f[rt].L,tail-l+<span class="number">1</span>),<span class="built_in">void</span>();</span><br><span class="line">	<span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span> (head&lt;=mid) <span class="built_in">Update2</span>(l,mid,rt&lt;&lt;<span class="number">1</span>,head,tail);</span><br><span class="line">	<span class="keyword">if</span> (tail&gt;mid)  <span class="built_in">Update2</span>(mid+<span class="number">1</span>,r,rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,head,tail);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Query</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> rt,<span class="type">int</span> Max1,<span class="type">int</span> Max2)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (l==r) &#123;</span><br><span class="line">		fa[l]=l+<span class="built_in">max</span>(<span class="built_in">max</span>(Max1,f[rt].lazy),<span class="built_in">max</span>(Max2,f[rt].L));</span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	<span class="built_in">Query</span>(l,mid,rt&lt;&lt;<span class="number">1</span>,<span class="built_in">max</span>(f[rt].lazy,Max1),<span class="built_in">max</span>(f[rt].L,Max2));</span><br><span class="line">	<span class="built_in">Query</span>(mid+<span class="number">1</span>,r,rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,<span class="built_in">max</span>(f[rt].lazy,Max1),<span class="built_in">max</span>(f[rt].L+l<span class="number">-1</span>-mid,Max2+l<span class="number">-1</span>-mid));</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> Ans,deep[maxn];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;O[maxn];</span><br><span class="line"><span class="type">int</span> head=<span class="number">1</span>,to[maxn],z[maxn],h[maxn];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">	to[++head]=y;z[head]=h[x];h[x]=head;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> stac[maxn],tot;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">	stac[++tot]=x;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> y:O[x]) &#123;</span><br><span class="line">		<span class="keyword">if</span> (stac[deep[y]]&lt;y) Ans^=(deep[x]-deep[y]+<span class="number">1</span>);</span><br><span class="line">		<span class="keyword">else</span> Ans^=(deep[x]-deep[y]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i=h[x];i;i=z[i]) <span class="built_in">solve</span>(to[i]); </span><br><span class="line">	tot--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line"><span class="comment">//	freopen(&quot;2.in&quot;,&quot;r&quot;,stdin);</span></span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;cover.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;cover.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout);</span><br><span class="line">	<span class="type">int</span> l,r,x,i,j,s,y,ans;</span><br><span class="line">	pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; query_content;</span><br><span class="line">	<span class="built_in">read</span>(n);<span class="built_in">read</span>(m);<span class="built_in">read</span>(q);<span class="built_in">read</span>(s);</span><br><span class="line">	RD::<span class="built_in">init</span>(n,s);</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=m;i++) &#123;</span><br><span class="line">		<span class="built_in">read</span>(l);<span class="built_in">read</span>(r);<span class="built_in">read</span>(x);</span><br><span class="line">		<span class="keyword">if</span> (r-x&gt;=l) <span class="built_in">Update1</span>(<span class="number">1</span>,n,<span class="number">1</span>,l,r-x,x);</span><br><span class="line">		<span class="keyword">if</span> (r-x+<span class="number">1</span>&lt;=r<span class="number">-1</span>) <span class="built_in">Update2</span>(<span class="number">1</span>,n,<span class="number">1</span>,r-x+<span class="number">1</span>,r<span class="number">-1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">Query</span>(<span class="number">1</span>,n,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">for</span> (i=n;i&gt;=<span class="number">1</span>;i--) deep[i]=deep[fa[i]]+<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;n;i++) <span class="built_in">add</span>(fa[i],i);</span><br><span class="line">	<span class="keyword">while</span> (q--) &#123;</span><br><span class="line">		pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; query_content = RD::<span class="built_in">getquery</span>();</span><br><span class="line">		x = query_content.first, y = query_content.second;</span><br><span class="line">		O[x].<span class="built_in">push_back</span>(y);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">solve</span>(n);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,Ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="T4"><a href="#T4" class="headerlink" title="T4"></a>T4</h2><h3 id="Description-3"><a href="#Description-3" class="headerlink" title="Description"></a>Description</h3><p><img src="https://s2.loli.net/2023/07/07/3JOAvn9QVkSTZhb.png"></p>
<p>$n,q\le 10^5$</p>
<p>5s , 512MB</p>
<h3 id="Solution-3"><a href="#Solution-3" class="headerlink" title="Solution"></a>Solution</h3><p>考虑二分答案。检验行驶速度的最小值为 $val$ 是否可行。</p>
<p>我们只需要求出， $&lt;val$ 的初始速度的点的升级代价之和，且这些点在 $a,b$ 上。</p>
<p>先不看 $val$ ，我们只需要维护点到根的路径上的代价之和，单点修改，区间查询，并且大概率需要用到树剖，这么做是 3log 的。</p>
<p>转化为 dfs 序，只需要在修改的点对整个子树修，查询就是单点的。这样做是区间修改，单点查询。</p>
<p>$val$ 的限制用主席树即可解决。</p>
<p>$o(n\log n+q\log^2n)$</p>
<h3 id="Code-3"><a href="#Code-3" class="headerlink" title="Code"></a>Code</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 200005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> put() putchar(<span class="string">&#x27;\n&#x27;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Tp template<span class="string">&lt;typename Ty&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Ts template<span class="string">&lt;typename Ty,typename... Ar&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(<span class="type">int</span> &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> f=<span class="number">1</span>;x=<span class="number">0</span>;<span class="type">char</span> c=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (c&lt;<span class="string">&#x27;0&#x27;</span>||c&gt;<span class="string">&#x27;9&#x27;</span>) &#123;<span class="keyword">if</span> (c==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">-1</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span> (c&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;c&lt;=<span class="string">&#x27;9&#x27;</span>) &#123;x=x*<span class="number">10</span>+c-<span class="string">&#x27;0&#x27;</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> Debug&#123;</span><br><span class="line">	Tp <span class="type">void</span> _debug(<span class="type">char</span>* f,Ty t)&#123;cerr&lt;&lt;f&lt;&lt;<span class="string">&#x27;=&#x27;</span>&lt;&lt;t&lt;&lt;endl;&#125;</span><br><span class="line">	Ts <span class="type">void</span> _debug(<span class="type">char</span>* f,Ty x,Ar... y)&#123;<span class="keyword">while</span>(*f!=<span class="string">&#x27;,&#x27;</span>) cerr&lt;&lt;*f++;cerr&lt;&lt;<span class="string">&#x27;=&#x27;</span>&lt;&lt;x&lt;&lt;<span class="string">&quot;,&quot;</span>;_debug(f+<span class="number">1</span>,y...);&#125;</span><br><span class="line">	Tp ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; os,vector&lt;Ty&gt;&amp; V)&#123;os&lt;&lt;<span class="string">&quot;[&quot;</span>;<span class="keyword">for</span>(<span class="keyword">auto</span>&amp; vv:V) os&lt;&lt;vv&lt;&lt;<span class="string">&quot;,&quot;</span>;os&lt;&lt;<span class="string">&quot;]&quot;</span>;<span class="keyword">return</span> os;&#125;</span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> gdb(...) _debug((char*)#__VA_ARGS__,__VA_ARGS__)</span></span><br><span class="line">&#125;<span class="keyword">using</span> <span class="keyword">namespace</span> Debug;</span><br><span class="line"><span class="type">int</span> n,q;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ed</span>&#123;</span><br><span class="line">	<span class="type">int</span> x,y,v,c,s;</span><br><span class="line">&#125;e[maxn],w[maxn];</span><br><span class="line">vector&lt;ed&gt;O[maxn];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;to[maxn];</span><br><span class="line"><span class="type">int</span> dfn[maxn],top[maxn],fa[maxn],id[maxn],idnum,deep[maxn],siz[maxn],son[maxn];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> pre)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> i;siz[x]=<span class="number">1</span>,deep[x]=deep[pre]+<span class="number">1</span>,fa[x]=pre;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> y:to[x]) <span class="keyword">if</span> (y^pre) &#123;</span><br><span class="line">		<span class="built_in">dfs1</span>(y,x);</span><br><span class="line">		siz[x]+=siz[y];</span><br><span class="line">		<span class="keyword">if</span> (!son[x]||siz[son[x]]&lt;siz[y]) son[x]=y;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf=<span class="number">1e9</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> pre,<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line">	top[x]=u;id[x]+=++idnum;</span><br><span class="line">	<span class="keyword">if</span> (!son[x]) <span class="keyword">return</span> ;</span><br><span class="line">	<span class="built_in">dfs2</span>(son[x],x,u);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> y:to[x]) <span class="keyword">if</span> (y!=pre&amp;&amp;y!=son[x]) <span class="built_in">dfs2</span>(y,x,y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">cmp</span><span class="params">(ed x,ed y)</span> </span>&#123;<span class="keyword">return</span> x.s&lt;y.s;&#125;</span><br><span class="line"><span class="type">int</span> g[maxn],tot,cnt;</span><br><span class="line"><span class="type">int</span> root[maxn];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">	<span class="type">int</span> ls,rs,sum;</span><br><span class="line">&#125;f[maxn*<span class="number">40</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">Update</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> pre,<span class="type">int</span> head,<span class="type">int</span> c)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> rt=++cnt;f[rt]=f[pre];f[rt].sum+=c;</span><br><span class="line">	<span class="keyword">if</span> (l==r) <span class="keyword">return</span> rt;</span><br><span class="line">	<span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span> (head&lt;=mid) f[rt].ls=<span class="built_in">Update</span>(l,mid,f[rt].ls,head,c);</span><br><span class="line">	<span class="keyword">else</span> f[rt].rs=<span class="built_in">Update</span>(mid+<span class="number">1</span>,r,f[rt].rs,head,c);</span><br><span class="line">	<span class="keyword">return</span> rt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">Query</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> rt,<span class="type">int</span> head,<span class="type">int</span> tail)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!rt) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (head&lt;=l&amp;&amp;r&lt;=tail) <span class="keyword">return</span> f[rt].sum;</span><br><span class="line">	<span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>,tmp1=<span class="number">0</span>,tmp2=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (head&lt;=mid) tmp1=<span class="built_in">Query</span>(l,mid,f[rt].ls,head,tail);</span><br><span class="line">	<span class="keyword">if</span> (tail&gt;mid)  tmp2=<span class="built_in">Query</span>(mid+<span class="number">1</span>,r,f[rt].rs,head,tail);</span><br><span class="line">	<span class="keyword">return</span> tmp1+tmp2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> lca;</span><br><span class="line"><span class="keyword">namespace</span> seg&#123;</span><br><span class="line">	<span class="type">int</span> f[maxn&lt;&lt;<span class="number">2</span>];</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">		<span class="built_in">memset</span>(f,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(f));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Update</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> rt,<span class="type">int</span> head,<span class="type">int</span> w)</span> </span>&#123;</span><br><span class="line">		f[rt]=<span class="built_in">min</span>(f[rt],w);</span><br><span class="line">		<span class="keyword">if</span> (l==r) <span class="keyword">return</span> f[rt]=w,<span class="built_in">void</span>();</span><br><span class="line">		<span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span> (head&lt;=mid) <span class="built_in">Update</span>(l,mid,rt&lt;&lt;<span class="number">1</span>,head,w);</span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">Update</span>(mid+<span class="number">1</span>,r,rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,head,w);</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">Query</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> rt,<span class="type">int</span> head,<span class="type">int</span> tail)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (head&lt;=l&amp;&amp;r&lt;=tail) <span class="keyword">return</span> f[rt];</span><br><span class="line">		<span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>,tmp1=inf,tmp2=inf;</span><br><span class="line">		<span class="keyword">if</span> (head&lt;=mid) tmp1=<span class="built_in">Query</span>(l,mid,rt&lt;&lt;<span class="number">1</span>,head,tail);</span><br><span class="line">		<span class="keyword">if</span> (tail&gt;mid)  tmp2=<span class="built_in">Query</span>(mid+<span class="number">1</span>,r,rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,head,tail);</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">min</span>(tmp1,tmp2);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">		<span class="type">int</span> ans=inf;</span><br><span class="line">		<span class="keyword">while</span> (top[x]^top[y]) &#123;</span><br><span class="line">			<span class="keyword">if</span> (deep[top[x]]&lt;deep[top[y]]) <span class="built_in">swap</span>(x,y);</span><br><span class="line">			<span class="type">int</span> tmp=<span class="built_in">Query</span>(<span class="number">1ll</span>,n,<span class="number">1ll</span>,id[top[x]],id[x]);ans=<span class="built_in">min</span>(ans,tmp);</span><br><span class="line">			x=fa[top[x]];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (deep[x]&lt;deep[y]) <span class="built_in">swap</span>(x,y);</span><br><span class="line">		<span class="keyword">if</span> (x^y) &#123;</span><br><span class="line">			ans=<span class="built_in">min</span>(ans,<span class="built_in">Query</span>(<span class="number">1ll</span>,n,<span class="number">1ll</span>,id[y]+<span class="number">1</span>,id[x]));</span><br><span class="line">		&#125;</span><br><span class="line">		lca=y;</span><br><span class="line">		<span class="keyword">return</span> ans;</span><br><span class="line">	&#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> val,<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> z)</span> </span>&#123;</span><br><span class="line">	val--;</span><br><span class="line">	<span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">	ans=<span class="built_in">Query</span>(<span class="number">1</span>,n,root[val],<span class="number">1</span>,id[x])+<span class="built_in">Query</span>(<span class="number">1</span>,n,root[val],<span class="number">1</span>,id[y])-<span class="built_in">Query</span>(<span class="number">1</span>,n,root[val],<span class="number">1</span>,id[lca])*<span class="number">2</span>;</span><br><span class="line">	<span class="keyword">return</span> ans&lt;=z;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">  	<span class="built_in">freopen</span>(<span class="string">&quot;arozustan.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;arozustan.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout);</span><br><span class="line">	<span class="type">int</span> i,x,y,z;</span><br><span class="line">	<span class="built_in">read</span>(n);</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;n;i++) &#123;</span><br><span class="line">		<span class="built_in">read</span>(e[i].x),<span class="built_in">read</span>(e[i].y),<span class="built_in">read</span>(e[i].v),<span class="built_in">read</span>(e[i].c),<span class="built_in">read</span>(e[i].s);</span><br><span class="line">		g[++tot]=e[i].v,g[++tot]=e[i].s;</span><br><span class="line">		to[e[i].x].<span class="built_in">push_back</span>(e[i].y);</span><br><span class="line">		to[e[i].y].<span class="built_in">push_back</span>(e[i].x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">sort</span>(g+<span class="number">1</span>,g+<span class="number">1</span>+tot);</span><br><span class="line">	tot=<span class="built_in">unique</span>(g+<span class="number">1</span>,g+<span class="number">1</span>+tot)-g<span class="number">-1</span>;</span><br><span class="line">	seg::<span class="built_in">init</span>();</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;n;i++) e[i].v=<span class="built_in">lower_bound</span>(g+<span class="number">1</span>,g+<span class="number">1</span>+tot,e[i].v)-g,e[i].s=<span class="built_in">lower_bound</span>(g+<span class="number">1</span>,g+<span class="number">1</span>+tot,e[i].s)-g;<span class="comment">//,gdb(i,e[i].x,e[i].y,e[i].v,e[i].s);</span></span><br><span class="line">	<span class="built_in">dfs1</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">dfs2</span>(<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;n;i++) <span class="keyword">if</span> (deep[e[i].x]&lt;deep[e[i].y]) w[e[i].y]=e[i];<span class="keyword">else</span> w[e[i].x]=e[i];</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) <span class="keyword">if</span> (w[i].x) &#123;</span><br><span class="line">		w[i].x=i,O[w[i].v].<span class="built_in">push_back</span>(w[i]);</span><br><span class="line">		seg::<span class="built_in">Update</span>(<span class="number">1</span>,n,<span class="number">1</span>,id[w[i].x],w[i].s);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=tot;i++) &#123;</span><br><span class="line">		root[i]=root[i<span class="number">-1</span>];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> tmp:O[i]) &#123;</span><br><span class="line">			root[i]=<span class="built_in">Update</span>(<span class="number">1</span>,n,root[i],id[tmp.x],tmp.c);</span><br><span class="line">			<span class="keyword">if</span> (id[tmp.x]+siz[tmp.x]&lt;=n) root[i]=<span class="built_in">Update</span>(<span class="number">1</span>,n,root[i],id[tmp.x]+siz[tmp.x],-tmp.c);</span><br><span class="line"> 		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">read</span>(q);</span><br><span class="line">	<span class="keyword">while</span> (q--) &#123;</span><br><span class="line">		<span class="built_in">read</span>(x),<span class="built_in">read</span>(y),<span class="built_in">read</span>(z);</span><br><span class="line">		<span class="type">int</span> l=<span class="number">0</span>,r=seg::<span class="built_in">query</span>(x,y)+<span class="number">1</span>,mid;</span><br><span class="line">		<span class="keyword">while</span> (l+<span class="number">1</span>&lt;r) &#123;</span><br><span class="line">			mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">			<span class="keyword">if</span> (<span class="built_in">check</span>(mid,x,y,z)) l=mid;</span><br><span class="line">			<span class="keyword">else</span> r=mid;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,g[l]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>倍增</tag>
        <tag>NOIP 模拟赛</tag>
        <tag>期望</tag>
        <tag>平面图</tag>
      </tags>
  </entry>
  <entry>
    <title>7.5 模拟赛</title>
    <url>/2023/07/07/7-5-%E6%A8%A1%E6%8B%9F%E8%B5%9B/</url>
    <content><![CDATA[<h1 id="Day-2"><a href="#Day-2" class="headerlink" title="Day 2"></a>Day 2</h1><h2 id="T1-script"><a href="#T1-script" class="headerlink" title="T1. script"></a>T1. script</h2><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p><img src="https://s2.loli.net/2023/07/07/dGfKLBCMIUgwDcs.png"></p>
<p>$n\le 10^5$</p>
<p>1s , 512MB</p>
<h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><p>考虑递归解决。比较简单，不细讲了。</p>
<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 200005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> put() putchar(<span class="string">&#x27;\n&#x27;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Tp template<span class="string">&lt;typename Ty&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Ts template<span class="string">&lt;typename Ty,typename... Ar&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(<span class="type">int</span> &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> f=<span class="number">1</span>;x=<span class="number">0</span>;<span class="type">char</span> c=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (c&lt;<span class="string">&#x27;0&#x27;</span>||c&gt;<span class="string">&#x27;9&#x27;</span>) &#123;<span class="keyword">if</span> (c==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">-1</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span> (c&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;c&lt;=<span class="string">&#x27;9&#x27;</span>) &#123;x=x*<span class="number">10</span>+c-<span class="string">&#x27;0&#x27;</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> Debug&#123;</span><br><span class="line">	Tp <span class="type">void</span> _debug(<span class="type">char</span>* f,Ty t)&#123;cerr&lt;&lt;f&lt;&lt;<span class="string">&#x27;=&#x27;</span>&lt;&lt;t&lt;&lt;endl;&#125;</span><br><span class="line">	Ts <span class="type">void</span> _debug(<span class="type">char</span>* f,Ty x,Ar... y)&#123;<span class="keyword">while</span>(*f!=<span class="string">&#x27;,&#x27;</span>) cerr&lt;&lt;*f++;cerr&lt;&lt;<span class="string">&#x27;=&#x27;</span>&lt;&lt;x&lt;&lt;<span class="string">&quot;,&quot;</span>;_debug(f+<span class="number">1</span>,y...);&#125;</span><br><span class="line">	Tp ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; os,vector&lt;Ty&gt;&amp; V)&#123;os&lt;&lt;<span class="string">&quot;[&quot;</span>;<span class="keyword">for</span>(<span class="keyword">auto</span>&amp; vv:V) os&lt;&lt;vv&lt;&lt;<span class="string">&quot;,&quot;</span>;os&lt;&lt;<span class="string">&quot;]&quot;</span>;<span class="keyword">return</span> os;&#125;</span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> gdb(...) _debug((char*)#__VA_ARGS__,__VA_ARGS__)</span></span><br><span class="line">&#125;<span class="keyword">using</span> <span class="keyword">namespace</span> Debug;</span><br><span class="line"><span class="type">int</span> fa[maxn],n,las[maxn];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;to[maxn];</span><br><span class="line"><span class="type">int</span> ans=<span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (to[x].<span class="built_in">size</span>()==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="type">int</span> max=<span class="number">0</span>,nums=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> y:to[x]) &#123;</span><br><span class="line">		<span class="type">int</span> tmp=<span class="built_in">dfs</span>(y);</span><br><span class="line">		<span class="keyword">if</span> (tmp&gt;max) max=tmp,nums=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (tmp==max) nums++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> max+(nums&gt;<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">solve</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> i;ans=<span class="number">1</span>;</span><br><span class="line">	<span class="built_in">read</span>(n);</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) to[i].<span class="built_in">clear</span>();</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">read</span>(fa[i]),to[fa[i]].<span class="built_in">push_back</span>(i);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">dfs</span>(<span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line"> 	<span class="built_in">freopen</span>(<span class="string">&quot;script.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;script.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout);</span><br><span class="line">	<span class="type">int</span> T;</span><br><span class="line">	<span class="built_in">read</span>(T);</span><br><span class="line">	<span class="keyword">while</span> (T--) <span class="built_in">solve</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="T2-deletion"><a href="#T2-deletion" class="headerlink" title="T2. deletion"></a>T2. deletion</h2><h3 id="Description-1"><a href="#Description-1" class="headerlink" title="Description"></a>Description</h3><p>Natsuzora 有一个长度为 $n$ 的排列 $a$。他想要将序列中的 $m$ 个数删除。</p>
<p>魔法工具也有 $m$ 种，其中，第 $i$ 种魔法工具能够将排列中任意一个的长度为 $l_i$ 的区间中最大的数删除。每个魔法工具最多只能使用 $1$ 次。</p>
<p>每次删除操作后，序列的长度将减少 $1$，且删去的数的右边所有数的下标减少 $1$。</p>
<p>$n\le 2\times 10^5$</p>
<p>1s , 512MB</p>
<h3 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution"></a>Solution</h3><p>$l_i$ 更大的要越先用掉。如果一个数包含另外一个数，则这个数比另外一个数更先用掉。</p>
<p>两个单调栈维护一下即可。</p>
<p>我写的是 $n^2$ 暴力过去了，就不贴了。</p>
<h2 id="T3-candy"><a href="#T3-candy" class="headerlink" title="T3. candy"></a>T3. candy</h2><h3 id="Description-2"><a href="#Description-2" class="headerlink" title="Description"></a>Description</h3><p>P8746 [蓝桥杯 2021 省 A] 分果果</p>
<h3 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution"></a>Solution</h3><p>外面枚举最小值 $minn$ ，考虑求最大值。</p>
<p>一个显然的性质是任意两个人取糖果的区间不包含。考虑两个区间 $l1&lt;l2&lt;r2&lt;r1$，如果换为 $[l1,r2],[l2,r1]$ 这样的极差显然更小。</p>
<p>令 $f[i][j][k]$ 表示，第 $i$ 个区间，上一个取一颗糖果的位置为 $j$ ，上一个取两颗糖果的位置为 $k$。$j\ge k$。最大值最小为 $f[i][j][k]$。</p>
<ul>
<li>两颗糖果的位置不取，$f[i][j][k]\Leftarrow f[i][j][l-1]$  ，这也说明 $f[i][j][k]$ 关于 $k$ 单调递减。</li>
<li>在 $t\le k$ 取，$f[i][j][k]\Leftarrow \max(f[i-1][k][t],s[j]-s[t])$ 把 $\max$ 中的两项当作两个关于 $t$ 的函数，可以发现两者都关于 $t$ 递减。所以取 $t$ 最大的即可。<strong>但是注意要满足 $s[j]-s[t]\ge minn$</strong></li>
<li>在 $k+1\le t\le j$ 之间取。这在<strong>之后</strong>会在第二种情况算到，所以可以<strong>不需要转移</strong>。因为转移两次的一定小于等于转移一次。如果转移两次的继续取，等到大于转移一次的位置，转移一次的位置就成了转移两次的。</li>
</ul>
<p>这样只需要一个指针维护即可。$dp$ 的复杂度为 $n^2\times m$</p>
<p>外面枚举的<strong>最小值</strong>复杂度是 $O(\dfrac{sum}{m})$ ，具体的，枚举的上界是 $\dfrac{2nw}{m}$</p>
<p>总的复杂度就是 $O(n^3w)$</p>
<h3 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> m,n,w[<span class="number">105</span>],base;</span><br><span class="line"><span class="type">int</span> f[<span class="number">55</span>][<span class="number">105</span>][<span class="number">105</span>];</span><br><span class="line"><span class="type">int</span> stac[<span class="number">106</span>],tot,ans=<span class="number">1e9</span>; </span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> minn)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> i,j,k,pp,p;</span><br><span class="line">	<span class="built_in">memset</span>(f,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(f));</span><br><span class="line">	f[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>]=minn;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=m;i++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (k=<span class="number">0</span>;k&lt;=n;k++) &#123;</span><br><span class="line">			p=tot=<span class="number">0</span>;</span><br><span class="line">			<span class="keyword">for</span> (j=k;j&lt;=n;j++) &#123;</span><br><span class="line">				<span class="keyword">if</span> (k&gt;<span class="number">0</span>) f[i][j][k]=<span class="built_in">min</span>(f[i][j][k],f[i][j][k<span class="number">-1</span>]);</span><br><span class="line">				<span class="keyword">while</span> (w[j]-w[p]&gt;=minn) p++;</span><br><span class="line">				<span class="keyword">if</span> ((pp=<span class="built_in">min</span>(p<span class="number">-1</span>,k))&gt;=<span class="number">0</span>) f[i][j][k]=<span class="built_in">min</span>(f[i][j][k],<span class="built_in">max</span>(f[i<span class="number">-1</span>][k][pp],w[j]-w[pp]));</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	ans=<span class="built_in">min</span>(ans,f[m][n][n]-minn);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">  	<span class="built_in">freopen</span>(<span class="string">&quot;candy.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">  	<span class="built_in">freopen</span>(<span class="string">&quot;candy.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout);</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) cin&gt;&gt;w[i],w[i]+=w[i<span class="number">-1</span>];</span><br><span class="line">	base=w[n]*<span class="number">2</span>/m;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=base;i++) <span class="built_in">solve</span>(i);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="T4-twotypes"><a href="#T4-twotypes" class="headerlink" title="T4. twotypes"></a>T4. twotypes</h2><h3 id="Description-3"><a href="#Description-3" class="headerlink" title="Description"></a>Description</h3><p>给你一张 $n$ 个点、$m$ 条边的有向无环图，图中的每条边有黑和白两种颜色。保证从 $1$ 号点出发可以到达任意一点。<br>共有 $q$ 次询问，在第 $i$ 次询问中，给定 $a_i$、$b_i$ 和 $x_i$，表示设黑边边权为 $a_i$，白边边权为 $b_i$，在这种条件下，请你求出从 $1$ 到 $x_i$ 的最短路径。</p>
<p>$n,q\le 5\times 10^4,m\le 1\times 10^5$</p>
<p>1s , 1024MB</p>
<h3 id="Solution-3"><a href="#Solution-3" class="headerlink" title="Solution"></a>Solution</h3><p>考虑一个点对答案<strong>可能</strong>有贡献的路径，用黑边条数和白边条数 $(x,y)$ 。目标 $\min Ax+By$，令 $Ax+By&#x3D;k$，化为 $y&#x3D;-\dfrac{A}{B}x+\dfrac{k}{B}$ 。根据几何意义，即在原图中的下 $\dfrac{1}{4}$ 的凸包上。可以证明，<strong>值域在 $n$</strong> 的点构成的凸包的最大点数为 $O(n^{2&#x2F;3})$ 级别的。实际上这个上界很松。</p>
<p>具体维护凸包。每次凸包合并。由于这个图是 DAG，合并的次数最多只有 $m$ 次。</p>
<p>查询的时候没必要二分。直接扫过去。</p>
<p>总复杂度 $O((m+q)n^{2&#x2F;3})$</p>
<h3 id="Code-2"><a href="#Code-2" class="headerlink" title="Code"></a>Code</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 50005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> put() putchar(<span class="string">&#x27;\n&#x27;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Tp template<span class="string">&lt;typename Ty&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Ts template<span class="string">&lt;typename Ty,typename... Ar&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(<span class="type">int</span> &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> f=<span class="number">1</span>;x=<span class="number">0</span>;<span class="type">char</span> c=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (c&lt;<span class="string">&#x27;0&#x27;</span>||c&gt;<span class="string">&#x27;9&#x27;</span>) &#123;<span class="keyword">if</span> (c==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">-1</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span> (c&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;c&lt;=<span class="string">&#x27;9&#x27;</span>) &#123;x=x*<span class="number">10</span>+c-<span class="string">&#x27;0&#x27;</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> Debug&#123;</span><br><span class="line">	Tp <span class="type">void</span> _debug(<span class="type">char</span>* f,Ty t)&#123;cerr&lt;&lt;f&lt;&lt;<span class="string">&#x27;=&#x27;</span>&lt;&lt;t&lt;&lt;endl;&#125;</span><br><span class="line">	Ts <span class="type">void</span> _debug(<span class="type">char</span>* f,Ty x,Ar... y)&#123;<span class="keyword">while</span>(*f!=<span class="string">&#x27;,&#x27;</span>) cerr&lt;&lt;*f++;cerr&lt;&lt;<span class="string">&#x27;=&#x27;</span>&lt;&lt;x&lt;&lt;<span class="string">&quot;,&quot;</span>;_debug(f+<span class="number">1</span>,y...);&#125;</span><br><span class="line">	Tp ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; os,vector&lt;Ty&gt;&amp; V)&#123;os&lt;&lt;<span class="string">&quot;[&quot;</span>;<span class="keyword">for</span>(<span class="keyword">auto</span>&amp; vv:V) os&lt;&lt;vv&lt;&lt;<span class="string">&quot;,&quot;</span>;os&lt;&lt;<span class="string">&quot;]&quot;</span>;<span class="keyword">return</span> os;&#125;</span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> gdb(...) _debug((char*)#__VA_ARGS__,__VA_ARGS__)</span></span><br><span class="line">&#125;<span class="keyword">using</span> <span class="keyword">namespace</span> Debug;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">	<span class="type">int</span> x,y;</span><br><span class="line">	<span class="built_in">node</span>(<span class="type">int</span> a=<span class="number">0</span>,<span class="type">int</span> b=<span class="number">0</span>) &#123;x=a;y=b;&#125;</span><br><span class="line">	node <span class="keyword">operator</span> +(<span class="type">const</span> <span class="type">int</span> &amp;z) <span class="type">const</span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (z==<span class="number">0</span>) <span class="keyword">return</span> <span class="built_in">node</span>(x+<span class="number">1</span>,y);</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">node</span>(x,y+<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;node&gt;g[maxn];</span><br><span class="line">node O[maxn];</span><br><span class="line"><span class="type">int</span> head=<span class="number">1</span>,h[maxn],n,m;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">yyy</span>&#123;</span><br><span class="line">	<span class="type">int</span> to,z,w;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">		to=y,z=h[x],h[x]=head;w=val;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;a[maxn*<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> in[maxn];</span><br><span class="line">queue&lt;<span class="type">int</span>&gt;q;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">double</span> <span class="title">slope</span><span class="params">(node x,node y)</span> </span>&#123;<span class="keyword">return</span> <span class="number">1.0</span>*(y.y-x.y)/(y.x-x.x);&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> y,<span class="type">int</span> x,<span class="type">int</span> z)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> i,tot=<span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> l1=g[x].<span class="built_in">size</span>(),l2=g[y].<span class="built_in">size</span>(),cnt1=<span class="number">0</span>,cnt2=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (cnt1&lt;l1&amp;&amp;cnt2&lt;l2) &#123;</span><br><span class="line">		node tmp1=g[x][cnt1]+z,tmp2=g[y][cnt2];</span><br><span class="line">		<span class="keyword">if</span> (tmp1.x==tmp2.x) &#123;</span><br><span class="line">			<span class="keyword">if</span> (tmp1.y&lt;tmp2.y) cnt2++;</span><br><span class="line">			<span class="keyword">else</span> cnt1++;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (tmp1.x&lt;tmp2.x) &#123;</span><br><span class="line">			<span class="keyword">while</span> (tot&gt;=<span class="number">2</span>&amp;&amp;(<span class="built_in">slope</span>(O[tot<span class="number">-1</span>],O[tot])&gt;=<span class="built_in">slope</span>(O[tot],tmp1))) tot--;</span><br><span class="line">			O[++tot]=tmp1;cnt1++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">while</span> (tot&gt;=<span class="number">2</span>&amp;&amp;(<span class="built_in">slope</span>(O[tot<span class="number">-1</span>],O[tot])&gt;=<span class="built_in">slope</span>(O[tot],tmp2))) tot--;</span><br><span class="line">			O[++tot]=tmp2;cnt2++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (cnt1&lt;l1) &#123;</span><br><span class="line">		node tmp1=g[x][cnt1]+z;</span><br><span class="line">		<span class="keyword">while</span> (tot&gt;=<span class="number">2</span>&amp;&amp;(<span class="built_in">slope</span>(O[tot<span class="number">-1</span>],O[tot])&gt;=<span class="built_in">slope</span>(O[tot],tmp1))) tot--;</span><br><span class="line">		O[++tot]=tmp1;cnt1++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (cnt2&lt;l2) &#123;</span><br><span class="line">		node tmp2=g[y][cnt2];</span><br><span class="line">		<span class="keyword">while</span> (tot&gt;=<span class="number">2</span>&amp;&amp;(<span class="built_in">slope</span>(O[tot<span class="number">-1</span>],O[tot])&gt;=<span class="built_in">slope</span>(O[tot],tmp2))) tot--;</span><br><span class="line">		O[++tot]=tmp2;cnt2++;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">//	vector&lt;node&gt;().swap(g[y]); </span></span><br><span class="line">	g[y].<span class="built_in">clear</span>(); </span><br><span class="line"><span class="comment">//	assert(tot&lt;=2000);</span></span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=tot;i++) g[y].<span class="built_in">push_back</span>(O[i]); </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">topo</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> i,x;</span><br><span class="line">	q.<span class="built_in">push</span>(<span class="number">1</span>);g[<span class="number">1</span>].<span class="built_in">push_back</span>(<span class="built_in">node</span>(<span class="number">0</span>,<span class="number">0</span>)); </span><br><span class="line">	<span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">		x=q.<span class="built_in">front</span>();q.<span class="built_in">pop</span>();</span><br><span class="line">		<span class="keyword">for</span> (i=h[x];i;i=a[i].z) &#123;</span><br><span class="line">			<span class="built_in">merge</span>(a[i].to,x,a[i].w);</span><br><span class="line">			<span class="keyword">if</span> (!--in[a[i].to]) q.<span class="built_in">push</span>(a[i].to);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line"><span class="comment">//  freopen(&quot;2.in&quot;,&quot;r&quot;,stdin);</span></span><br><span class="line">  	<span class="built_in">freopen</span>(<span class="string">&quot;twotypes.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">  	<span class="built_in">freopen</span>(<span class="string">&quot;twotypes.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout);</span><br><span class="line">	<span class="type">int</span> i,x,y,z;</span><br><span class="line">	<span class="built_in">read</span>(n);<span class="built_in">read</span>(m);</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=m;i++) &#123;</span><br><span class="line">		<span class="built_in">read</span>(x),<span class="built_in">read</span>(y),<span class="built_in">read</span>(z);</span><br><span class="line">		++in[y];a[++head].<span class="built_in">add</span>(x,y,z);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">topo</span>();</span><br><span class="line">	<span class="type">int</span> tmp1,tmp2,q;</span><br><span class="line">	<span class="built_in">read</span>(q); </span><br><span class="line">	<span class="keyword">while</span> (q--) &#123;</span><br><span class="line">		<span class="built_in">read</span>(tmp1),<span class="built_in">read</span>(tmp2),<span class="built_in">read</span>(x);</span><br><span class="line">		<span class="type">int</span> ans=<span class="number">1e9</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> tmp:g[x]) ans=<span class="built_in">min</span>(ans,tmp1*tmp.x+tmp2*tmp.y);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>NOIP模拟赛</tag>
        <tag>dp</tag>
        <tag>凸包</tag>
      </tags>
  </entry>
  <entry>
    <title>7.17 模拟赛</title>
    <url>/2023/07/17/7-17-%E6%A8%A1%E6%8B%9F%E8%B5%9B/</url>
    <content><![CDATA[<h1 id="7-17-模拟赛"><a href="#7-17-模拟赛" class="headerlink" title="7.17 模拟赛"></a>7.17 模拟赛</h1><h2 id="T1-Tree"><a href="#T1-Tree" class="headerlink" title="T1. Tree"></a>T1. Tree</h2><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>给你一棵 $n$ 个节点的树, 每次询问包含第 $i$ 条边的树上最长路径长度。</p>
<p>$n\le 10^6$ </p>
<p>1s 512MB</p>
<h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><p>对于每个点，求从自己出发子树内的最长路径和子树外的最长路径。就是这个点和这个点父亲相连的边最长路径。</p>
<p>换根 dp。复杂度 $O(n)$。</p>
<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 1000005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> put() putchar(<span class="string">&#x27;\n&#x27;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Tp template<span class="string">&lt;typename Ty&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Ts template<span class="string">&lt;typename Ty,typename... Ar&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(<span class="type">int</span> &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> f=<span class="number">1</span>;x=<span class="number">0</span>;<span class="type">char</span> c=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (c&lt;<span class="string">&#x27;0&#x27;</span>||c&gt;<span class="string">&#x27;9&#x27;</span>) &#123;<span class="keyword">if</span> (c==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">-1</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span> (c&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;c&lt;=<span class="string">&#x27;9&#x27;</span>) &#123;x=x*<span class="number">10</span>+c-<span class="string">&#x27;0&#x27;</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> Debug&#123;</span><br><span class="line">	Tp <span class="type">void</span> _debug(<span class="type">char</span>* f,Ty t)&#123;cerr&lt;&lt;f&lt;&lt;<span class="string">&#x27;=&#x27;</span>&lt;&lt;t&lt;&lt;endl;&#125;</span><br><span class="line">	Ts <span class="type">void</span> _debug(<span class="type">char</span>* f,Ty x,Ar... y)&#123;<span class="keyword">while</span>(*f!=<span class="string">&#x27;,&#x27;</span>) cerr&lt;&lt;*f++;cerr&lt;&lt;<span class="string">&#x27;=&#x27;</span>&lt;&lt;x&lt;&lt;<span class="string">&quot;,&quot;</span>;_debug(f+<span class="number">1</span>,y...);&#125;</span><br><span class="line">	Tp ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; os,vector&lt;Ty&gt;&amp; V)&#123;os&lt;&lt;<span class="string">&quot;[&quot;</span>;<span class="keyword">for</span>(<span class="keyword">auto</span>&amp; vv:V) os&lt;&lt;vv&lt;&lt;<span class="string">&quot;,&quot;</span>;os&lt;&lt;<span class="string">&quot;]&quot;</span>;<span class="keyword">return</span> os;&#125;</span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> gdb(...) _debug((char*)#__VA_ARGS__,__VA_ARGS__)</span></span><br><span class="line">&#125;<span class="keyword">using</span> <span class="keyword">namespace</span> Debug;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ed</span>&#123;</span><br><span class="line">	<span class="type">int</span> x,y;</span><br><span class="line">&#125;e[maxn];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;to[maxn];</span><br><span class="line"><span class="type">int</span> f[maxn],g[maxn],ff[maxn];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> pre)</span> </span>&#123;</span><br><span class="line">	f[x]=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> y:to[x]) <span class="keyword">if</span> (y^pre) &#123;</span><br><span class="line">		<span class="built_in">dfs1</span>(y,x);</span><br><span class="line">		<span class="keyword">if</span> (f[x]&lt;=f[y]+<span class="number">1</span>) ff[x]=f[x],f[x]=f[y]+<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (ff[x]&lt;f[y]+<span class="number">1</span>) ff[x]=f[y]+<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> pre)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> y:to[x]) <span class="keyword">if</span> (y^pre) &#123;</span><br><span class="line">		<span class="keyword">if</span> (f[y]==f[x]<span class="number">-1</span>) g[y]=<span class="built_in">max</span>(g[x]+<span class="number">1</span>,ff[x]+<span class="number">1</span>);</span><br><span class="line">		<span class="keyword">else</span> g[y]=<span class="built_in">max</span>(g[x]+<span class="number">1</span>,f[x]+<span class="number">1</span>);</span><br><span class="line">		<span class="built_in">dfs2</span>(y,x);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">  	<span class="built_in">freopen</span>(<span class="string">&quot;tree.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;tree.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout);</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="built_in">read</span>(n);</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;n;i++) <span class="built_in">read</span>(e[i].x),<span class="built_in">read</span>(e[i].y),to[e[i].x].<span class="built_in">push_back</span>(e[i].y),to[e[i].y].<span class="built_in">push_back</span>(e[i].x);</span><br><span class="line">	<span class="built_in">dfs1</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">	g[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">dfs2</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;n;i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (f[e[i].x]&gt;f[e[i].y]) <span class="built_in">swap</span>(e[i].x,e[i].y);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,f[e[i].x]+g[e[i].x]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="T2-path"><a href="#T2-path" class="headerlink" title="T2. path"></a>T2. path</h2><h3 id="Description-1"><a href="#Description-1" class="headerlink" title="Description"></a>Description</h3><p>给出一个 $n$ 个点，$m$ 条边的无向图。接下来 $Q$ 次询问，每次从图中删掉一个点 $A$ 后，请问此时点 $B$ 到点 $C$ 的最短路长度。每次询问独立。</p>
<p>$n\le 200,m\le n^2,q\le 10^5$</p>
<p>0.3s 512MB</p>
<h3 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution"></a>Solution</h3><p>首先，Floyd 最外层的 $k$ 只需要是 $n$ 的排列即可。Floyd 加入一个点的复杂度是 $O(n^2)$ 的。</p>
<p>考虑分治（类似于线段树分治）。复杂度 $O(n^3\log n)$ ，每层记录一个数组，空间复杂度 $O(n^2\log n)$</p>
<h3 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 205</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> put() putchar(<span class="string">&#x27;\n&#x27;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Tp template<span class="string">&lt;typename Ty&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Ts template<span class="string">&lt;typename Ty,typename... Ar&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(<span class="type">int</span> &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> f=<span class="number">1</span>;x=<span class="number">0</span>;<span class="type">char</span> c=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (c&lt;<span class="string">&#x27;0&#x27;</span>||c&gt;<span class="string">&#x27;9&#x27;</span>) &#123;<span class="keyword">if</span> (c==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">-1</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span> (c&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;c&lt;=<span class="string">&#x27;9&#x27;</span>) &#123;x=x*<span class="number">10</span>+c-<span class="string">&#x27;0&#x27;</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> Debug&#123;</span><br><span class="line">	Tp <span class="type">void</span> _debug(<span class="type">char</span>* f,Ty t)&#123;cerr&lt;&lt;f&lt;&lt;<span class="string">&#x27;=&#x27;</span>&lt;&lt;t&lt;&lt;endl;&#125;</span><br><span class="line">	Ts <span class="type">void</span> _debug(<span class="type">char</span>* f,Ty x,Ar... y)&#123;<span class="keyword">while</span>(*f!=<span class="string">&#x27;,&#x27;</span>) cerr&lt;&lt;*f++;cerr&lt;&lt;<span class="string">&#x27;=&#x27;</span>&lt;&lt;x&lt;&lt;<span class="string">&quot;,&quot;</span>;_debug(f+<span class="number">1</span>,y...);&#125;</span><br><span class="line">	Tp ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; os,vector&lt;Ty&gt;&amp; V)&#123;os&lt;&lt;<span class="string">&quot;[&quot;</span>;<span class="keyword">for</span>(<span class="keyword">auto</span>&amp; vv:V) os&lt;&lt;vv&lt;&lt;<span class="string">&quot;,&quot;</span>;os&lt;&lt;<span class="string">&quot;]&quot;</span>;<span class="keyword">return</span> os;&#125;</span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> gdb(...) _debug((char*)#__VA_ARGS__,__VA_ARGS__)</span></span><br><span class="line">&#125;<span class="keyword">using</span> <span class="keyword">namespace</span> Debug;</span><br><span class="line"><span class="type">int</span> a[maxn][maxn],n,m,q;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">	<span class="type">int</span> id,x,y;</span><br><span class="line">	<span class="built_in">node</span>(<span class="type">int</span> a=<span class="number">0</span>,<span class="type">int</span> b=<span class="number">0</span>,<span class="type">int</span> c=<span class="number">0</span>) &#123;id=a;x=b;y=c;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;node&gt;O[maxn];</span><br><span class="line"><span class="type">int</span> f[<span class="number">19</span>][maxn][maxn],Ans[<span class="number">100005</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> L,<span class="type">int</span> R,<span class="type">int</span> deep)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> mid=L+R&gt;&gt;<span class="number">1</span>,i,j,k;</span><br><span class="line">	<span class="keyword">if</span> (L==R) &#123;</span><br><span class="line"> 		<span class="built_in">memcpy</span>(f[deep],f[deep<span class="number">-1</span>],<span class="built_in">sizeof</span>(f[deep]));</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> tmp:O[L]) &#123;</span><br><span class="line">			Ans[tmp.id]=f[deep][tmp.x][tmp.y];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span>; </span><br><span class="line">	&#125;</span><br><span class="line"> 	<span class="built_in">memcpy</span>(f[deep],f[deep<span class="number">-1</span>],<span class="built_in">sizeof</span>(f[deep]));</span><br><span class="line">	<span class="keyword">for</span> (k=mid+<span class="number">1</span>;k&lt;=R;k++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">			<span class="keyword">for</span> (j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">				f[deep][i][j]=<span class="built_in">min</span>(f[deep][i][j],f[deep][i][k]+f[deep][k][j]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">solve</span>(L,mid,deep+<span class="number">1</span>);</span><br><span class="line">	</span><br><span class="line"> 	<span class="built_in">memcpy</span>(f[deep],f[deep<span class="number">-1</span>],<span class="built_in">sizeof</span>(f[deep]));</span><br><span class="line">	<span class="keyword">for</span> (k=L;k&lt;=mid;k++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">			<span class="keyword">for</span> (j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">				f[deep][i][j]=<span class="built_in">min</span>(f[deep][i][j],f[deep][i][k]+f[deep][k][j]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">solve</span>(mid+<span class="number">1</span>,R,deep+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;path.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;path.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout);</span><br><span class="line">	<span class="type">int</span> i,j,k,x,y,z;</span><br><span class="line">	<span class="built_in">memset</span>(a,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(a));</span><br><span class="line">	<span class="built_in">memset</span>(f,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(f));</span><br><span class="line">	<span class="built_in">read</span>(n);<span class="built_in">read</span>(m);<span class="built_in">read</span>(q);</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=m;i++) &#123;</span><br><span class="line">		<span class="built_in">read</span>(x);<span class="built_in">read</span>(y);<span class="built_in">read</span>(z); </span><br><span class="line">		a[x][y]=<span class="built_in">min</span>(a[x][y],z);</span><br><span class="line">		a[y][x]=<span class="built_in">min</span>(a[y][x],z); </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) a[i][i]=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=q;i++) &#123;</span><br><span class="line">		<span class="built_in">read</span>(x),<span class="built_in">read</span>(y),<span class="built_in">read</span>(z);</span><br><span class="line">		O[x].<span class="built_in">push_back</span>(<span class="built_in">node</span>(i,y,z));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">memcpy</span>(f[<span class="number">0</span>],a,<span class="built_in">sizeof</span>(f[<span class="number">0</span>]));</span><br><span class="line">	<span class="built_in">solve</span>(<span class="number">1</span>,n,<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=q;i++) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,Ans[i]&gt;=<span class="number">1e9</span>?<span class="number">-1</span>:Ans[i]);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="T3-dove"><a href="#T3-dove" class="headerlink" title="T3. dove"></a>T3. dove</h2><h3 id="Description-2"><a href="#Description-2" class="headerlink" title="Description"></a>Description</h3><p>有 $n$ 个互不相同的位置 $p_i$，初始每个位置有值 $w_i$ ，有两个操作：</p>
<ul>
<li>给 $[l,r]$ 的每个位置加上 $c$</li>
<li>给定 $l,r$ ，如果 $l&lt;r$ ，则把 $l$ 移到 $r$ 的位置，$[l+1,r]$ 向前移一个位置。反之，把 $r$ 移到 $l$ 的位置，$[l,r-1]$ 向后移一个位置。</li>
</ul>
<p>每次操作结束，求带权中位数的位置（权值是每个点的值）。</p>
<p>$n\le 10^5$</p>
<p>1s 512MB</p>
<h3 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution"></a>Solution</h3><p>平衡树维护即可。</p>
<h3 id="Code-2"><a href="#Code-2" class="headerlink" title="Code"></a>Code</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//原题中毒瘤zj卡了一个爆long long的点。所以 sum 用 int128 存一下。</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 100005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> put() putchar(<span class="string">&#x27;\n&#x27;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Tp template<span class="string">&lt;typename Ty&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Ts template<span class="string">&lt;typename Ty,typename... Ar&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(<span class="type">int</span> &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> f=<span class="number">1</span>;x=<span class="number">0</span>;<span class="type">char</span> c=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (c&lt;<span class="string">&#x27;0&#x27;</span>||c&gt;<span class="string">&#x27;9&#x27;</span>) &#123;<span class="keyword">if</span> (c==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">-1</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span> (c&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;c&lt;=<span class="string">&#x27;9&#x27;</span>) &#123;x=x*<span class="number">10</span>+c-<span class="string">&#x27;0&#x27;</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> Debug&#123;</span><br><span class="line">	Tp <span class="type">void</span> _debug(<span class="type">char</span>* f,Ty t)&#123;cerr&lt;&lt;f&lt;&lt;<span class="string">&#x27;=&#x27;</span>&lt;&lt;t&lt;&lt;endl;&#125;</span><br><span class="line">	Ts <span class="type">void</span> _debug(<span class="type">char</span>* f,Ty x,Ar... y)&#123;<span class="keyword">while</span>(*f!=<span class="string">&#x27;,&#x27;</span>) cerr&lt;&lt;*f++;cerr&lt;&lt;<span class="string">&#x27;=&#x27;</span>&lt;&lt;x&lt;&lt;<span class="string">&quot;,&quot;</span>;_debug(f+<span class="number">1</span>,y...);&#125;</span><br><span class="line">	Tp ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; os,vector&lt;Ty&gt;&amp; V)&#123;os&lt;&lt;<span class="string">&quot;[&quot;</span>;<span class="keyword">for</span>(<span class="keyword">auto</span>&amp; vv:V) os&lt;&lt;vv&lt;&lt;<span class="string">&quot;,&quot;</span>;os&lt;&lt;<span class="string">&quot;]&quot;</span>;<span class="keyword">return</span> os;&#125;</span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> gdb(...) _debug((char*)#__VA_ARGS__,__VA_ARGS__)</span></span><br><span class="line">&#125;<span class="keyword">using</span> <span class="keyword">namespace</span> Debug;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">yyy</span>&#123;</span><br><span class="line">    __int128 sum;</span><br><span class="line">	<span class="type">int</span> ls,rs,siz,rnd,lazy,val;</span><br><span class="line">&#125;a[maxn];</span><br><span class="line"><span class="type">int</span> root,cnt;</span><br><span class="line"><span class="function">mt19937 <span class="title">rnd</span><span class="params">(time(<span class="number">0</span>))</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">clone</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">	++cnt;</span><br><span class="line">	a[cnt].ls=a[cnt].rs=<span class="number">0</span>;a[cnt].rnd=<span class="built_in">rnd</span>();</span><br><span class="line">	a[cnt].siz=<span class="number">1</span>;a[cnt].lazy=<span class="number">0</span>;</span><br><span class="line">	a[cnt].val=a[cnt].sum=val;</span><br><span class="line">	<span class="keyword">return</span> cnt;</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">	a[k].sum=a[a[k].ls].sum+a[a[k].rs].sum+a[k].val;</span><br><span class="line">	a[k].siz=a[a[k].ls].siz+a[a[k].rs].siz+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">cover</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">	a[x].lazy+=k;</span><br><span class="line">	a[x].sum+=k*a[x].siz;</span><br><span class="line">	a[x].val+=k; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (a[k].lazy) &#123;</span><br><span class="line">		<span class="keyword">if</span> (a[k].ls) <span class="built_in">cover</span>(a[k].ls,a[k].lazy);</span><br><span class="line">		<span class="keyword">if</span> (a[k].rs) <span class="built_in">cover</span>(a[k].rs,a[k].lazy);</span><br><span class="line">		a[k].lazy=<span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">split</span><span class="params">(<span class="type">int</span> k,<span class="type">int</span> x,<span class="type">int</span> &amp;tmp1,<span class="type">int</span> &amp;tmp2)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!k) <span class="keyword">return</span> tmp1=tmp2=<span class="number">0</span>,<span class="built_in">void</span>();</span><br><span class="line">	<span class="built_in">pushdown</span>(k);</span><br><span class="line">	<span class="keyword">if</span> (a[a[k].ls].siz+<span class="number">1</span>&lt;x) &#123;</span><br><span class="line">		<span class="built_in">split</span>(a[k].rs,x-a[a[k].ls].siz<span class="number">-1</span>,a[k].rs,tmp2);</span><br><span class="line">		<span class="built_in">pushup</span>(k);tmp1=k;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="built_in">split</span>(a[k].ls,x,tmp1,a[k].ls);</span><br><span class="line">		<span class="built_in">pushup</span>(k);tmp2=k;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!x||!y) <span class="keyword">return</span> x+y;</span><br><span class="line">	<span class="keyword">if</span> (a[x].rnd&lt;a[y].rnd) &#123;</span><br><span class="line">		<span class="built_in">pushdown</span>(x);</span><br><span class="line">		a[x].rs=<span class="built_in">merge</span>(a[x].rs,y);</span><br><span class="line">		<span class="built_in">pushup</span>(x);<span class="keyword">return</span> x;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="built_in">pushdown</span>(y);</span><br><span class="line">		a[y].ls=<span class="built_in">merge</span>(x,a[y].ls);</span><br><span class="line">		<span class="built_in">pushup</span>(y);<span class="keyword">return</span> y;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> x=(a[k].sum+<span class="number">1</span>)/<span class="number">2</span>,sum=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (k) &#123;</span><br><span class="line">		<span class="built_in">pushdown</span>(k);</span><br><span class="line">		<span class="keyword">if</span> (x&lt;=a[a[k].ls].sum) k=a[k].ls;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (x&lt;=a[a[k].ls].sum+a[k].val) <span class="keyword">return</span> sum+<span class="number">1</span>+a[a[k].ls].siz;</span><br><span class="line">		<span class="keyword">else</span> x=x-a[a[k].ls].sum-a[k].val,sum+=a[a[k].ls].siz+<span class="number">1</span>,k=a[k].rs; </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> p[maxn],w[maxn];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!k) <span class="keyword">return</span> ;</span><br><span class="line">	<span class="built_in">pushdown</span>(k);</span><br><span class="line">	<span class="built_in">assert</span>(a[k].sum==a[a[k].ls].sum+a[a[k].rs].sum+a[k].val);</span><br><span class="line">	<span class="built_in">print</span>(a[k].ls);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld &quot;</span>,a[k].val);</span><br><span class="line">	<span class="built_in">print</span>(a[k].rs);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;dove.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;dove.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout);</span><br><span class="line">	<span class="type">char</span> ch;<span class="type">int</span> l,r,s,i,sum=<span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> tmp1,tmp2,tmp3,tmp4;</span><br><span class="line">	<span class="built_in">read</span>(n);<span class="built_in">read</span>(m);</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">read</span>(w[i]),root=<span class="built_in">merge</span>(root,<span class="built_in">clone</span>(w[i])),sum+=w[i];</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">read</span>(p[i]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,p[<span class="built_in">query</span>(root)]);</span><br><span class="line">	<span class="keyword">while</span> (m--) &#123;</span><br><span class="line">		ch=<span class="built_in">getchar</span>();<span class="keyword">while</span> (ch!=<span class="string">&#x27;A&#x27;</span>&amp;&amp;ch!=<span class="string">&#x27;B&#x27;</span>) ch=<span class="built_in">getchar</span>();</span><br><span class="line">		<span class="keyword">if</span> (ch==<span class="string">&#x27;A&#x27;</span>) &#123;</span><br><span class="line">			<span class="built_in">read</span>(l);<span class="built_in">read</span>(r);<span class="built_in">read</span>(s);</span><br><span class="line">			<span class="built_in">split</span>(root,l,tmp1,tmp2);</span><br><span class="line">			<span class="built_in">split</span>(tmp2,r-l+<span class="number">2</span>,tmp2,tmp3);</span><br><span class="line">			<span class="built_in">cover</span>(tmp2,s);</span><br><span class="line">			root=<span class="built_in">merge</span>(tmp1,<span class="built_in">merge</span>(tmp2,tmp3));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="built_in">read</span>(l);<span class="built_in">read</span>(r);</span><br><span class="line">			<span class="keyword">if</span> (l&lt;r) &#123;</span><br><span class="line">				<span class="built_in">split</span>(root,l,tmp1,tmp2);</span><br><span class="line">				<span class="built_in">split</span>(tmp2,<span class="number">2</span>,tmp2,tmp3);</span><br><span class="line">				<span class="built_in">split</span>(tmp3,r-l+<span class="number">1</span>,tmp3,tmp4);</span><br><span class="line">				root=<span class="built_in">merge</span>(<span class="built_in">merge</span>(tmp1,tmp3),<span class="built_in">merge</span>(tmp2,tmp4));</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="built_in">swap</span>(l,r);</span><br><span class="line">				<span class="built_in">split</span>(root,l,tmp1,tmp2);</span><br><span class="line">				<span class="built_in">split</span>(tmp2,r-l+<span class="number">1</span>,tmp2,tmp3);</span><br><span class="line">				<span class="built_in">split</span>(tmp3,<span class="number">2</span>,tmp3,tmp4);</span><br><span class="line">				root=<span class="built_in">merge</span>(<span class="built_in">merge</span>(tmp1,tmp3),<span class="built_in">merge</span>(tmp2,tmp4));</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,p[<span class="built_in">query</span>(root)]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="T4-music"><a href="#T4-music" class="headerlink" title="T4. music"></a>T4. music</h2><p>今天 T4 好像是错题，就不放了。</p>
]]></content>
      <tags>
        <tag>NOIP模拟赛</tag>
        <tag>线段树分治</tag>
        <tag>Floyd</tag>
        <tag>平衡树</tag>
      </tags>
  </entry>
  <entry>
    <title>7.9 模拟赛</title>
    <url>/2023/07/18/7-9-%E6%A8%A1%E6%8B%9F%E8%B5%9B/</url>
    <content><![CDATA[<h1 id="7-9-模拟赛"><a href="#7-9-模拟赛" class="headerlink" title="7.9 模拟赛"></a>7.9 模拟赛</h1><h2 id="T1-six"><a href="#T1-six" class="headerlink" title="T1. six"></a>T1. six</h2><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p><img src="https://s2.loli.net/2023/07/18/bwIND2h6aHyJ3lv.png" alt="image-20230718141203887"></p>
<p>1s 512MB</p>
<h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><p>模拟。总状态只有 $2^8&#x3D;256$</p>
<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 1005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> put() putchar(<span class="string">&#x27;\n&#x27;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Tp template<span class="string">&lt;typename Ty&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Ts template<span class="string">&lt;typename Ty,typename... Ar&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(<span class="type">int</span> &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> f=<span class="number">1</span>;x=<span class="number">0</span>;<span class="type">char</span> c=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (c&lt;<span class="string">&#x27;0&#x27;</span>||c&gt;<span class="string">&#x27;9&#x27;</span>) &#123;<span class="keyword">if</span> (c==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">-1</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span> (c&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;c&lt;=<span class="string">&#x27;9&#x27;</span>) &#123;x=x*<span class="number">10</span>+c-<span class="string">&#x27;0&#x27;</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> Debug&#123;</span><br><span class="line">	Tp <span class="type">void</span> _debug(<span class="type">char</span>* f,Ty t)&#123;cerr&lt;&lt;f&lt;&lt;<span class="string">&#x27;=&#x27;</span>&lt;&lt;t&lt;&lt;endl;&#125;</span><br><span class="line">	Ts <span class="type">void</span> _debug(<span class="type">char</span>* f,Ty x,Ar... y)&#123;<span class="keyword">while</span>(*f!=<span class="string">&#x27;,&#x27;</span>) cerr&lt;&lt;*f++;cerr&lt;&lt;<span class="string">&#x27;=&#x27;</span>&lt;&lt;x&lt;&lt;<span class="string">&quot;,&quot;</span>;_debug(f+<span class="number">1</span>,y...);&#125;</span><br><span class="line">	Tp ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; os,vector&lt;Ty&gt;&amp; V)&#123;os&lt;&lt;<span class="string">&quot;[&quot;</span>;<span class="keyword">for</span>(<span class="keyword">auto</span>&amp; vv:V) os&lt;&lt;vv&lt;&lt;<span class="string">&quot;,&quot;</span>;os&lt;&lt;<span class="string">&quot;]&quot;</span>;<span class="keyword">return</span> os;&#125;</span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> gdb(...) _debug((char*)#__VA_ARGS__,__VA_ARGS__)</span></span><br><span class="line">&#125;<span class="keyword">using</span> <span class="keyword">namespace</span> Debug;</span><br><span class="line"><span class="type">int</span> dis[maxn];</span><br><span class="line">queue&lt;<span class="type">int</span>&gt;q;</span><br><span class="line"><span class="type">int</span> ch1[<span class="number">11</span>],ch2[<span class="number">11</span>];</span><br><span class="line"><span class="type">int</span> t[<span class="number">11</span>],g[<span class="number">11</span>],b[<span class="number">11</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">calc</span><span class="params">(<span class="type">int</span> *a)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> i,sum=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++) sum+=a[i]*(<span class="number">1</span>&lt;&lt;i);</span><br><span class="line">	<span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++) b[i]=(x&gt;&gt;i)&amp;<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++) <span class="keyword">if</span> (ch1[i]!=(b[i]|b[i+<span class="number">4</span>])) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (ch2[<span class="number">0</span>]!=(b[<span class="number">0</span>]|b[<span class="number">1</span>])) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (ch2[<span class="number">1</span>]!=(b[<span class="number">4</span>]|b[<span class="number">5</span>])) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (ch2[<span class="number">2</span>]!=(b[<span class="number">2</span>]|b[<span class="number">3</span>])) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (ch2[<span class="number">3</span>]!=(b[<span class="number">6</span>]|b[<span class="number">7</span>])) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf=<span class="number">1e9</span>;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;six.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;six.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout); </span><br><span class="line">	<span class="type">char</span> ch;<span class="type">int</span> i,j,tmp;</span><br><span class="line">	<span class="built_in">memset</span>(dis,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(dis));</span><br><span class="line">	<span class="type">int</span> x=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=<span class="number">8</span>;i++) cin&gt;&gt;ch,x+=(ch==<span class="string">&#x27;1&#x27;</span>)*(<span class="number">1</span>&lt;&lt;i<span class="number">-1</span>);</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++) cin&gt;&gt;ch,ch1[i]=(ch==<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++) cin&gt;&gt;ch,ch2[i]=(ch==<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line">	dis[x]=<span class="number">0</span>;q.<span class="built_in">push</span>(x);</span><br><span class="line">	<span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">		x=q.<span class="built_in">front</span>();q.<span class="built_in">pop</span>();</span><br><span class="line">		<span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++) t[i]=(x&gt;&gt;i)&amp;<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">check</span>(x)) <span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,dis[x]),<span class="number">0</span>;</span><br><span class="line">		</span><br><span class="line">		<span class="built_in">memcpy</span>(g,t,<span class="built_in">sizeof</span>(g));</span><br><span class="line">		<span class="built_in">swap</span>(g[<span class="number">0</span>],g[<span class="number">1</span>]),<span class="built_in">swap</span>(g[<span class="number">1</span>],g[<span class="number">3</span>]),<span class="built_in">swap</span>(g[<span class="number">3</span>],g[<span class="number">2</span>]);</span><br><span class="line">		<span class="keyword">if</span> (dis[tmp=<span class="built_in">calc</span>(g)]&gt;=inf) dis[tmp]=dis[x]+<span class="number">1</span>,q.<span class="built_in">push</span>(tmp);</span><br><span class="line">		</span><br><span class="line">		<span class="built_in">memcpy</span>(g,t,<span class="built_in">sizeof</span>(g));</span><br><span class="line">		<span class="built_in">swap</span>(g[<span class="number">2</span>],g[<span class="number">3</span>]),<span class="built_in">swap</span>(g[<span class="number">3</span>],g[<span class="number">1</span>]),<span class="built_in">swap</span>(g[<span class="number">1</span>],g[<span class="number">0</span>]);</span><br><span class="line">		<span class="keyword">if</span> (dis[tmp=<span class="built_in">calc</span>(g)]&gt;=inf) dis[tmp]=dis[x]+<span class="number">1</span>,q.<span class="built_in">push</span>(tmp);</span><br><span class="line">		</span><br><span class="line">		<span class="built_in">memcpy</span>(g,t,<span class="built_in">sizeof</span>(g));</span><br><span class="line">		<span class="built_in">swap</span>(g[<span class="number">4</span>],g[<span class="number">5</span>]),<span class="built_in">swap</span>(g[<span class="number">5</span>],g[<span class="number">7</span>]),<span class="built_in">swap</span>(g[<span class="number">7</span>],g[<span class="number">6</span>]);</span><br><span class="line">		<span class="keyword">if</span> (dis[tmp=<span class="built_in">calc</span>(g)]&gt;=inf) dis[tmp]=dis[x]+<span class="number">1</span>,q.<span class="built_in">push</span>(tmp);</span><br><span class="line">		</span><br><span class="line">		<span class="built_in">memcpy</span>(g,t,<span class="built_in">sizeof</span>(g));</span><br><span class="line">		<span class="built_in">swap</span>(g[<span class="number">6</span>],g[<span class="number">7</span>]),<span class="built_in">swap</span>(g[<span class="number">7</span>],g[<span class="number">5</span>]),<span class="built_in">swap</span>(g[<span class="number">5</span>],g[<span class="number">4</span>]);</span><br><span class="line">		<span class="keyword">if</span> (dis[tmp=<span class="built_in">calc</span>(g)]&gt;=inf) dis[tmp]=dis[x]+<span class="number">1</span>,q.<span class="built_in">push</span>(tmp);</span><br><span class="line">		<span class="comment">//</span></span><br><span class="line">		<span class="built_in">memcpy</span>(g,t,<span class="built_in">sizeof</span>(g));</span><br><span class="line">		<span class="built_in">swap</span>(g[<span class="number">1</span>],g[<span class="number">3</span>]),<span class="built_in">swap</span>(g[<span class="number">3</span>],g[<span class="number">7</span>]),<span class="built_in">swap</span>(g[<span class="number">7</span>],g[<span class="number">5</span>]);</span><br><span class="line">		<span class="keyword">if</span> (dis[tmp=<span class="built_in">calc</span>(g)]&gt;=inf) dis[tmp]=dis[x]+<span class="number">1</span>,q.<span class="built_in">push</span>(tmp);</span><br><span class="line">		</span><br><span class="line">		<span class="built_in">memcpy</span>(g,t,<span class="built_in">sizeof</span>(g));</span><br><span class="line">		<span class="built_in">swap</span>(g[<span class="number">5</span>],g[<span class="number">7</span>]),<span class="built_in">swap</span>(g[<span class="number">7</span>],g[<span class="number">3</span>]),<span class="built_in">swap</span>(g[<span class="number">3</span>],g[<span class="number">1</span>]);</span><br><span class="line">		<span class="keyword">if</span> (dis[tmp=<span class="built_in">calc</span>(g)]&gt;=inf) dis[tmp]=dis[x]+<span class="number">1</span>,q.<span class="built_in">push</span>(tmp);</span><br><span class="line">		</span><br><span class="line">		<span class="built_in">memcpy</span>(g,t,<span class="built_in">sizeof</span>(g));</span><br><span class="line">		<span class="built_in">swap</span>(g[<span class="number">0</span>],g[<span class="number">2</span>]),<span class="built_in">swap</span>(g[<span class="number">2</span>],g[<span class="number">6</span>]),<span class="built_in">swap</span>(g[<span class="number">6</span>],g[<span class="number">4</span>]);</span><br><span class="line">		<span class="keyword">if</span> (dis[tmp=<span class="built_in">calc</span>(g)]&gt;=inf) dis[tmp]=dis[x]+<span class="number">1</span>,q.<span class="built_in">push</span>(tmp);</span><br><span class="line">		</span><br><span class="line">		<span class="built_in">memcpy</span>(g,t,<span class="built_in">sizeof</span>(g));</span><br><span class="line">		<span class="built_in">swap</span>(g[<span class="number">4</span>],g[<span class="number">6</span>]),<span class="built_in">swap</span>(g[<span class="number">6</span>],g[<span class="number">2</span>]),<span class="built_in">swap</span>(g[<span class="number">2</span>],g[<span class="number">0</span>]);</span><br><span class="line">		<span class="keyword">if</span> (dis[tmp=<span class="built_in">calc</span>(g)]&gt;=inf) dis[tmp]=dis[x]+<span class="number">1</span>,q.<span class="built_in">push</span>(tmp);</span><br><span class="line">		<span class="comment">//</span></span><br><span class="line">		<span class="built_in">memcpy</span>(g,t,<span class="built_in">sizeof</span>(g));</span><br><span class="line">		<span class="built_in">swap</span>(g[<span class="number">0</span>],g[<span class="number">1</span>]),<span class="built_in">swap</span>(g[<span class="number">1</span>],g[<span class="number">5</span>]),<span class="built_in">swap</span>(g[<span class="number">5</span>],g[<span class="number">4</span>]);</span><br><span class="line">		<span class="keyword">if</span> (dis[tmp=<span class="built_in">calc</span>(g)]&gt;=inf) dis[tmp]=dis[x]+<span class="number">1</span>,q.<span class="built_in">push</span>(tmp);</span><br><span class="line">		</span><br><span class="line">		<span class="built_in">memcpy</span>(g,t,<span class="built_in">sizeof</span>(g));</span><br><span class="line">		<span class="built_in">swap</span>(g[<span class="number">4</span>],g[<span class="number">5</span>]),<span class="built_in">swap</span>(g[<span class="number">5</span>],g[<span class="number">1</span>]),<span class="built_in">swap</span>(g[<span class="number">1</span>],g[<span class="number">0</span>]);</span><br><span class="line">		<span class="keyword">if</span> (dis[tmp=<span class="built_in">calc</span>(g)]&gt;=inf) dis[tmp]=dis[x]+<span class="number">1</span>,q.<span class="built_in">push</span>(tmp);</span><br><span class="line">		</span><br><span class="line">		<span class="built_in">memcpy</span>(g,t,<span class="built_in">sizeof</span>(g));</span><br><span class="line">		<span class="built_in">swap</span>(g[<span class="number">2</span>],g[<span class="number">3</span>]),<span class="built_in">swap</span>(g[<span class="number">3</span>],g[<span class="number">7</span>]),<span class="built_in">swap</span>(g[<span class="number">7</span>],g[<span class="number">6</span>]);</span><br><span class="line">		<span class="keyword">if</span> (dis[tmp=<span class="built_in">calc</span>(g)]&gt;=inf) dis[tmp]=dis[x]+<span class="number">1</span>,q.<span class="built_in">push</span>(tmp);</span><br><span class="line">		</span><br><span class="line">		<span class="built_in">memcpy</span>(g,t,<span class="built_in">sizeof</span>(g));</span><br><span class="line">		<span class="built_in">swap</span>(g[<span class="number">6</span>],g[<span class="number">7</span>]),<span class="built_in">swap</span>(g[<span class="number">7</span>],g[<span class="number">3</span>]),<span class="built_in">swap</span>(g[<span class="number">3</span>],g[<span class="number">2</span>]);</span><br><span class="line">		<span class="keyword">if</span> (dis[tmp=<span class="built_in">calc</span>(g)]&gt;=inf) dis[tmp]=dis[x]+<span class="number">1</span>,q.<span class="built_in">push</span>(tmp);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="T2-march"><a href="#T2-march" class="headerlink" title="T2. march"></a>T2. march</h2><h3 id="Description-1"><a href="#Description-1" class="headerlink" title="Description"></a>Description</h3><p><img src="https://s2.loli.net/2023/07/18/sutHVXi3xLfoyvz.png" alt="image-20230718152125824"></p>
<p>$m\le |S|\le 10^6$</p>
<h3 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution"></a>Solution</h3><p>很好的线性 dp！</p>
<p>考虑令 $f[i][0&#x2F;1],g[i][0&#x2F;1],h[i][0&#x2F;1]$ 表示到第 $i$ 个位置，结尾为 $0&#x2F;1$，分别没找到 $[l1,r1]$，仅存在 $[l1,r1]$，存在 $[l1,r1],[l2,r2]$ 的方案数。</p>
<p>考虑 $f$ 向 $g$ 转移，如果在 $[i-m+1,i]$ 都没有 $0$，$g[i][1]\leftarrow f[i-m][0]$ ，同时为了防止 $f$ 算重（保持总数不变），$f[i][1]\leftarrow -f[i-m][0]$。</p>
<p>$g$ 向 $h$ 同理。</p>
<p>1s 512MB</p>
<h3 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 1000005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> put() putchar(<span class="string">&#x27;\n&#x27;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Tp template<span class="string">&lt;typename Ty&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Ts template<span class="string">&lt;typename Ty,typename... Ar&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(<span class="type">int</span> &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> f=<span class="number">1</span>;x=<span class="number">0</span>;<span class="type">char</span> c=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (c&lt;<span class="string">&#x27;0&#x27;</span>||c&gt;<span class="string">&#x27;9&#x27;</span>) &#123;<span class="keyword">if</span> (c==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">-1</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span> (c&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;c&lt;=<span class="string">&#x27;9&#x27;</span>) &#123;x=x*<span class="number">10</span>+c-<span class="string">&#x27;0&#x27;</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> Debug&#123;</span><br><span class="line">	Tp <span class="type">void</span> _debug(<span class="type">char</span>* f,Ty t)&#123;cerr&lt;&lt;f&lt;&lt;<span class="string">&#x27;=&#x27;</span>&lt;&lt;t&lt;&lt;endl;&#125;</span><br><span class="line">	Ts <span class="type">void</span> _debug(<span class="type">char</span>* f,Ty x,Ar... y)&#123;<span class="keyword">while</span>(*f!=<span class="string">&#x27;,&#x27;</span>) cerr&lt;&lt;*f++;cerr&lt;&lt;<span class="string">&#x27;=&#x27;</span>&lt;&lt;x&lt;&lt;<span class="string">&quot;,&quot;</span>;_debug(f+<span class="number">1</span>,y...);&#125;</span><br><span class="line">	Tp ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; os,vector&lt;Ty&gt;&amp; V)&#123;os&lt;&lt;<span class="string">&quot;[&quot;</span>;<span class="keyword">for</span>(<span class="keyword">auto</span>&amp; vv:V) os&lt;&lt;vv&lt;&lt;<span class="string">&quot;,&quot;</span>;os&lt;&lt;<span class="string">&quot;]&quot;</span>;<span class="keyword">return</span> os;&#125;</span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> gdb(...) _debug((char*)#__VA_ARGS__,__VA_ARGS__)</span></span><br><span class="line">&#125;<span class="keyword">using</span> <span class="keyword">namespace</span> Debug;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>,Inv=(mod+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line"><span class="type">char</span> ch[maxn];</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> suf1[maxn],suf0[maxn],f[maxn][<span class="number">2</span>],g[maxn][<span class="number">2</span>],h[maxn][<span class="number">2</span>]; </span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> &amp;x,<span class="type">int</span> y)</span> </span>&#123;x=(x+y)%mod;&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="built_in">read</span>(m);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,ch+<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span> (n=<span class="number">0</span>;ch[n+<span class="number">1</span>];n++);</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		suf1[i]=suf1[i<span class="number">-1</span>];</span><br><span class="line">		suf0[i]=suf0[i<span class="number">-1</span>];</span><br><span class="line">		<span class="keyword">if</span> (ch[i]==<span class="string">&#x27;1&#x27;</span>) suf1[i]++;</span><br><span class="line">		<span class="keyword">if</span> (ch[i]==<span class="string">&#x27;0&#x27;</span>) suf0[i]++; </span><br><span class="line">	&#125;</span><br><span class="line">	f[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (ch[i]!=<span class="string">&#x27;0&#x27;</span>) <span class="built_in">add</span>(f[i][<span class="number">1</span>],f[i<span class="number">-1</span>][<span class="number">0</span>]+f[i<span class="number">-1</span>][<span class="number">1</span>]);</span><br><span class="line">		<span class="keyword">if</span> (ch[i]!=<span class="string">&#x27;1&#x27;</span>) <span class="built_in">add</span>(f[i][<span class="number">0</span>],f[i<span class="number">-1</span>][<span class="number">0</span>]+f[i<span class="number">-1</span>][<span class="number">1</span>]); </span><br><span class="line">		<span class="keyword">if</span> (i&gt;=m&amp;&amp;suf0[i]-suf0[i-m]==<span class="number">0</span>) <span class="built_in">add</span>(g[i][<span class="number">1</span>],f[i-m][<span class="number">0</span>]),<span class="built_in">add</span>(f[i][<span class="number">1</span>],mod-f[i-m][<span class="number">0</span>]);</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span> (ch[i]!=<span class="string">&#x27;0&#x27;</span>) <span class="built_in">add</span>(g[i][<span class="number">1</span>],g[i<span class="number">-1</span>][<span class="number">0</span>]+g[i<span class="number">-1</span>][<span class="number">1</span>]);</span><br><span class="line">		<span class="keyword">if</span> (ch[i]!=<span class="string">&#x27;1&#x27;</span>) <span class="built_in">add</span>(g[i][<span class="number">0</span>],g[i<span class="number">-1</span>][<span class="number">0</span>]+g[i<span class="number">-1</span>][<span class="number">1</span>]); </span><br><span class="line">		<span class="keyword">if</span> (i&gt;=m&amp;&amp;suf1[i]-suf1[i-m]==<span class="number">0</span>) <span class="built_in">add</span>(h[i][<span class="number">0</span>],g[i-m][<span class="number">1</span>]),<span class="built_in">add</span>(g[i][<span class="number">0</span>],mod-g[i-m][<span class="number">1</span>]);</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span> (ch[i]!=<span class="string">&#x27;0&#x27;</span>) <span class="built_in">add</span>(h[i][<span class="number">1</span>],h[i<span class="number">-1</span>][<span class="number">0</span>]+h[i<span class="number">-1</span>][<span class="number">1</span>]);</span><br><span class="line">		<span class="keyword">if</span> (ch[i]!=<span class="string">&#x27;1&#x27;</span>) <span class="built_in">add</span>(h[i][<span class="number">0</span>],h[i<span class="number">-1</span>][<span class="number">0</span>]+h[i<span class="number">-1</span>][<span class="number">1</span>]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,(h[n][<span class="number">0</span>]+h[n][<span class="number">1</span>])%mod);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="T3-planet"><a href="#T3-planet" class="headerlink" title="T3.planet"></a>T3.planet</h2><h3 id="Description-2"><a href="#Description-2" class="headerlink" title="Description"></a>Description</h3><p><img src="https://s2.loli.net/2023/07/18/EmM1CWuHQVzNb8f.png" alt="image-20230718153023351"></p>
<p>$n\le 1500$</p>
<p>1s 512MB</p>
<h3 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution"></a>Solution</h3><p>很好的题。</p>
<p>点边互换，考虑一个 $(n+1)\times (n+1)$ 的点阵，最外面一圈都已经相连。这个图显然是一平面图。如果两条边断开，则对应图上的两个点相连。两个点不再联通等价于图上多了一个面。</p>
<p>用平面图欧拉定理维护面的数量。具体实现上，判断两个点是否已经联通。</p>
<h3 id="Code-2"><a href="#Code-2" class="headerlink" title="Code"></a>Code</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 2005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> put() putchar(<span class="string">&#x27;\n&#x27;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Tp template<span class="string">&lt;typename Ty&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Ts template<span class="string">&lt;typename Ty,typename... Ar&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(<span class="type">int</span> &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> f=<span class="number">1</span>;x=<span class="number">0</span>;<span class="type">char</span> c=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (c&lt;<span class="string">&#x27;0&#x27;</span>||c&gt;<span class="string">&#x27;9&#x27;</span>) &#123;<span class="keyword">if</span> (c==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">-1</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span> (c&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;c&lt;=<span class="string">&#x27;9&#x27;</span>) &#123;x=x*<span class="number">10</span>+c-<span class="string">&#x27;0&#x27;</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> Debug&#123;</span><br><span class="line">	Tp <span class="type">void</span> _debug(<span class="type">char</span>* f,Ty t)&#123;cerr&lt;&lt;f&lt;&lt;<span class="string">&#x27;=&#x27;</span>&lt;&lt;t&lt;&lt;endl;&#125;</span><br><span class="line">	Ts <span class="type">void</span> _debug(<span class="type">char</span>* f,Ty x,Ar... y)&#123;<span class="keyword">while</span>(*f!=<span class="string">&#x27;,&#x27;</span>) cerr&lt;&lt;*f++;cerr&lt;&lt;<span class="string">&#x27;=&#x27;</span>&lt;&lt;x&lt;&lt;<span class="string">&quot;,&quot;</span>;_debug(f+<span class="number">1</span>,y...);&#125;</span><br><span class="line">	Tp ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; os,vector&lt;Ty&gt;&amp; V)&#123;os&lt;&lt;<span class="string">&quot;[&quot;</span>;<span class="keyword">for</span>(<span class="keyword">auto</span>&amp; vv:V) os&lt;&lt;vv&lt;&lt;<span class="string">&quot;,&quot;</span>;os&lt;&lt;<span class="string">&quot;]&quot;</span>;<span class="keyword">return</span> os;&#125;</span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> gdb(...) _debug((char*)#__VA_ARGS__,__VA_ARGS__)</span></span><br><span class="line">&#125;<span class="keyword">using</span> <span class="keyword">namespace</span> Debug;</span><br><span class="line"><span class="type">int</span> n,q;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">id</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> j)</span> </span>&#123;<span class="keyword">return</span> (i<span class="number">-1</span>)*(n+<span class="number">1</span>)+j;&#125;</span><br><span class="line"><span class="type">int</span> fa[maxn*maxn];</span><br><span class="line"><span class="type">int</span> dn,en,total;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">getfa</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;<span class="keyword">return</span> x==fa[x]?x:fa[x]=<span class="built_in">getfa</span>(fa[x]);&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">	x=<span class="built_in">getfa</span>(x),y=<span class="built_in">getfa</span>(y);</span><br><span class="line">	<span class="keyword">if</span> (x^y) fa[x]=y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> x,y,xx,yy,c=<span class="number">0</span>,q,i,j,fx,fy;</span><br><span class="line">	<span class="built_in">read</span>(n);<span class="built_in">read</span>(q);<span class="built_in">gdb</span>(n);</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=(n+<span class="number">1</span>)*(n+<span class="number">1</span>);i++) fa[i]=i;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">merge</span>(<span class="built_in">id</span>(<span class="number">1</span>,i),<span class="built_in">id</span>(<span class="number">1</span>,i+<span class="number">1</span>)),<span class="built_in">merge</span>(<span class="built_in">id</span>(n+<span class="number">1</span>,i),<span class="built_in">id</span>(n+<span class="number">1</span>,i+<span class="number">1</span>));</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">merge</span>(<span class="built_in">id</span>(i,<span class="number">1</span>),<span class="built_in">id</span>(i+<span class="number">1</span>,<span class="number">1</span>)),<span class="built_in">merge</span>(<span class="built_in">id</span>(i,n+<span class="number">1</span>),<span class="built_in">id</span>(i+<span class="number">1</span>,n+<span class="number">1</span>));</span><br><span class="line">	en=(n<span class="number">-1</span>)*<span class="number">4</span>,dn=n*n,total=(n<span class="number">-2</span>)*(n<span class="number">-2</span>)+<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (q--) &#123;</span><br><span class="line">		<span class="built_in">read</span>(x),<span class="built_in">read</span>(y),<span class="built_in">read</span>(xx),<span class="built_in">read</span>(yy);</span><br><span class="line">		x=(x+c)%n+<span class="number">1</span>,y=(y+c)%n+<span class="number">1</span>,xx=(xx+c)%n+<span class="number">1</span>,yy=(yy+c)%n+<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span> (x==xx) &#123;</span><br><span class="line">			<span class="keyword">if</span> (y&gt;yy) <span class="built_in">swap</span>(y,yy);</span><br><span class="line">			fx=<span class="built_in">getfa</span>(<span class="built_in">id</span>(x,yy));</span><br><span class="line">			fy=<span class="built_in">getfa</span>(<span class="built_in">id</span>(x+<span class="number">1</span>,yy));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> (x&gt;xx) <span class="built_in">swap</span>(x,xx);</span><br><span class="line">			fx=<span class="built_in">getfa</span>(<span class="built_in">id</span>(xx,y));</span><br><span class="line">			fy=<span class="built_in">getfa</span>(<span class="built_in">id</span>(xx,y+<span class="number">1</span>));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (fx^fy) <span class="built_in">puts</span>(<span class="string">&quot;YES&quot;</span>),fa[fx]=fy,c++;</span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;NO&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="T4-dustbin"><a href="#T4-dustbin" class="headerlink" title="T4. dustbin"></a>T4. dustbin</h2><h3 id="Description-3"><a href="#Description-3" class="headerlink" title="Description"></a>Description</h3><p><img src="https://s2.loli.net/2023/07/18/zB1MLFe3PEYv7Hl.png" alt="image-20230718153902806"></p>
<p>$n,q\le 5\times 10^5$</p>
<p>3s 512MB</p>
<p>原题 CF526G，强制在线方式略有不同。</p>
<h3 id="Solution-3"><a href="#Solution-3" class="headerlink" title="Solution"></a>Solution</h3><p>先不考虑 $a$ 的限制。</p>
<p>如果 $c&#x3D;1$ ，选择的是直径。否则<strong>再</strong>选择 $c-1$ 条最大以叶子节点为端点的线段交的最大值。</p>
<p>考虑以直径的一端为端点。则原题即为选择 $2c-1$ 条最长叶子到根的路径并起来。</p>
<p>但不一定是前 $2c-1$ 长的路径组成的。这里贪心一下即可预处理出来。</p>
<p>现在要加上 $a$ 的限制。</p>
<p>一种情况是直接替换第 $2c-1$ 小的路径。另一种情况是在 $2c-2$ 小的路径的基础上，再找一条最长的路径。</p>
<p>可能要特判 $c&#x3D;1$ 的点。 </p>
<h3 id="Code-3"><a href="#Code-3" class="headerlink" title="Code"></a>Code</h3><p>代码贴的是 CF 的。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 500005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> put() putchar(<span class="string">&#x27;\n&#x27;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Tp template<span class="string">&lt;typename Ty&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Ts template<span class="string">&lt;typename Ty,typename... Ar&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(<span class="type">int</span> &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> f=<span class="number">1</span>;x=<span class="number">0</span>;<span class="type">char</span> c=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (c&lt;<span class="string">&#x27;0&#x27;</span>||c&gt;<span class="string">&#x27;9&#x27;</span>) &#123;<span class="keyword">if</span> (c==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">-1</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span> (c&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;c&lt;=<span class="string">&#x27;9&#x27;</span>) &#123;x=x*<span class="number">10</span>+c-<span class="string">&#x27;0&#x27;</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> Debug&#123;</span><br><span class="line">	Tp <span class="type">void</span> _debug(<span class="type">char</span>* f,Ty t)&#123;cerr&lt;&lt;f&lt;&lt;<span class="string">&#x27;=&#x27;</span>&lt;&lt;t&lt;&lt;endl;&#125;</span><br><span class="line">	Ts <span class="type">void</span> _debug(<span class="type">char</span>* f,Ty x,Ar... y)&#123;<span class="keyword">while</span>(*f!=<span class="string">&#x27;,&#x27;</span>) cerr&lt;&lt;*f++;cerr&lt;&lt;<span class="string">&#x27;=&#x27;</span>&lt;&lt;x&lt;&lt;<span class="string">&quot;,&quot;</span>;_debug(f+<span class="number">1</span>,y...);&#125;</span><br><span class="line">	Tp ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; os,vector&lt;Ty&gt;&amp; V)&#123;os&lt;&lt;<span class="string">&quot;[&quot;</span>;<span class="keyword">for</span>(<span class="keyword">auto</span>&amp; vv:V) os&lt;&lt;vv&lt;&lt;<span class="string">&quot;,&quot;</span>;os&lt;&lt;<span class="string">&quot;]&quot;</span>;<span class="keyword">return</span> os;&#125;</span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> gdb(...) _debug((char*)#__VA_ARGS__,__VA_ARGS__)</span></span><br><span class="line">&#125;<span class="keyword">using</span> <span class="keyword">namespace</span> Debug;</span><br><span class="line"><span class="type">int</span> h[maxn],head=<span class="number">1</span>,n,q;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">yyy</span>&#123;</span><br><span class="line">	<span class="type">int</span> to,z,w;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">		to=y;z=h[x];h[x]=head;w=val;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;a[maxn*<span class="number">2</span>];</span><br><span class="line"><span class="keyword">namespace</span> TD&#123;</span><br><span class="line">	queue&lt;<span class="type">int</span>&gt;q;</span><br><span class="line">	<span class="type">int</span> dis[maxn];</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">bfs</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">		<span class="type">int</span> i,ans=x;</span><br><span class="line">		<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) dis[i]=<span class="number">-1</span>;</span><br><span class="line">		dis[x]=<span class="number">0</span>;</span><br><span class="line">		q.<span class="built_in">push</span>(x);</span><br><span class="line">		<span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">			x=q.<span class="built_in">front</span>();q.<span class="built_in">pop</span>();</span><br><span class="line">			<span class="keyword">for</span> (i=h[x];i;i=a[i].z) <span class="keyword">if</span> (dis[a[i].to]==<span class="number">-1</span>) &#123;</span><br><span class="line">				dis[a[i].to]=dis[x]+a[i].w,q.<span class="built_in">push</span>(a[i].to);</span><br><span class="line">				<span class="keyword">if</span> (dis[ans]&lt;dis[a[i].to]) ans=a[i].to;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> ans;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> &amp;x,<span class="type">int</span> &amp;y)</span> </span>&#123;</span><br><span class="line">		x=<span class="built_in">bfs</span>(<span class="number">1</span>),y=<span class="built_in">bfs</span>(x);</span><br><span class="line">	&#125; </span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> lg[maxn];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">	<span class="type">int</span> x,w;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">cmp</span><span class="params">(node x,node y)</span> </span>&#123;<span class="keyword">return</span> x.w&gt;y.w;&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">tree</span>&#123;</span><br><span class="line">	node e[maxn];</span><br><span class="line">	<span class="type">int</span> fa[maxn][<span class="number">21</span>],deep[maxn],w[maxn],dis[maxn],cnt,rk[maxn],Ans[maxn],g[maxn];</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> pre)</span> </span>&#123;</span><br><span class="line">		deep[x]=deep[pre]+<span class="number">1</span>;fa[x][<span class="number">0</span>]=pre;<span class="type">int</span> i;</span><br><span class="line">		<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=lg[deep[x]];i++) fa[x][i]=fa[fa[x][i<span class="number">-1</span>]][i<span class="number">-1</span>];</span><br><span class="line">		<span class="keyword">for</span> (i=h[x];i;i=a[i].z) <span class="keyword">if</span> (a[i].to^pre) &#123;</span><br><span class="line">			dis[a[i].to]=dis[x]+a[i].w;</span><br><span class="line">			<span class="built_in">dfs</span>(a[i].to,x);</span><br><span class="line">			<span class="keyword">if</span> (w[a[i].to]+a[i].w&gt;w[x]) g[x]=a[i].to,w[x]=w[a[i].to]+a[i].w; </span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> top[maxn];</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line">		top[x]=u;</span><br><span class="line">		<span class="keyword">if</span> (x==u) e[++cnt]=(node)&#123;x,w[x]+dis[x]-dis[fa[x][<span class="number">0</span>]]&#125;;</span><br><span class="line">		<span class="keyword">if</span> (g[x]) <span class="built_in">dfs2</span>(g[x],u);</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i=h[x];i;i=a[i].z) <span class="keyword">if</span> (a[i].to^fa[x][<span class="number">0</span>]&amp;&amp;a[i].to^g[x]) <span class="built_in">dfs2</span>(a[i].to,a[i].to);</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> rt)</span> </span>&#123;</span><br><span class="line">		<span class="type">int</span> i;</span><br><span class="line">		<span class="built_in">dfs</span>(rt,rt);</span><br><span class="line">		<span class="built_in">dfs2</span>(rt,rt);</span><br><span class="line">		<span class="built_in">sort</span>(e+<span class="number">1</span>,e+<span class="number">1</span>+cnt,cmp);</span><br><span class="line">		<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=cnt;i++) Ans[i]=Ans[i<span class="number">-1</span>]+e[i].w,rk[e[i].x]=i;</span><br><span class="line">		<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) rk[i]=rk[top[i]]; </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (rk[x]&lt;=k) <span class="keyword">return</span> Ans[<span class="built_in">min</span>(k,cnt)];</span><br><span class="line">		<span class="type">int</span> u=x,v=x,i;</span><br><span class="line">		<span class="keyword">for</span> (i=lg[deep[v]];i&gt;=<span class="number">0</span>;i--) <span class="keyword">if</span> (rk[fa[v][i]]&gt;k) v=fa[v][i]; </span><br><span class="line">		<span class="keyword">for</span> (i=lg[deep[u]];i&gt;=<span class="number">0</span>;i--) <span class="keyword">if</span> (rk[fa[u][i]]&gt;=k) u=fa[u][i];</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">max</span>(Ans[k<span class="number">-1</span>]+w[x]+dis[x]-dis[fa[u][<span class="number">0</span>]],Ans[k]+w[x]+dis[x]-w[fa[v][<span class="number">0</span>]]-dis[fa[v][<span class="number">0</span>]]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;t1,t2;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> i,x,y,z,rt1=<span class="number">0</span>,rt2=<span class="number">0</span>,q;</span><br><span class="line">	<span class="built_in">read</span>(n);<span class="built_in">read</span>(q);</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;n;i++) &#123;</span><br><span class="line">		<span class="built_in">read</span>(x),<span class="built_in">read</span>(y),<span class="built_in">read</span>(z);</span><br><span class="line">		a[++head].<span class="built_in">add</span>(x,y,z);</span><br><span class="line">		a[++head].<span class="built_in">add</span>(y,x,z);</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">2</span>;i&lt;=n;i++) lg[i]=lg[i/<span class="number">2</span>]+<span class="number">1</span>;</span><br><span class="line">	TD::<span class="built_in">init</span>(rt1,rt2);</span><br><span class="line">	t1.<span class="built_in">init</span>(rt1);t2.<span class="built_in">init</span>(rt2);</span><br><span class="line">	<span class="type">int</span> las=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (q--) &#123;</span><br><span class="line">		<span class="built_in">read</span>(x),<span class="built_in">read</span>(y);x=(x+las<span class="number">-1</span>)%n+<span class="number">1</span>;y=(y+las<span class="number">-1</span>)%n+<span class="number">1</span>;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,las=<span class="built_in">max</span>(t1.<span class="built_in">query</span>(x,<span class="number">2</span>*y<span class="number">-1</span>),t2.<span class="built_in">query</span>(x,<span class="number">2</span>*y<span class="number">-1</span>)));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>NOIP模拟赛</tag>
        <tag>dp</tag>
        <tag>容斥</tag>
        <tag>倍增</tag>
        <tag>平面图欧拉定理</tag>
      </tags>
  </entry>
  <entry>
    <title>ARC165E Random Isolation</title>
    <url>/2023/09/19/ARC165E-Random-Isolation/</url>
    <content><![CDATA[<h1 id="Random-Isolation"><a href="#Random-Isolation" class="headerlink" title="Random Isolation"></a>Random Isolation</h1><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>给定一颗 $n$ 个点的树，如果存在，则随机大于 $k$ 的连通块，随机选择连通块中的一个点，删掉这个点以及相邻的边。期望操作次数。</p>
<p>$k&lt;n\le 100$。2s。</p>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>根据期望的线性性，期望的操作次数为每个点期望的操作次数之和。考虑 $O(n)$ 枚举以每个点为根。</p>
<p>考虑树的一颗子图，子图的节点数为 $n$，相邻的节点数为 $m$，则到达这个子图的概率为 $\dfrac{1}{\dbinom{n+m}{n}}$。所以一个子图的概率只与 $n$ 和 $m$ 相关，类似于树上背包 dp。</p>
<p>这样做是 $O(n^5)$ 的，但观察到 $n+m\le$ 总节点个数，所以常数比较小。能过。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 205</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> put() putchar(<span class="string">&#x27;\n&#x27;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Tp template<span class="string">&lt;typename Ty&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Ts template<span class="string">&lt;typename Ty,typename... Ar&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">(<span class="type">int</span> &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> f=<span class="number">1</span>;x=<span class="number">0</span>;<span class="type">char</span> c=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (c&lt;<span class="string">&#x27;0&#x27;</span>||c&gt;<span class="string">&#x27;9&#x27;</span>) &#123;<span class="keyword">if</span> (c==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">-1</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span> (c&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;c&lt;=<span class="string">&#x27;9&#x27;</span>) &#123;x=x*<span class="number">10</span>+c-<span class="string">&#x27;0&#x27;</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> Debug&#123;</span><br><span class="line">	Tp <span class="type">void</span> _debug(<span class="type">char</span>* f,Ty t)&#123;cerr&lt;&lt;f&lt;&lt;<span class="string">&#x27;=&#x27;</span>&lt;&lt;t&lt;&lt;endl;&#125;</span><br><span class="line">	Ts <span class="type">void</span> _debug(<span class="type">char</span>* f,Ty x,Ar... y)&#123;<span class="keyword">while</span>(*f!=<span class="string">&#x27;,&#x27;</span>) cerr&lt;&lt;*f++;cerr&lt;&lt;<span class="string">&#x27;=&#x27;</span>&lt;&lt;x&lt;&lt;<span class="string">&quot;,&quot;</span>;_debug(f+<span class="number">1</span>,y...);&#125;</span><br><span class="line">	Tp ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; os,vector&lt;Ty&gt;&amp; V)&#123;os&lt;&lt;<span class="string">&quot;[&quot;</span>;<span class="keyword">for</span>(<span class="keyword">auto</span>&amp; vv:V) os&lt;&lt;vv&lt;&lt;<span class="string">&quot;,&quot;</span>;os&lt;&lt;<span class="string">&quot;]&quot;</span>;<span class="keyword">return</span> os;&#125;</span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> gdb(...) _debug((char*)#__VA_ARGS__,__VA_ARGS__)</span></span><br><span class="line">&#125;<span class="keyword">using</span> <span class="keyword">namespace</span> Debug;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mk make_pair</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">998244353</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">power</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y=mod<span class="number">-2</span>)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> sum=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (y) &#123;</span><br><span class="line">		<span class="keyword">if</span> (y&amp;<span class="number">1</span>) sum=sum*x%mod;</span><br><span class="line">		x=x*x%mod;y&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> suf[maxn],isuf[maxn];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">C</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> m)</span> </span>&#123;<span class="keyword">return</span> suf[n]*isuf[m]%mod*isuf[n-m]%mod;&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">iC</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> m)</span> </span>&#123;<span class="keyword">return</span> suf[m]*suf[n-m]%mod*isuf[n]%mod;&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> &amp;x,<span class="type">int</span> y)</span> </span>&#123;x=(x+y)%mod;&#125;</span><br><span class="line"><span class="type">int</span> n,m,ans,f[maxn][maxn][maxn],g[maxn][maxn],siz[maxn],inv[maxn];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;to[maxn];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> pre)</span> </span>&#123;</span><br><span class="line">	siz[x]=<span class="number">1</span>;</span><br><span class="line">	<span class="type">int</span> i,j,k,l,cnt=<span class="number">0</span>;</span><br><span class="line">	f[x][<span class="number">1</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> y:to[x]) <span class="keyword">if</span> (y^pre) &#123;</span><br><span class="line">		<span class="built_in">dfs</span>(y,x);</span><br><span class="line">		<span class="built_in">memset</span>(g,<span class="number">0</span>,<span class="built_in">sizeof</span>(g));</span><br><span class="line">		<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=siz[x];i++)</span><br><span class="line">			<span class="keyword">for</span> (j=<span class="number">0</span>;j&lt;=siz[x]-i;j++) &#123;</span><br><span class="line">				<span class="built_in">add</span>(g[i][j+<span class="number">1</span>],f[x][i][j]);</span><br><span class="line">				<span class="keyword">for</span> (k=<span class="number">1</span>;k&lt;=siz[y];k++)</span><br><span class="line">					<span class="keyword">for</span> (l=<span class="number">0</span>;l&lt;=siz[y]-k;l++) &#123;</span><br><span class="line">						<span class="built_in">add</span>(g[i+k][j+l],f[x][i][j]*f[y][k][l]);</span><br><span class="line">					&#125;	</span><br><span class="line">			&#125;</span><br><span class="line">		siz[x]+=siz[y];</span><br><span class="line">		<span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;=siz[x];i++) <span class="keyword">for</span> (j=<span class="number">0</span>;j&lt;=siz[x];j++) f[x][i][j]=g[i][j];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> i,j,k,x,y;<span class="type">double</span> tmp=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">read</span>(n);<span class="built_in">read</span>(m);</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;n;i++) &#123;</span><br><span class="line">		<span class="built_in">read</span>(x);<span class="built_in">read</span>(y);</span><br><span class="line">		to[x].<span class="built_in">push_back</span>(y);</span><br><span class="line">		to[y].<span class="built_in">push_back</span>(x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (inv[<span class="number">0</span>]=<span class="number">1</span>,i=<span class="number">1</span>;i&lt;=<span class="number">2</span>*n;i++) inv[i]=<span class="built_in">power</span>(i);</span><br><span class="line">	<span class="keyword">for</span> (suf[<span class="number">0</span>]=<span class="number">1</span>,i=<span class="number">1</span>;i&lt;=<span class="number">2</span>*n;i++) suf[i]=suf[i<span class="number">-1</span>]*i%mod;</span><br><span class="line">	isuf[<span class="number">2</span>*n]=<span class="built_in">power</span>(suf[<span class="number">2</span>*n]);</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">2</span>*n;i&gt;=<span class="number">1</span>;i--) isuf[i<span class="number">-1</span>]=isuf[i]*i%mod;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="built_in">memset</span>(f,<span class="number">0</span>,<span class="built_in">sizeof</span>(f));</span><br><span class="line">		<span class="built_in">dfs</span>(i,<span class="number">0</span>);</span><br><span class="line">		<span class="keyword">for</span> (j=m+<span class="number">1</span>;j&lt;=n;j++) <span class="keyword">for</span> (k=<span class="number">0</span>;k&lt;=n-j;k++) &#123;</span><br><span class="line">			<span class="built_in">add</span>(ans,<span class="built_in">iC</span>(j+k,j)*f[i][j][k]%mod*inv[j]%mod);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>dp</tag>
        <tag>期望</tag>
      </tags>
  </entry>
  <entry>
    <title>ARC166C LU RD Marking</title>
    <url>/2023/10/09/ARC166C-LU-RD-Marking/</url>
    <content><![CDATA[<h1 id="ARC166C-LU-x2F-RD-Marking"><a href="#ARC166C-LU-x2F-RD-Marking" class="headerlink" title="ARC166C LU&#x2F;RD Marking"></a>ARC166C LU&#x2F;RD Marking</h1><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p><a href="https://atcoder.jp/contests/arc166/tasks/arc166_c">https://atcoder.jp/contests/arc166/tasks/arc166_c</a></p>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>ARC 的 C 都不会了，丢人。写篇题解警戒自己。</p>
<p>观察到每条从左下到右上的对角折线是独立的。</p>
<p><img src="https://img.atcoder.jp/arc166/25192085101f6f5c7b5bd1b5d9ae1849.png"></p>
<p>然后对于长度为 $i$ 的折线，方案数 $f_i&#x3D;f_{i-1}+f_{i-2}$。</p>
<p>预处理，中间特判。</p>
<p><strong>总结：观察独立性质。</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 2000005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> put() putchar(<span class="string">&#x27;\n&#x27;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Tp template<span class="string">&lt;typename Ty&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Ts template<span class="string">&lt;typename Ty,typename... Ar&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">(<span class="type">int</span> &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> f=<span class="number">1</span>;x=<span class="number">0</span>;<span class="type">char</span> c=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (c&lt;<span class="string">&#x27;0&#x27;</span>||c&gt;<span class="string">&#x27;9&#x27;</span>) &#123;<span class="keyword">if</span> (c==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">-1</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span> (c&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;c&lt;=<span class="string">&#x27;9&#x27;</span>) &#123;x=x*<span class="number">10</span>+c-<span class="string">&#x27;0&#x27;</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> Debug&#123;</span><br><span class="line">	Tp <span class="type">void</span> _debug(<span class="type">char</span>* f,Ty t)&#123;cerr&lt;&lt;f&lt;&lt;<span class="string">&#x27;=&#x27;</span>&lt;&lt;t&lt;&lt;endl;&#125;</span><br><span class="line">	Ts <span class="type">void</span> _debug(<span class="type">char</span>* f,Ty x,Ar... y)&#123;<span class="keyword">while</span>(*f!=<span class="string">&#x27;,&#x27;</span>) cerr&lt;&lt;*f++;cerr&lt;&lt;<span class="string">&#x27;=&#x27;</span>&lt;&lt;x&lt;&lt;<span class="string">&quot;,&quot;</span>;_debug(f+<span class="number">1</span>,y...);&#125;</span><br><span class="line">	Tp ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; os,vector&lt;Ty&gt;&amp; V)&#123;os&lt;&lt;<span class="string">&quot;[&quot;</span>;<span class="keyword">for</span>(<span class="keyword">auto</span>&amp; vv:V) os&lt;&lt;vv&lt;&lt;<span class="string">&quot;,&quot;</span>;os&lt;&lt;<span class="string">&quot;]&quot;</span>;<span class="keyword">return</span> os;&#125;</span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> gdb(...) _debug((char*)#__VA_ARGS__,__VA_ARGS__)</span></span><br><span class="line">&#125;<span class="keyword">using</span> <span class="keyword">namespace</span> Debug;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mk make_pair</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">998244353</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">power</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y=mod<span class="number">-2</span>)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> sum=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (y) &#123;</span><br><span class="line">		<span class="keyword">if</span> (y&amp;<span class="number">1</span>) sum=sum*x%mod;</span><br><span class="line">		x=x*x%mod;y&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> f[maxn],g[maxn];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	f[<span class="number">0</span>]=<span class="number">1</span>;f[<span class="number">1</span>]=<span class="number">1</span>,f[<span class="number">2</span>]=<span class="number">2</span>;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">3</span>;i&lt;=<span class="number">2e6</span>;i++) f[i]=(f[i<span class="number">-1</span>]+f[i<span class="number">-2</span>])%mod;</span><br><span class="line">	<span class="keyword">for</span> (g[<span class="number">0</span>]=<span class="number">1</span>,i=<span class="number">2</span>;i&lt;=<span class="number">2e6</span>;i+=<span class="number">2</span>) g[i]=g[i<span class="number">-2</span>]*f[i]%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> n,m;</span><br><span class="line">	<span class="built_in">read</span>(n);<span class="built_in">read</span>(m);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,g[<span class="built_in">min</span>(n,m)*<span class="number">2</span>]*g[<span class="built_in">min</span>(n,m)*<span class="number">2</span>]%mod*<span class="built_in">power</span>(f[<span class="number">2</span>*<span class="built_in">min</span>(n,m)+<span class="number">1</span>],<span class="built_in">abs</span>(n-m))%mod);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">	<span class="built_in">init</span>();</span><br><span class="line">	<span class="type">int</span> T;<span class="built_in">read</span>(T);<span class="keyword">while</span> (T--) <span class="built_in">solve</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>dp</tag>
        <tag>组合</tag>
        <tag>计数</tag>
      </tags>
  </entry>
  <entry>
    <title>CF1009F</title>
    <url>/2022/06/29/CF1009F/</url>
    <content><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>给定一棵以 $1$ 为根，$n$ 个节点的树。设 $d(u,x)$ 为 $u$ 子树中到 $u$ 距离为 $x$ 的节点数。  </p>
<p>对于每个点，求一个最小的 $k$，使得 $d(u,k)$ 最大。</p>
<h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><p>令 $f_{i,j}$ 表示 $i$ 的子树中，$d(i,x)&#x3D;j$ 的个数。</p>
<p>容易想到 $f_{i,j}&#x3D;\sum f_{son,j-1}$</p>
<p>以深度为下标，考虑长链剖分优化。用指针写比较方便（似乎也比较快（？））</p>
<p>dp 代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> pre)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> i,j;</span><br><span class="line">	f[x][ans[x]=<span class="number">0</span>]=<span class="number">1</span>;<span class="comment">//初始化</span></span><br><span class="line">	<span class="keyword">if</span> (son[x]) f[son[x]]=f[x]+<span class="number">1</span>,<span class="built_in">solve</span>(son[x],x);<span class="comment">//继承</span></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span>;</span><br><span class="line">	ans[x]=ans[son[x]]+<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span> (f[x][ans[x]]&lt;=<span class="number">1</span>) ans[x]=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (i=h[x];i;i=a[i].z)</span><br><span class="line">	    <span class="keyword">if</span> (a[i].to!=pre&amp;&amp;a[i].to!=son[x]) &#123;</span><br><span class="line">	    	f[a[i].to]=id;id+=<span class="number">2</span>*d[a[i].to];<span class="comment">//分配内存</span></span><br><span class="line">	    	<span class="built_in">solve</span>(a[i].to,x);</span><br><span class="line">	    	<span class="keyword">for</span> (j=<span class="number">0</span>;j&lt;d[a[i].to];j++) &#123;</span><br><span class="line">	    		f[x][j+<span class="number">1</span>]+=f[a[i].to][j];<span class="comment">//暴力合并</span></span><br><span class="line">	    		<span class="keyword">if</span> (f[x][ans[x]]&lt;f[x][j+<span class="number">1</span>]||(j+<span class="number">1</span>&lt;=ans[x]&amp;&amp;f[x][ans[x]]==f[x][j+<span class="number">1</span>])) ans[x]=j+<span class="number">1</span>;<span class="comment">//更新答案</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="code"><a href="#code" class="headerlink" title="code"></a>code</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 1000005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> put() putchar(<span class="string">&#x27;\n&#x27;</span>)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(<span class="type">int</span> &amp;x)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> f=<span class="number">1</span>;x=<span class="number">0</span>;<span class="type">char</span> c=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span> (c&lt;<span class="string">&#x27;0&#x27;</span>||c&gt;<span class="string">&#x27;9&#x27;</span>) &#123;<span class="keyword">if</span> (c==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">-1</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">while</span> (c&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;c&lt;=<span class="string">&#x27;9&#x27;</span>) &#123;x=x*<span class="number">10</span>+c-<span class="string">&#x27;0&#x27;</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> son[maxn],d[maxn],head=<span class="number">1</span>,h[maxn];</span><br><span class="line"><span class="type">int</span> *f[maxn],stac[maxn*<span class="number">2</span>],n,*id=stac,ans[maxn];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">yyy</span>&#123;</span><br><span class="line">	<span class="type">int</span> to,z;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">		to=y;z=h[x];h[x]=head;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;a[maxn*<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> pre)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> i;d[x]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (i=h[x];i;i=a[i].z)</span><br><span class="line">	    <span class="keyword">if</span> (a[i].to^pre) &#123;</span><br><span class="line">	    	<span class="built_in">dfs1</span>(a[i].to,x);</span><br><span class="line">	    	<span class="keyword">if</span> (d[x]&lt;d[a[i].to]+<span class="number">1</span>) d[x]=d[a[i].to]+<span class="number">1</span>,son[x]=a[i].to;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> pre)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> i,j;</span><br><span class="line">	f[x][ans[x]=<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span> (son[x]) f[son[x]]=f[x]+<span class="number">1</span>,<span class="built_in">solve</span>(son[x],x);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span>;</span><br><span class="line">	ans[x]=ans[son[x]]+<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span> (f[x][ans[x]]&lt;=<span class="number">1</span>) ans[x]=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (i=h[x];i;i=a[i].z)</span><br><span class="line">	    <span class="keyword">if</span> (a[i].to!=pre&amp;&amp;a[i].to!=son[x]) &#123;</span><br><span class="line">	    	f[a[i].to]=id;id+=<span class="number">2</span>*d[a[i].to];</span><br><span class="line">	    	<span class="built_in">solve</span>(a[i].to,x);</span><br><span class="line">	    	<span class="keyword">for</span> (j=<span class="number">0</span>;j&lt;d[a[i].to];j++) &#123;</span><br><span class="line">	    		f[x][j+<span class="number">1</span>]+=f[a[i].to][j];</span><br><span class="line">	    		<span class="keyword">if</span> (f[x][ans[x]]&lt;f[x][j+<span class="number">1</span>]||(j+<span class="number">1</span>&lt;=ans[x]&amp;&amp;f[x][ans[x]]==f[x][j+<span class="number">1</span>])) ans[x]=j+<span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> i,x,y;</span><br><span class="line">	<span class="built_in">read</span>(n);</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;n;i++) &#123;</span><br><span class="line">		<span class="built_in">read</span>(x);<span class="built_in">read</span>(y);</span><br><span class="line">		a[++head].<span class="built_in">add</span>(x,y);</span><br><span class="line">		a[++head].<span class="built_in">add</span>(y,x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">dfs1</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">	f[<span class="number">1</span>]=id;id+=<span class="number">2</span>*d[<span class="number">1</span>];</span><br><span class="line">	<span class="built_in">solve</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans[i]);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>似乎也可以用 dsu on tree 。</p>
]]></content>
      <tags>
        <tag>dp</tag>
        <tag>长链剖分</tag>
        <tag>CF</tag>
      </tags>
  </entry>
  <entry>
    <title>CF1486F Pairs of Paths</title>
    <url>/2023/07/12/CF1486F-Pairs-of-Paths/</url>
    <content><![CDATA[<h2 id="CF1486F-Pairs-of-Paths"><a href="#CF1486F-Pairs-of-Paths" class="headerlink" title="CF1486F Pairs of Paths"></a>CF1486F Pairs of Paths</h2><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>给定一棵包含 $n$ 个节点（编号 $1$ 到 $n$），我们同时选定该树上的 $m$ 条简单路径，求多少对<strong>无序二元组</strong>满足两条路径有且仅有一个焦点。</p>
<p>$1\leq n,m\leq3\times10^5$</p>
<p>6s , 512MB</p>
<h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><p>先不考虑<strong>单独一个节点</strong>的路径。</p>
<p>考虑对某个节点分析，我们统计两条路径的产生贡献<strong>且交在这个节点上</strong>的数量，钦定这个节点为 $1$。</p>
<p>对于路径 $i$ ，$j$ 有两种情况：</p>
<ul>
<li>两者路径的 lca 都为 $i$，且四个端点<strong>分别</strong>处于 $i$ 的四个不同子树中。</li>
<li>一条路径的 lca 为 $i$，$j$ 的一端在 $i$ 的子树外，一端在不同于 $i$ 的两个端点所在的子树内。</li>
</ul>
<p>第一种情况用容斥计算。所有的 $-$ 至少一个端点在相同子树的个数 $+$ 两个端点都在相同子树中。</p>
<p>第二种情况也可以容斥。所有的 $-$ 一个端点相同的。</p>
<p>最后加上单独一个节点的路径。</p>
<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 300005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> put() putchar(<span class="string">&#x27;\n&#x27;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Tp template<span class="string">&lt;typename Ty&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Ts template<span class="string">&lt;typename Ty,typename... Ar&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(<span class="type">int</span> &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> f=<span class="number">1</span>;x=<span class="number">0</span>;<span class="type">char</span> c=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (c&lt;<span class="string">&#x27;0&#x27;</span>||c&gt;<span class="string">&#x27;9&#x27;</span>) &#123;<span class="keyword">if</span> (c==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">-1</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span> (c&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;c&lt;=<span class="string">&#x27;9&#x27;</span>) &#123;x=x*<span class="number">10</span>+c-<span class="string">&#x27;0&#x27;</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> Debug&#123;</span><br><span class="line">	Tp <span class="type">void</span> _debug(<span class="type">char</span>* f,Ty t)&#123;cerr&lt;&lt;f&lt;&lt;<span class="string">&#x27;=&#x27;</span>&lt;&lt;t&lt;&lt;endl;&#125;</span><br><span class="line">	Ts <span class="type">void</span> _debug(<span class="type">char</span>* f,Ty x,Ar... y)&#123;<span class="keyword">while</span>(*f!=<span class="string">&#x27;,&#x27;</span>) cerr&lt;&lt;*f++;cerr&lt;&lt;<span class="string">&#x27;=&#x27;</span>&lt;&lt;x&lt;&lt;<span class="string">&quot;,&quot;</span>;_debug(f+<span class="number">1</span>,y...);&#125;</span><br><span class="line">	Tp ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; os,vector&lt;Ty&gt;&amp; V)&#123;os&lt;&lt;<span class="string">&quot;[&quot;</span>;<span class="keyword">for</span>(<span class="keyword">auto</span>&amp; vv:V) os&lt;&lt;vv&lt;&lt;<span class="string">&quot;,&quot;</span>;os&lt;&lt;<span class="string">&quot;]&quot;</span>;<span class="keyword">return</span> os;&#125;</span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> gdb(...) _debug((char*)#__VA_ARGS__,__VA_ARGS__)</span></span><br><span class="line">&#125;<span class="keyword">using</span> <span class="keyword">namespace</span> Debug;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;to[maxn];</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> deep[maxn],fa[maxn],dfn[maxn],son[maxn],top[maxn],siz[maxn],times,id[maxn],pp[maxn];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> pre)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	deep[x]=deep[pre]+<span class="number">1</span>;fa[x]=pre;siz[x]=<span class="number">1</span>;son[x]=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> y:to[x]) <span class="keyword">if</span> (y^pre) &#123;</span><br><span class="line">		<span class="built_in">dfs</span>(y,x);</span><br><span class="line">		siz[x]+=siz[y];</span><br><span class="line">		<span class="keyword">if</span> (!son[x]||siz[son[x]]&lt;siz[y]) son[x]=y;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> pre,<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> i;top[x]=u;id[x]=++times;pp[times]=x;</span><br><span class="line">	<span class="keyword">if</span> (!son[x]) <span class="keyword">return</span> ;</span><br><span class="line">	<span class="built_in">dfs2</span>(son[x],x,u);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> y:to[x]) <span class="keyword">if</span> (y^pre&amp;&amp;y^son[x]) <span class="built_in">dfs2</span>(y,x,y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (top[x]^top[y]) &#123;</span><br><span class="line">		<span class="keyword">if</span> (deep[top[x]]&lt;deep[top[y]]) <span class="built_in">swap</span>(x,y);</span><br><span class="line">		x=fa[top[x]];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (deep[x]&lt;deep[y]) <span class="keyword">return</span> x;<span class="keyword">else</span> <span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">getk</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (deep[x]-deep[top[x]]+<span class="number">1</span>&lt;=k) k-=deep[x]-deep[top[x]]+<span class="number">1</span>,x=fa[top[x]];</span><br><span class="line">	<span class="keyword">return</span> pp[id[x]-k];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">	<span class="type">int</span> x,y,g,xx,yy;</span><br><span class="line">&#125;e[maxn];</span><br><span class="line">vector&lt;node&gt;O[maxn];</span><br><span class="line"><span class="type">int</span> d[maxn];</span><br><span class="line"><span class="type">int</span> t[maxn],total[maxn];</span><br><span class="line">ll ans;</span><br><span class="line">map&lt;ll,<span class="type">int</span>&gt;mp;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> pre)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> y:to[x]) <span class="keyword">if</span> (y^pre) <span class="built_in">solve</span>(y,x),d[x]+=d[y];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> tmp:O[x]) d[tmp.xx]--,d[tmp.yy]--;</span><br><span class="line">	<span class="type">int</span> nums=O[x].<span class="built_in">size</span>();</span><br><span class="line">	ans+=<span class="number">1ll</span>*d[x]*nums+<span class="number">1ll</span>*nums*(nums<span class="number">-1</span>)/<span class="number">2</span>;</span><br><span class="line">	ans+=<span class="number">1ll</span>*(d[x]+nums)*total[x]+<span class="number">1ll</span>*total[x]*(total[x]<span class="number">-1</span>)/<span class="number">2</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> tmp:O[x]) &#123;</span><br><span class="line">		t[tmp.xx]++,t[tmp.yy]++;</span><br><span class="line">		<span class="keyword">if</span> (tmp.xx&amp;&amp;tmp.yy) mp[<span class="number">1ll</span>*tmp.xx*(n+<span class="number">1</span>)+tmp.yy]++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> y:to[x]) <span class="keyword">if</span> (y^pre) ans-=<span class="number">1ll</span>*d[y]*t[y];</span><br><span class="line">	t[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line"> 	<span class="keyword">for</span> (<span class="keyword">auto</span> tmp:O[x]) &#123;</span><br><span class="line">		<span class="keyword">if</span> (t[tmp.xx]) ans-=<span class="number">1ll</span>*t[tmp.xx]*(t[tmp.xx]<span class="number">-1</span>)/<span class="number">2</span>,t[tmp.xx]=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span> (t[tmp.yy]) ans-=<span class="number">1ll</span>*t[tmp.yy]*(t[tmp.yy]<span class="number">-1</span>)/<span class="number">2</span>,t[tmp.yy]=<span class="number">0</span>;</span><br><span class="line">		ll now=<span class="number">1ll</span>*tmp.xx*(n+<span class="number">1</span>)+tmp.yy;</span><br><span class="line">		ans+=<span class="number">1ll</span>*mp[now]*(mp[now]<span class="number">-1</span>)/<span class="number">2</span>;mp[now]=<span class="number">0</span>;</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line"><span class="comment">//  freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);</span></span><br><span class="line">	<span class="type">int</span> i,x,y;</span><br><span class="line">	<span class="built_in">read</span>(n);</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;n;i++) <span class="built_in">read</span>(x),<span class="built_in">read</span>(y),to[x].<span class="built_in">push_back</span>(y),to[y].<span class="built_in">push_back</span>(x);</span><br><span class="line">	<span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">dfs2</span>(<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">read</span>(m);</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=m;i++) &#123;</span><br><span class="line">		<span class="built_in">read</span>(e[i].x),<span class="built_in">read</span>(e[i].y);</span><br><span class="line">		<span class="keyword">if</span> (e[i].x==e[i].y) &#123;total[e[i].x]++;<span class="keyword">continue</span>;&#125;</span><br><span class="line">		e[i].g=<span class="built_in">query</span>(e[i].x,e[i].y);</span><br><span class="line">		<span class="keyword">if</span> (e[i].x^e[i].g) e[i].xx=<span class="built_in">getk</span>(e[i].x,deep[e[i].x]-deep[e[i].g]<span class="number">-1</span>);</span><br><span class="line">		<span class="keyword">if</span> (e[i].y^e[i].g) e[i].yy=<span class="built_in">getk</span>(e[i].y,deep[e[i].y]-deep[e[i].g]<span class="number">-1</span>);</span><br><span class="line">		<span class="keyword">if</span> (e[i].xx&gt;e[i].yy) <span class="built_in">swap</span>(e[i].xx,e[i].yy);</span><br><span class="line">		d[e[i].x]++,d[e[i].y]++,d[e[i].g]-=<span class="number">2</span>;</span><br><span class="line">		O[e[i].g].<span class="built_in">push_back</span>(e[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">solve</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>容斥</tag>
        <tag>计数</tag>
      </tags>
  </entry>
  <entry>
    <title>CF1373F</title>
    <url>/2023/02/28/CF1373F/</url>
    <content><![CDATA[<p>Hall 定理的推论。</p>
<h3 id="题意："><a href="#题意：" class="headerlink" title="题意："></a>题意：</h3><p> $n$ 个城市，这 $n$个城市首尾相接形成一个环。每个城市需要 $a_i$ 个网络数量。$n$ 个网络基站，第 $i$ 个网络基站有 $b_i$ 的网络数量，可以给 $i$ 和 $i+1$ 提供 网络。（第 $n$ 个网络基站可以给第 $n$ 座城市和第 $1$ 座城市提供网络）。</p>
<p>判断能否使得所有的家庭都获得网络。</p>
<p>$n\le 10^6$</p>
<h3 id="Hall-定理的推论"><a href="#Hall-定理的推论" class="headerlink" title="Hall 定理的推论"></a>Hall 定理的推论</h3><p>Hall 定理可以用于点有权值的情况。左部点 $i$ 需要匹配 $a_i$ 个右部点，右部点 $i$ 需要匹配 $b_i$ 个左部点。<strong>匹配是可重复的。</strong>只需要将定理改写一下。其有完美匹配的充要条件为：<br>$$<br>\forall S\subseteq X,|\sum\limits_{x\in S}a_x|\le |\sum\limits_{y\in N(S)}b_y|<br>$$<br>证明可以将左部点 $i$ 拆成 $a_i$ 个点，右部点同样。发现此条件和原本的 Hall 定理是等价的。</p>
<h3 id="做法"><a href="#做法" class="headerlink" title="做法"></a>做法</h3><p>显然是个带权二分图求完美匹配的题。</p>
<p>考虑枚举城市的集合 $L$，如果 $L$ 不是一个连续的区间，判断其是否合法，与其中每个连续的区间分别同时满足判定的条件是等价的。</p>
<p>转化为对于任意区间 $[l,r]$ ，$\sum\limits_{i&#x3D;l}^r a_i\le \sum\limits_{i&#x3D;l-1}^rb_i$ 都成立。</p>
<p>前缀和+后缀最大值即可。题目要求为环的情况，断环为链。</p>
<h3 id="CODE"><a href="#CODE" class="headerlink" title="CODE"></a>CODE</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a[maxn],b[maxn],n,d[maxn],suf[maxn];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">solve</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> i,sum1=<span class="number">0</span>,sum2=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">read</span>(n);</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">read</span>(a[i]);</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">read</span>(b[i]),d[i]=a[i]-b[i],sum1+=d[i];</span><br><span class="line">	<span class="keyword">if</span> (sum1&gt;<span class="number">0</span>) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;NO&quot;</span>);</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) a[i+n]=a[i],b[i+n]=b[i];</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n*<span class="number">2</span>;i++) d[i]=d[i<span class="number">-1</span>]+b[i]-a[i];</span><br><span class="line">	<span class="keyword">for</span> (suf[n*<span class="number">2</span>+<span class="number">1</span>]=<span class="number">1e18</span>,i=n*<span class="number">2</span>;i&gt;=<span class="number">1</span>;i--) suf[i]=<span class="built_in">min</span>(suf[i+<span class="number">1</span>],d[i]);</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (suf[i+<span class="number">1</span>]-d[i]+b[i]&lt;<span class="number">0</span>) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;NO&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;YES&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





]]></content>
      <tags>
        <tag>Hall定理</tag>
        <tag>二分图</tag>
      </tags>
  </entry>
  <entry>
    <title>CF1267G Game Relics</title>
    <url>/2023/09/13/CF1267G-Game-Relics/</url>
    <content><![CDATA[<h1 id="Game-Relics"><a href="#Game-Relics" class="headerlink" title="Game Relics"></a>Game Relics</h1><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>真的好退役了&#x2F;kk</p>
<p>抽的期望价值是递增的。所以一个简单的策略是先抽后买。那么这些操作肯定有一个分界点。</p>
<p>令已经有了 $i$ 个物品，已有的物品买的价值和 $j$，考虑选下一个。抽的权值为 $\dfrac{x}{2}(\dfrac{n}{n-i}+1)$，买的平均价值为 $\dfrac{sum-j}{n-i}$。如果买的平均价值小于抽的期望价值，则开始买。观察到两者只与 $i$ 和权值和 $j$ 有关。令 $f_{i,j}$ 为到这个状态的概率。转化为求方案数，做背包，总方案数为 $\dbinom{n}{i}$ 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 105</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> put() putchar(<span class="string">&#x27;\n&#x27;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Tp template<span class="string">&lt;typename Ty&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Ts template<span class="string">&lt;typename Ty,typename... Ar&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">(<span class="type">int</span> &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> f=<span class="number">1</span>;x=<span class="number">0</span>;<span class="type">char</span> c=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (c&lt;<span class="string">&#x27;0&#x27;</span>||c&gt;<span class="string">&#x27;9&#x27;</span>) &#123;<span class="keyword">if</span> (c==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">-1</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span> (c&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;c&lt;=<span class="string">&#x27;9&#x27;</span>) &#123;x=x*<span class="number">10</span>+c-<span class="string">&#x27;0&#x27;</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> Debug&#123;</span><br><span class="line">	Tp <span class="type">void</span> _debug(<span class="type">char</span>* f,Ty t)&#123;cerr&lt;&lt;f&lt;&lt;<span class="string">&#x27;=&#x27;</span>&lt;&lt;t&lt;&lt;endl;&#125;</span><br><span class="line">	Ts <span class="type">void</span> _debug(<span class="type">char</span>* f,Ty x,Ar... y)&#123;<span class="keyword">while</span>(*f!=<span class="string">&#x27;,&#x27;</span>) cerr&lt;&lt;*f++;cerr&lt;&lt;<span class="string">&#x27;=&#x27;</span>&lt;&lt;x&lt;&lt;<span class="string">&quot;,&quot;</span>;_debug(f+<span class="number">1</span>,y...);&#125;</span><br><span class="line">	Tp ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; os,vector&lt;Ty&gt;&amp; V)&#123;os&lt;&lt;<span class="string">&quot;[&quot;</span>;<span class="keyword">for</span>(<span class="keyword">auto</span>&amp; vv:V) os&lt;&lt;vv&lt;&lt;<span class="string">&quot;,&quot;</span>;os&lt;&lt;<span class="string">&quot;]&quot;</span>;<span class="keyword">return</span> os;&#125;</span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> gdb(...) _debug((char*)#__VA_ARGS__,__VA_ARGS__)</span></span><br><span class="line">&#125;<span class="keyword">using</span> <span class="keyword">namespace</span> Debug;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mk make_pair</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">power</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y=mod<span class="number">-2</span>)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> sum=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (y) &#123;</span><br><span class="line">		<span class="keyword">if</span> (y&amp;<span class="number">1</span>) sum=sum*x%mod;</span><br><span class="line">		x=x*x%mod;y&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,m,a[maxn],sum;</span><br><span class="line"><span class="type">double</span> c[maxn][maxn], f[maxn][maxn*maxn],ans;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line"><span class="comment">//	freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);</span></span><br><span class="line">	<span class="type">int</span> i,j,k;</span><br><span class="line">	<span class="built_in">read</span>(n);<span class="built_in">read</span>(m);</span><br><span class="line">	c[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		c[i][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span> (j=<span class="number">1</span>;j&lt;=i;j++) c[i][j]=c[i<span class="number">-1</span>][j]+c[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	f[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="built_in">read</span>(a[i]);sum+=a[i];</span><br><span class="line">		<span class="keyword">for</span> (k=i;k&gt;=<span class="number">1</span>;k--)</span><br><span class="line">			<span class="keyword">for</span> (j=a[i];j&lt;=sum;j++)</span><br><span class="line">				f[k][j]+=f[k<span class="number">-1</span>][j-a[i]];</span><br><span class="line">	&#125;        </span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">		<span class="keyword">for</span> (j=<span class="number">0</span>;j&lt;=sum;j++) &#123;</span><br><span class="line">			ans+=<span class="built_in">min</span>(<span class="number">1.0</span>*(sum-j)/(n-i),<span class="number">1.0</span>*m/<span class="number">2</span>*(<span class="number">1.0</span>*n/(n-i)+<span class="number">1</span>))*f[i][j]/c[n][i];</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%.10lf&quot;</span>,ans);                                                                             </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



]]></content>
      <tags>
        <tag>dp</tag>
        <tag>期望</tag>
        <tag>贡献</tag>
      </tags>
  </entry>
  <entry>
    <title>CF1626F</title>
    <url>/2023/02/28/CF1626F/</url>
    <content><![CDATA[<h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><p>观察到 $k$ 很小，我们可以对值域按照模 $lcm(1,…,k)$ 进行分类。同一类的数进行相同操作，减掉的数的大小都是相同的。</p>
<p>令 $M&#x3D;lcm(1,…,k)$</p>
<p>根据期望的线性性，我们可以对每类数分别计算。</p>
<p>令 $f[i][j]$ 为进行了 $i$ 轮，选到 $j$ 这个数的概率。<br>$$<br>\begin{cases}f[i+1][j]+&#x3D;\dfrac{n-1}{n}\times f[i][j]\f[i+1][j-j\bmod i]+&#x3D;\dfrac{1}{n}\times f[i][j]\end{cases}<br>$$<br>累加答案，$\sum\limits_{1\le i\le k}\sum\limits_{0\le j&lt; M} f[i][j]\times j$</p>
<p>注意到最后一轮，模 $k$ 之后不再产生贡献。为了减少常数，$M&#x3D;lca(1,…,k-1)$ 即可。</p>
<h3 id="code"><a href="#code" class="headerlink" title="code"></a>code</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 13000005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> put() putchar(<span class="string">&#x27;\n&#x27;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Tp template<span class="string">&lt;typename Ty&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Ts template<span class="string">&lt;typename Ty,typename... Ar&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(<span class="type">int</span> &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> f=<span class="number">1</span>;x=<span class="number">0</span>;<span class="type">char</span> c=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (c&lt;<span class="string">&#x27;0&#x27;</span>||c&gt;<span class="string">&#x27;9&#x27;</span>) &#123;<span class="keyword">if</span> (c==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">-1</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span> (c&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;c&lt;=<span class="string">&#x27;9&#x27;</span>) &#123;x=x*<span class="number">10</span>+c-<span class="string">&#x27;0&#x27;</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> Debug&#123;</span><br><span class="line">	Tp <span class="type">void</span> _debug(<span class="type">char</span>* f,Ty t)&#123;cerr&lt;&lt;f&lt;&lt;<span class="string">&#x27;=&#x27;</span>&lt;&lt;t&lt;&lt;endl;&#125;</span><br><span class="line">	Ts <span class="type">void</span> _debug(<span class="type">char</span>* f,Ty x,Ar... y)&#123;<span class="keyword">while</span>(*f!=<span class="string">&#x27;,&#x27;</span>) cerr&lt;&lt;*f++;cerr&lt;&lt;<span class="string">&#x27;=&#x27;</span>&lt;&lt;x&lt;&lt;<span class="string">&quot;,&quot;</span>;_debug(f+<span class="number">1</span>,y...);&#125;</span><br><span class="line">	Tp ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; os,vector&lt;Ty&gt;&amp; V)&#123;os&lt;&lt;<span class="string">&quot;[&quot;</span>;<span class="keyword">for</span>(<span class="keyword">auto</span>&amp; vv:V) os&lt;&lt;vv&lt;&lt;<span class="string">&quot;,&quot;</span>;os&lt;&lt;<span class="string">&quot;]&quot;</span>;<span class="keyword">return</span> os;&#125;</span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> gdb(...) _debug((char*)#__VA_ARGS__,__VA_ARGS__)</span></span><br><span class="line">&#125;<span class="keyword">using</span> <span class="keyword">namespace</span> Debug;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">998244353</span>;</span><br><span class="line"><span class="type">int</span> base=<span class="number">720720</span>*<span class="number">17</span>;</span><br><span class="line"><span class="type">int</span> n,a[maxn],A,B,P,k,Invn;</span><br><span class="line"><span class="type">int</span> nums[maxn],f[<span class="number">2</span>][<span class="number">1000005</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">power</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> ans=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (y) &#123;</span><br><span class="line">		<span class="keyword">if</span> (y&amp;<span class="number">1</span>) ans=ans*x%mod;</span><br><span class="line">		x=x*x%mod;y&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> sum,ans,fn[<span class="number">20</span>];</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> i,j;</span><br><span class="line">	<span class="built_in">read</span>(n);<span class="built_in">read</span>(a[<span class="number">1</span>]);<span class="built_in">read</span>(A);<span class="built_in">read</span>(B);<span class="built_in">read</span>(k);<span class="built_in">read</span>(P);</span><br><span class="line">	<span class="keyword">for</span> (base=<span class="number">1</span>,fn[<span class="number">0</span>]=<span class="number">1</span>,i=<span class="number">1</span>;i&lt;k;i++) fn[i]=fn[i<span class="number">-1</span>]*n%mod,base=base/__gcd(i,base)*i;</span><br><span class="line">	Invn=<span class="built_in">power</span>(n,mod<span class="number">-2</span>);</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">2</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		a[i]=(a[i<span class="number">-1</span>]*A+B)%P;</span><br><span class="line">		sum=(sum+a[i]-a[i]%base)%mod;</span><br><span class="line">		f[<span class="number">1</span>][a[i]%base]=(f[<span class="number">1</span>][a[i]%base]+Invn)%mod;</span><br><span class="line">	&#125;</span><br><span class="line">	sum=(sum+a[<span class="number">1</span>]-a[<span class="number">1</span>]%base)*Invn%mod*k%mod;</span><br><span class="line">	ans=sum;</span><br><span class="line">	f[<span class="number">1</span>][a[<span class="number">1</span>]%base]=(f[<span class="number">1</span>][a[<span class="number">1</span>]%base]+Invn)%mod;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=k;i++) &#123;</span><br><span class="line">		<span class="type">int</span> now=i&amp;<span class="number">1</span>,pre=now^<span class="number">1</span>;</span><br><span class="line">		<span class="built_in">memset</span>(f[pre],<span class="number">0</span>,<span class="built_in">sizeof</span>(f[pre]));</span><br><span class="line">		<span class="keyword">for</span> (j=<span class="number">0</span>;j&lt;=base;j++) &#123;</span><br><span class="line">			f[pre][j]=(f[pre][j]+f[now][j]*(<span class="number">1</span>-Invn+mod))%mod;</span><br><span class="line">			f[pre][j-j%i]=(f[pre][j-j%i]+f[now][j]*Invn)%mod;</span><br><span class="line">			ans=(ans+f[now][j]*j%mod)%mod;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,(ans*<span class="built_in">power</span>(n,k))%mod);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>dp</tag>
        <tag>期望</tag>
      </tags>
  </entry>
  <entry>
    <title>CF1530H Turing&#39;s Award</title>
    <url>/2023/09/20/CF1530H-Turing-s-Award/</url>
    <content><![CDATA[<h1 id="Turing’s-Award"><a href="#Turing’s-Award" class="headerlink" title="Turing’s Award"></a>Turing’s Award</h1><p>7.13 模拟赛 T4</p>
<p><a href="https://www.luogu.com.cn/problem/CF1530H">https://www.luogu.com.cn/problem/CF1530H</a></p>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>覆盖很恶心，考虑倒序做。覆盖变成如果这个位置为空就一定要填，这个位置不为空则不操作。<strong>则加数操作一定在头尾。</strong></p>
<p>则第一个限制是 $a_n$ 一定在序列里。</p>
<p>发现当前序列只需要维护 LIS。但是 $a_n$ 一定要在序列里，<strong>所以要讨论一下 $a_n$ 在不在 LIS 中。码到最后别忘了！！！</strong></p>
<p>考虑如果当前已经有 $k$ 个数，上一个数加在序列的头部，如果再加一个数在头部没有限制；如果在尾部，则要满足 $j-i\ge k$。这是显然的。所以就可以转移了。</p>
<p>注意到序列是随机的，而一个**经典结论是：随机序列的 LIS 长度为 $O(\sqrt n)$**。可以把 LIS 长度放在状态之中。</p>
<p>令 $fl_{k,i}$ 表示当前 LIS 长度为 $k$，第 $k$ 个数为 $a_i$，$a_i$ 在 LIS 头部，尾部的最小值为 $fl_{k,i}$。$fr_{k,i}$ 表示 $a_i$ 在尾部，LIS 头部的最大值为 $fr_{k,i}$。</p>
<p>有转移:<br>$$<br>fl_{l+1,i}&#x3D;\min{[a_i&lt;a_j]f_{k,j},[fr_{k,j}&gt;a_i,j-i\ge k]a_j}<br>$$<br>$fr_{k,i}$ 同理。发现操作是前后缀最小值最大值，用树状数组优化一下。</p>
<p>复杂度 $O(n\sqrt n \log n)$。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 20005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> put() putchar(<span class="string">&#x27;\n&#x27;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Tp template<span class="string">&lt;typename Ty&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Ts template<span class="string">&lt;typename Ty,typename... Ar&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">(<span class="type">int</span> &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> f=<span class="number">1</span>;x=<span class="number">0</span>;<span class="type">char</span> c=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (c&lt;<span class="string">&#x27;0&#x27;</span>||c&gt;<span class="string">&#x27;9&#x27;</span>) &#123;<span class="keyword">if</span> (c==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">-1</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span> (c&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;c&lt;=<span class="string">&#x27;9&#x27;</span>) &#123;x=x*<span class="number">10</span>+c-<span class="string">&#x27;0&#x27;</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> Debug&#123;</span><br><span class="line">	Tp <span class="type">void</span> _debug(<span class="type">char</span>* f,Ty t)&#123;cerr&lt;&lt;f&lt;&lt;<span class="string">&#x27;=&#x27;</span>&lt;&lt;t&lt;&lt;endl;&#125;</span><br><span class="line">	Ts <span class="type">void</span> _debug(<span class="type">char</span>* f,Ty x,Ar... y)&#123;<span class="keyword">while</span>(*f!=<span class="string">&#x27;,&#x27;</span>) cerr&lt;&lt;*f++;cerr&lt;&lt;<span class="string">&#x27;=&#x27;</span>&lt;&lt;x&lt;&lt;<span class="string">&quot;,&quot;</span>;_debug(f+<span class="number">1</span>,y...);&#125;</span><br><span class="line">	Tp ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; os,vector&lt;Ty&gt;&amp; V)&#123;os&lt;&lt;<span class="string">&quot;[&quot;</span>;<span class="keyword">for</span>(<span class="keyword">auto</span>&amp; vv:V) os&lt;&lt;vv&lt;&lt;<span class="string">&quot;,&quot;</span>;os&lt;&lt;<span class="string">&quot;]&quot;</span>;<span class="keyword">return</span> os;&#125;</span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> gdb(...) _debug((char*)#__VA_ARGS__,__VA_ARGS__)</span></span><br><span class="line">&#125;<span class="keyword">using</span> <span class="keyword">namespace</span> Debug;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mk make_pair</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">power</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y=mod<span class="number">-2</span>)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> sum=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (y) &#123;</span><br><span class="line">		<span class="keyword">if</span> (y&amp;<span class="number">1</span>) sum=sum*x%mod;</span><br><span class="line">		x=x*x%mod;y&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> base=<span class="number">300</span>,inf=<span class="number">1e9</span>;</span><br><span class="line"><span class="type">int</span> fl[base+<span class="number">5</span>][maxn],fr[base+<span class="number">5</span>][maxn];</span><br><span class="line"><span class="type">int</span> a[maxn],ans,n;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">BITmin</span> &#123;</span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> lowbit(x) ((x)&amp;(-x))</span></span><br><span class="line">	<span class="type">int</span> f[maxn];</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;<span class="built_in">memset</span>(f,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(f));&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span> </span>&#123;<span class="keyword">for</span> (;x&lt;=n;x+=<span class="built_in">lowbit</span>(x)) f[x]=<span class="built_in">min</span>(f[x],y);&#125;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;<span class="type">int</span> sum=inf;<span class="keyword">for</span> (;x;x-=<span class="built_in">lowbit</span>(x)) sum=<span class="built_in">min</span>(sum,f[x]);<span class="keyword">return</span> sum;&#125;</span><br><span class="line">&#125;t1,t2;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">BITmax</span> &#123;</span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> lowbit(x) ((x)&amp;(-x))</span></span><br><span class="line">	<span class="type">int</span> f[maxn];</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;<span class="built_in">memset</span>(f,<span class="number">0</span>,<span class="built_in">sizeof</span>(f));&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span> </span>&#123;<span class="keyword">for</span> (;x&lt;=n;x+=<span class="built_in">lowbit</span>(x)) f[x]=<span class="built_in">max</span>(f[x],y);&#125;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;<span class="type">int</span> sum=<span class="number">0</span>;<span class="keyword">for</span> (;x;x-=<span class="built_in">lowbit</span>(x)) sum=<span class="built_in">max</span>(sum,f[x]);<span class="keyword">return</span> sum;&#125;</span><br><span class="line">&#125;t3,t4;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> i,j,k;ans=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">read</span>(n);</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">read</span>(a[i]);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;=n;i++) <span class="keyword">for</span> (j=<span class="number">1</span>;j&lt;=base;j++) fl[j][i]=inf,fr[j][i]=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) fl[<span class="number">2</span>][i]=fr[<span class="number">2</span>][i]=a[i];</span><br><span class="line">	<span class="keyword">for</span> (k=<span class="number">2</span>;k&lt;=base;k++) &#123;</span><br><span class="line">		t1.<span class="built_in">clear</span>(),t2.<span class="built_in">clear</span>(),t3.<span class="built_in">clear</span>(),t4.<span class="built_in">clear</span>();</span><br><span class="line">		<span class="keyword">for</span> (i=n<span class="number">-1</span>;i&gt;=<span class="number">1</span>;i--) &#123;</span><br><span class="line">			<span class="keyword">if</span> (fl[k][i+<span class="number">1</span>]&lt;=n) t1.<span class="built_in">add</span>(n-a[i+<span class="number">1</span>]+<span class="number">1</span>,fl[k][i+<span class="number">1</span>]);</span><br><span class="line">			<span class="keyword">if</span> (n-i&gt;=k&amp;&amp;fr[k][i+k]&gt;=<span class="number">1</span>) t1.<span class="built_in">add</span>(n-fr[k][i+k]+<span class="number">1</span>,a[i+k]);</span><br><span class="line">			<span class="keyword">if</span> (fr[k][i+<span class="number">1</span>]&gt;=<span class="number">1</span>) t3.<span class="built_in">add</span>(a[i+<span class="number">1</span>],fr[k][i+<span class="number">1</span>]);</span><br><span class="line">			<span class="keyword">if</span> (n-i&gt;=k&amp;&amp;fl[k][i+k]&lt;=n) t3.<span class="built_in">add</span>(fl[k][i+k],a[i+k]);</span><br><span class="line">			</span><br><span class="line">			fl[k+<span class="number">1</span>][i]=<span class="built_in">min</span>(t1.<span class="built_in">query</span>(n-a[i]),t2.<span class="built_in">query</span>(n-a[i]));</span><br><span class="line">			fr[k+<span class="number">1</span>][i]=<span class="built_in">max</span>(t3.<span class="built_in">query</span>(a[i]<span class="number">-1</span>),t4.<span class="built_in">query</span>(a[i]<span class="number">-1</span>));</span><br><span class="line">		&#125; </span><br><span class="line">		<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (<span class="number">1</span>&lt;=fl[k][i]&amp;&amp;fl[k][i]&lt;=n) &#123;</span><br><span class="line">				ans=<span class="built_in">max</span>(ans,k);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (<span class="number">1</span>&lt;=fr[k][i]&amp;&amp;fr[k][i]&lt;=n) &#123;</span><br><span class="line">				ans=<span class="built_in">max</span>(ans,k);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	ans--;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;=n;i++) <span class="keyword">for</span> (j=<span class="number">1</span>;j&lt;=base;j++) fl[j][i]=inf,fr[j][i]=<span class="number">0</span>;</span><br><span class="line">	fl[<span class="number">1</span>][n]=fr[<span class="number">1</span>][n]=a[n];</span><br><span class="line">	<span class="keyword">for</span> (k=<span class="number">1</span>;k&lt;=base;k++) &#123;</span><br><span class="line">		t1.<span class="built_in">clear</span>(),t2.<span class="built_in">clear</span>(),t3.<span class="built_in">clear</span>(),t4.<span class="built_in">clear</span>();</span><br><span class="line">		<span class="keyword">for</span> (i=n<span class="number">-1</span>;i&gt;=<span class="number">1</span>;i--) &#123;</span><br><span class="line">			<span class="keyword">if</span> (fl[k][i+<span class="number">1</span>]&lt;=n) t1.<span class="built_in">add</span>(n-a[i+<span class="number">1</span>]+<span class="number">1</span>,fl[k][i+<span class="number">1</span>]);</span><br><span class="line">			<span class="keyword">if</span> (n-i&gt;=k&amp;&amp;fr[k][i+k]&gt;=<span class="number">1</span>) t1.<span class="built_in">add</span>(n-fr[k][i+k]+<span class="number">1</span>,a[i+k]);</span><br><span class="line">			<span class="keyword">if</span> (fr[k][i+<span class="number">1</span>]&gt;=<span class="number">1</span>) t3.<span class="built_in">add</span>(a[i+<span class="number">1</span>],fr[k][i+<span class="number">1</span>]);</span><br><span class="line">			<span class="keyword">if</span> (n-i&gt;=k&amp;&amp;fl[k][i+k]&lt;=n) t3.<span class="built_in">add</span>(fl[k][i+k],a[i+k]);</span><br><span class="line">			</span><br><span class="line">			fl[k+<span class="number">1</span>][i]=<span class="built_in">min</span>(t1.<span class="built_in">query</span>(n-a[i]),t2.<span class="built_in">query</span>(n-a[i]));</span><br><span class="line">			fr[k+<span class="number">1</span>][i]=<span class="built_in">max</span>(t3.<span class="built_in">query</span>(a[i]<span class="number">-1</span>),t4.<span class="built_in">query</span>(a[i]<span class="number">-1</span>));</span><br><span class="line">		&#125; </span><br><span class="line">		<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (<span class="number">1</span>&lt;=fl[k][i]&amp;&amp;fl[k][i]&lt;=n) &#123;</span><br><span class="line">				ans=<span class="built_in">max</span>(ans,k);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (<span class="number">1</span>&lt;=fr[k][i]&amp;&amp;fr[k][i]&lt;=n) &#123;</span><br><span class="line">				ans=<span class="built_in">max</span>(ans,k);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> T;</span><br><span class="line">	<span class="built_in">read</span>(T);</span><br><span class="line">	<span class="keyword">while</span> (T--) <span class="built_in">solve</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>NOIP模拟赛</tag>
        <tag>dp</tag>
        <tag>随机</tag>
      </tags>
  </entry>
  <entry>
    <title>CF1634F</title>
    <url>/2022/10/19/CF1634F/</url>
    <content><![CDATA[<p>令 $C_i&#x3D;A_i-B_i$</p>
<p>因为加上斐波那契数列，我们定义差分数组 $D_i&#x3D;C_i-C_{i-1}-C_{i-2}$</p>
<p>如果在区间 $[l,r]$ 上操作，只需要 $D_l+&#x3D;1,D_{r+1}-&#x3D;f[r-l+1]-f[r-l],D_{r+2}-&#x3D;f[r-l+1]$</p>
<p>$A,B$ 相等等价于 $C$ 全为0，区间全为又等价为其差分数组 $D$ 全为 $0$ 。都是充要的。</p>
<p>只需要在更新 $D$ 的时候统计数组中 $0$ 的个数即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 300005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> put() putchar(<span class="string">&#x27;\n&#x27;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Tp template<span class="string">&lt;typename Ty&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Ts template<span class="string">&lt;typename Ty,typename... Ar&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(<span class="type">int</span> &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> f=<span class="number">1</span>;x=<span class="number">0</span>;<span class="type">char</span> c=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (c&lt;<span class="string">&#x27;0&#x27;</span>||c&gt;<span class="string">&#x27;9&#x27;</span>) &#123;<span class="keyword">if</span> (c==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">-1</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span> (c&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;c&lt;=<span class="string">&#x27;9&#x27;</span>) &#123;x=x*<span class="number">10</span>+c-<span class="string">&#x27;0&#x27;</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> Debug&#123;</span><br><span class="line">	Tp <span class="type">void</span> _debug(<span class="type">char</span>* f,Ty t)&#123;cerr&lt;&lt;f&lt;&lt;<span class="string">&#x27;=&#x27;</span>&lt;&lt;t&lt;&lt;endl;&#125;</span><br><span class="line">	Ts <span class="type">void</span> _debug(<span class="type">char</span>* f,Ty x,Ar... y)&#123;<span class="keyword">while</span>(*f!=<span class="string">&#x27;,&#x27;</span>) cerr&lt;&lt;*f++;cerr&lt;&lt;<span class="string">&#x27;=&#x27;</span>&lt;&lt;x&lt;&lt;<span class="string">&quot;,&quot;</span>;_debug(f+<span class="number">1</span>,y...);&#125;</span><br><span class="line">	Tp ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; os,vector&lt;Ty&gt;&amp; V)&#123;os&lt;&lt;<span class="string">&quot;[&quot;</span>;<span class="keyword">for</span>(<span class="keyword">auto</span>&amp; vv:V) os&lt;&lt;vv&lt;&lt;<span class="string">&quot;,&quot;</span>;os&lt;&lt;<span class="string">&quot;]&quot;</span>;<span class="keyword">return</span> os;&#125;</span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> gdb(...) _debug(#__VA_ARGS__,__VA_ARGS__)</span></span><br><span class="line">&#125;<span class="keyword">using</span> <span class="keyword">namespace</span> Debug;</span><br><span class="line"><span class="type">int</span> n,q,mod;</span><br><span class="line"><span class="type">int</span> d[maxn],f[maxn],a[maxn],b[maxn],num;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> now,<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (now&gt;n) <span class="keyword">return</span> ;</span><br><span class="line">	x=(x%mod+mod)%mod;</span><br><span class="line">	num-=(d[now]==<span class="number">0</span>);</span><br><span class="line">	d[now]=(d[now]+x)%mod;</span><br><span class="line">	num+=(d[now]==<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line"><span class="comment">//  freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);</span></span><br><span class="line">	<span class="type">int</span> i,l,r;<span class="type">char</span> ch;</span><br><span class="line">	<span class="built_in">read</span>(n);<span class="built_in">read</span>(q);<span class="built_in">read</span>(mod);</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">read</span>(a[i]);</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">read</span>(b[i]),a[i]=(a[i]-b[i]+mod)%mod;</span><br><span class="line">	d[<span class="number">1</span>]=a[<span class="number">1</span>];</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">2</span>;i&lt;=n;i++) d[i]=(a[i]-a[i<span class="number">-1</span>]-a[i<span class="number">-2</span>]+mod*<span class="number">2</span>)%mod;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) num+=(d[i]==<span class="number">0</span>);</span><br><span class="line">	f[<span class="number">1</span>]=f[<span class="number">2</span>]=<span class="number">1</span>;<span class="keyword">for</span> (i=<span class="number">3</span>;i&lt;=n;i++) f[i]=(f[i<span class="number">-1</span>]+f[i<span class="number">-2</span>])%mod; </span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=q;i++) &#123;</span><br><span class="line">		ch=<span class="built_in">getchar</span>();<span class="keyword">while</span> (ch!=<span class="string">&#x27;A&#x27;</span>&amp;&amp;ch!=<span class="string">&#x27;B&#x27;</span>) ch=<span class="built_in">getchar</span>();<span class="built_in">read</span>(l);<span class="built_in">read</span>(r);</span><br><span class="line">		<span class="keyword">if</span> (ch==<span class="string">&#x27;A&#x27;</span>) &#123;<span class="built_in">add</span>(l,<span class="number">1</span>);<span class="built_in">add</span>(r+<span class="number">1</span>,-f[r-l+<span class="number">1</span>]-f[r-l]+mod*<span class="number">2</span>);<span class="built_in">add</span>(r+<span class="number">2</span>,-f[r-l+<span class="number">1</span>]+mod);&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">add</span>(l,mod<span class="number">-1</span>),<span class="built_in">add</span>(r+<span class="number">1</span>,f[r-l+<span class="number">1</span>]+f[r-l]),<span class="built_in">add</span>(r+<span class="number">2</span>,f[r-l+<span class="number">1</span>]);</span><br><span class="line">		<span class="built_in">puts</span>(num==n?<span class="string">&quot;Yes&quot;</span>:<span class="string">&quot;No&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>CF</tag>
        <tag>差分</tag>
        <tag>斐波那契数列</tag>
      </tags>
  </entry>
  <entry>
    <title>CF1677D Tokitsukaze and Permutations</title>
    <url>/2023/08/22/CF1677D-Tokitsukaze-and-Permutations/</url>
    <content><![CDATA[<h1 id="Tokitsukaze-and-Permutations"><a href="#Tokitsukaze-and-Permutations" class="headerlink" title="Tokitsukaze and Permutations"></a>Tokitsukaze and Permutations</h1><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>有一个长度为 $n$ 的数组 $p$，将执行 $k$ 次操作。 </p>
<p>操作过程：对于 $[1,n]$ 中，当$ p_{i} &gt; p_{i+1}$，则交换 $p_{i}，p_{i+1}$。 </p>
<p>经过 $k$ 次操作之后，得到了一个新数组 $a$，再定义数组 $v$ 表示在 $[1,i-1]$ 中比 $a_{i}$ 大的个数。</p>
<p>现在给定 $v$，但是有可能其中的值为 $-1$，这表示它的值并不确定 。</p>
<p>求有多少种 $p$ 满足在 $k$ 次操作后得到的 $v$ 和给定确定值一致，结果取模 $998244353$。      </p>
<p>$1\le n\le 10^6$ 2s 250MB</p>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>大为震撼。</p>
<p>首先有一个结论 ：</p>
<ul>
<li>一个排列 $p$ 对应唯一的 $v$。</li>
</ul>
<p>如果一个 $v$ 是合法的，当且仅当 $v_i\in [0,i-1]$。</p>
<p>再考虑每次操作的本质，把 $v_i$ 整体向左移一位，高位补 $0$，其他位置 $v_i\gets \max(v_i-1,0)$。</p>
<p>所以操作 $k$ 次以后，末尾 $k$ 个数为 $0$，如果不是就输出 $0$。</p>
<p>对于 $i\in [1,n-k]$ 中，考虑对答案的贡献：</p>
<ul>
<li>如果 $v_i$ 为 $-1$ ，操作 $k$ 次之前 $v_{i+k}$ 也是不知道的，可以取 $[0,i+k-1]$。</li>
<li>如果 $v_i$ 为 $0$，操作 $k$ 次之前 $v_{i+k}\in[0,k]$。</li>
<li>如果 $v_i&gt;0$，操作 $k$ 次之前 $v_{i+k}&#x3D;v_i+k$。是确定的。</li>
</ul>
<p>所有贡献乘起来即可。</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> n,v[maxn],p[maxn],k;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">solve</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> i,ans=<span class="number">1</span>;</span><br><span class="line">	<span class="built_in">read</span>(n);<span class="built_in">read</span>(k);</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">read</span>(v[i]);</span><br><span class="line">	<span class="keyword">for</span> (i=n;i&gt;n-k;i--) <span class="keyword">if</span> (v[i]&gt;<span class="number">0</span>) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;0&quot;</span>),<span class="built_in">void</span>();</span><br><span class="line">	<span class="keyword">for</span> (i=n;i&gt;k;i--) </span><br><span class="line">		<span class="keyword">if</span> (v[i-k]==<span class="number">-1</span>) ans=ans*i%mod;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (v[i-k]==<span class="number">0</span>) ans=ans*(k+<span class="number">1</span>)%mod;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=k;i++) ans=ans*i%mod;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> T;</span><br><span class="line">	<span class="built_in">read</span>(T);</span><br><span class="line">	<span class="keyword">while</span> (T--) <span class="built_in">solve</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>计数</tag>
      </tags>
  </entry>
  <entry>
    <title>CF1670F Jee, You See</title>
    <url>/2023/07/14/CF1670F-Jee-You-See/</url>
    <content><![CDATA[<h2 id="CF1670F-Jee-You-See"><a href="#CF1670F-Jee-You-See" class="headerlink" title="CF1670F Jee, You See?"></a>CF1670F Jee, You See?</h2><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>给定 4 个整数 $n,l,r,z$ $1 \le n \le 1000,1 \le l \le r \le 10^{18},1 \le z \le 10^{18}$</p>
<p>求满足一下条件的序列 $a$ 的个数：</p>
<ol>
<li>$a_i$ 为非负整数</li>
<li>$l \le a_1 + a_2 + \dots a_n \le r $</li>
<li>$a_1 \oplus a_2 \oplus \dots \oplus a_n &#x3D; z$</li>
</ol>
<p>其中 $\oplus$ 表示二进制按位异或运算</p>
<p>答案对 $10^9 + 7$ 取模</p>
<p>2s 250MB</p>
<h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><p>令 $\sum a_i\le r$ 且符合题意的个数为 $G(r)$ ，则答案为 $G(r)-G(l-1)$。转化为求 $1\le \sum a_i\le r$ 的个数。</p>
<p>考虑数位 dp ，令 $f[i][j]$ 表示从低到高第 $i$ 位，还能以 $2^i\times j$ 填剩下的位数。</p>
<p>令 $x&#x3D;2j+\text{[n第 i 位为1]}$，转移是 $f[i][x-t]\Leftarrow f[i+1][j]\dbinom{n}{t}$</p>
<p>考虑到从低到高第 $i$ 位之和最大只有 $(2^i-1)n$，所以第二位最大只有 $n$。</p>
<p>转移的时候考虑一下 $z$ 的限制即可。</p>
<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> put() putchar(<span class="string">&#x27;\n&#x27;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Tp template<span class="string">&lt;typename Ty&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Ts template<span class="string">&lt;typename Ty,typename... Ar&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(<span class="type">int</span> &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> f=<span class="number">1</span>;x=<span class="number">0</span>;<span class="type">char</span> c=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (c&lt;<span class="string">&#x27;0&#x27;</span>||c&gt;<span class="string">&#x27;9&#x27;</span>) &#123;<span class="keyword">if</span> (c==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">-1</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span> (c&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;c&lt;=<span class="string">&#x27;9&#x27;</span>) &#123;x=x*<span class="number">10</span>+c-<span class="string">&#x27;0&#x27;</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> Debug&#123;</span><br><span class="line">	Tp <span class="type">void</span> _debug(<span class="type">char</span>* f,Ty t)&#123;cerr&lt;&lt;f&lt;&lt;<span class="string">&#x27;=&#x27;</span>&lt;&lt;t&lt;&lt;endl;&#125;</span><br><span class="line">	Ts <span class="type">void</span> _debug(<span class="type">char</span>* f,Ty x,Ar... y)&#123;<span class="keyword">while</span>(*f!=<span class="string">&#x27;,&#x27;</span>) cerr&lt;&lt;*f++;cerr&lt;&lt;<span class="string">&#x27;=&#x27;</span>&lt;&lt;x&lt;&lt;<span class="string">&quot;,&quot;</span>;_debug(f+<span class="number">1</span>,y...);&#125;</span><br><span class="line">	Tp ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; os,vector&lt;Ty&gt;&amp; V)&#123;os&lt;&lt;<span class="string">&quot;[&quot;</span>;<span class="keyword">for</span>(<span class="keyword">auto</span>&amp; vv:V) os&lt;&lt;vv&lt;&lt;<span class="string">&quot;,&quot;</span>;os&lt;&lt;<span class="string">&quot;]&quot;</span>;<span class="keyword">return</span> os;&#125;</span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> gdb(...) _debug((char*)#__VA_ARGS__,__VA_ARGS__)</span></span><br><span class="line">&#125;<span class="keyword">using</span> <span class="keyword">namespace</span> Debug;</span><br><span class="line"><span class="type">int</span> n,L,R,z;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">int</span> dp[<span class="number">65</span>][<span class="number">1005</span>],c[<span class="number">1005</span>][<span class="number">1005</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> &amp;x,<span class="type">int</span> y)</span> </span>&#123;x=(x+y)%mod;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> m)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> i,j,t;</span><br><span class="line">	<span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="built_in">sizeof</span>(dp));</span><br><span class="line">	dp[<span class="number">63</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (j=<span class="number">62</span>;j&gt;=<span class="number">0</span>;j--) &#123;</span><br><span class="line">		<span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;=n;i++) &#123;</span><br><span class="line">			<span class="type">int</span> now=<span class="number">2</span>*i+(m&gt;&gt;j)%<span class="number">2</span>;</span><br><span class="line">			<span class="keyword">for</span> (t=(z&gt;&gt;j)%<span class="number">2</span>;t&lt;=<span class="built_in">min</span>(now,n);t+=<span class="number">2</span>)</span><br><span class="line">				<span class="built_in">add</span>(dp[j][<span class="built_in">min</span>(now-t,n)],dp[j+<span class="number">1</span>][i]*c[n][t]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;=n;i++) <span class="built_in">add</span>(ans,dp[<span class="number">0</span>][i]);</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> i,j;</span><br><span class="line">	<span class="built_in">read</span>(n);<span class="built_in">read</span>(L);<span class="built_in">read</span>(R);<span class="built_in">read</span>(z);</span><br><span class="line">	c[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		c[i][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span> (j=<span class="number">1</span>;j&lt;=i;j++) c[i][j]=(c[i<span class="number">-1</span>][j]+c[i<span class="number">-1</span>][j<span class="number">-1</span>])%mod;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,(<span class="built_in">solve</span>(R)-<span class="built_in">solve</span>(L<span class="number">-1</span>)+mod)%mod);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





]]></content>
      <tags>
        <tag>数位dp</tag>
      </tags>
  </entry>
  <entry>
    <title>CF1707D Partial Virtual Tree</title>
    <url>/2023/08/30/CF1707D-Partial-Virtual-Tree/</url>
    <content><![CDATA[<h1 id="CF1707D-Partial-Virtual-Trees"><a href="#CF1707D-Partial-Virtual-Trees" class="headerlink" title="CF1707D Partial Virtual Trees"></a>CF1707D Partial Virtual Trees</h1><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p><a href="https://www.luogu.com.cn/problem/CF1707D">https://www.luogu.com.cn/problem/CF1707D</a></p>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>学到容斥了，感觉妙妙。</p>
<p>感觉这个 $S_i\not &#x3D; S_{i+1}$ 很烦，考虑容斥，令 $g_i$ 表示答案序列，$f_i$ 表示不考虑 $S_i\not &#x3D; S_{i+1}$ 的限制，结尾为 ${1}$，且满足题目限制的方案数。</p>
<p>有 $f_i&#x3D;\sum\limits_{j\le i} \dbinom{i}{j} g_j$，根据二项式反演，有 $g_i&#x3D;\sum\limits_{j\le i} (-1)^{i-j}\dbinom{i}{j}f_i$ 。只需要求出 $f$ 即可。</p>
<p>令 $f_{i,j}$ 表示时刻 $j$ 在 $i$ 的子树中仍然有点被选中的方案数。如果一个点有至少两个互不相同的子树中存在被选中的点，那么这个点一定要被选中。否则随便。</p>
<p>分两种情况考虑：</p>
<ul>
<li><p>$i$ 在集合中</p>
<p>则子树的内可以任意选。<br>$$<br>f_{i,j}&#x3D;\prod\limits_{y\in son_i} \sum\limits_{k\le j} f_{y,j}<br>$$<br>令 $s_{y,j}&#x3D;\sum\limits_{k\le j} f_{y,k}$，前缀和优化一下是简单的。</p>
</li>
<li><p>$i$ 不在集合中</p>
<p>则枚举 $i$ 在 $p$ 到 $p+1$ 的时间熄灭。<br>$$<br>f_{i,j}&#x3D;\sum_{p&lt;j}\sum_{x\in son_i} f_{x,j}\prod_{y\in son_i,y\not &#x3D; x} s_{y,p}<br>$$<br>预处理一些东西，前后缀积什么的，可以做到全局 $O(n^2)$。</p>
</li>
</ul>
<p>注意最后一个集合一定为 ${1}$。需要特判一下。</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 2005</span></span><br><span class="line"><span class="type">int</span> mod;</span><br><span class="line"><span class="type">int</span> c[maxn][maxn];</span><br><span class="line"><span class="type">int</span> n,dp[maxn][maxn],s[maxn][maxn],fs[maxn][maxn],fp[maxn][maxn],ft[maxn],g[maxn],o[maxn];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;to[maxn];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> &amp;x,<span class="type">int</span> y)</span> </span>&#123;x=(x+y)%mod;&#125;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> id=<span class="number">1</span>; </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> pre)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> i,j,y;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> y:to[x]) <span class="keyword">if</span> (y^pre) <span class="built_in">solve</span>(y,x);</span><br><span class="line">	<span class="keyword">for</span> (j=<span class="number">0</span>;j&lt;=n;j++) dp[x][j]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span> (x!=id) &#123;</span><br><span class="line">		<span class="type">int</span> nums=to[x].<span class="built_in">size</span>(),tot=<span class="number">-1</span>;</span><br><span class="line">		<span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;nums;i++) </span><br><span class="line">			<span class="keyword">if</span> ((y=to[x][i])^pre) &#123;</span><br><span class="line">				o[y]=++tot;</span><br><span class="line">				<span class="keyword">for</span> (j=<span class="number">1</span>;j&lt;=n;j++) dp[x][j]=dp[x][j]*s[y][j]%mod;</span><br><span class="line">				<span class="keyword">for</span> (j=<span class="number">0</span>;j&lt;=n;j++) &#123;</span><br><span class="line">					<span class="keyword">if</span> (tot&gt;<span class="number">0</span>) fs[tot][j]=fs[tot<span class="number">-1</span>][j]*s[y][j]%mod;</span><br><span class="line">					<span class="keyword">else</span> fs[tot][j]=s[y][j];</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		<span class="keyword">for</span> (i=nums<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--) <span class="keyword">if</span> ((y=to[x][i])^pre) &#123;</span><br><span class="line">			<span class="keyword">for</span> (j=<span class="number">0</span>;j&lt;=n;j++) </span><br><span class="line">				<span class="keyword">if</span> (o[y]&lt;tot) fp[o[y]][j]=fp[o[y]+<span class="number">1</span>][j]*s[y][j]%mod;</span><br><span class="line">				<span class="keyword">else</span> fp[o[y]][j]=s[y][j]; </span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> y:to[x]) <span class="keyword">if</span> (y^pre) &#123;</span><br><span class="line">			<span class="keyword">for</span> (j=<span class="number">0</span>;j&lt;=n;j++) ft[j]=(o[y]?fs[o[y]<span class="number">-1</span>][j]:<span class="number">1</span>)*(o[y]&lt;tot?fp[o[y]+<span class="number">1</span>][j]:<span class="number">1</span>)%mod;</span><br><span class="line">			<span class="keyword">for</span> (j=<span class="number">1</span>;j&lt;=n;j++) <span class="built_in">add</span>(ft[j],ft[j<span class="number">-1</span>]),<span class="built_in">add</span>(dp[x][j],dp[y][j]*ft[j<span class="number">-1</span>]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> y:to[x]) <span class="keyword">if</span> (y^pre) &#123;</span><br><span class="line">			<span class="keyword">for</span> (j=<span class="number">1</span>;j&lt;=n;j++) dp[x][j]=dp[x][j]*s[y][j<span class="number">-1</span>]%mod;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	s[x][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (j=<span class="number">1</span>;j&lt;=n;j++) <span class="built_in">add</span>(s[x][j],s[x][j<span class="number">-1</span>]+dp[x][j]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line"><span class="comment">//	freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);</span></span><br><span class="line">	<span class="type">int</span> i,j,x,y;</span><br><span class="line">	<span class="built_in">read</span>(n);<span class="built_in">read</span>(mod);</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		c[i][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span> (j=<span class="number">1</span>;j&lt;=i;j++) c[i][j]=(c[i<span class="number">-1</span>][j<span class="number">-1</span>]+c[i<span class="number">-1</span>][j])%mod;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) dp[i][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;n;i++) &#123;</span><br><span class="line">		<span class="built_in">read</span>(x),<span class="built_in">read</span>(y);</span><br><span class="line">		to[x].<span class="built_in">push_back</span>(y);</span><br><span class="line">		to[y].<span class="built_in">push_back</span>(x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">solve</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">		<span class="keyword">for</span> (j=<span class="number">1</span>;j&lt;=i;j++) &#123;</span><br><span class="line">			<span class="type">int</span> sum=c[i][j]*dp[id][j]%mod;</span><br><span class="line">			<span class="keyword">if</span> ((i-j)%<span class="number">2</span>==<span class="number">0</span>) <span class="built_in">add</span>(g[i],sum);</span><br><span class="line">			<span class="keyword">else</span> <span class="built_in">add</span>(g[i],mod-sum);</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;n;i++) <span class="built_in">printf</span>(<span class="string">&quot;%lld &quot;</span>,g[i]);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>dp</tag>
        <tag>容斥</tag>
        <tag>计数</tag>
      </tags>
  </entry>
  <entry>
    <title>CF1792E</title>
    <url>/2023/02/28/CF1792E/</url>
    <content><![CDATA[<h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><p>先考虑直接求出 $m1\times m2$ 的所有因子。个数是 $O(n^{\frac{1}{3}})$ 级别的。</p>
<p>然后对每个因子考虑直接求出答案。直接求最小值是很难的，所以我们可以考虑求出一个数 $\le n$ 的最大因数 $f(x)$。$x&#x2F;f(x)$ 即为答案。</p>
<p>考虑转移：<br>$$<br>f(x)&#x3D;\max\limits_{p|x} f(x&#x2F;p)<br>$$<br>其中 $p$ 是 $x$ 的一个质因数。 </p>
<p>初始化：<br>$$<br>f(x)&#x3D;x[x\le n]<br>$$</p>
<h3 id="CODE"><a href="#CODE" class="headerlink" title="CODE"></a>CODE</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 2000005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> put() putchar(<span class="string">&#x27;\n&#x27;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Tp template<span class="string">&lt;typename Ty&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Ts template<span class="string">&lt;typename Ty,typename... Ar&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(<span class="type">int</span> &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> f=<span class="number">1</span>;x=<span class="number">0</span>;<span class="type">char</span> c=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (c&lt;<span class="string">&#x27;0&#x27;</span>||c&gt;<span class="string">&#x27;9&#x27;</span>) &#123;<span class="keyword">if</span> (c==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">-1</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span> (c&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;c&lt;=<span class="string">&#x27;9&#x27;</span>) &#123;x=x*<span class="number">10</span>+c-<span class="string">&#x27;0&#x27;</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> Debug&#123;</span><br><span class="line">	Tp <span class="type">void</span> _debug(<span class="type">char</span>* f,Ty t)&#123;cerr&lt;&lt;f&lt;&lt;<span class="string">&#x27;=&#x27;</span>&lt;&lt;t&lt;&lt;endl;&#125;</span><br><span class="line">	Ts <span class="type">void</span> _debug(<span class="type">char</span>* f,Ty x,Ar... y)&#123;<span class="keyword">while</span>(*f!=<span class="string">&#x27;,&#x27;</span>) cerr&lt;&lt;*f++;cerr&lt;&lt;<span class="string">&#x27;=&#x27;</span>&lt;&lt;x&lt;&lt;<span class="string">&quot;,&quot;</span>;_debug(f+<span class="number">1</span>,y...);&#125;</span><br><span class="line">	Tp ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; os,vector&lt;Ty&gt;&amp; V)&#123;os&lt;&lt;<span class="string">&quot;[&quot;</span>;<span class="keyword">for</span>(<span class="keyword">auto</span>&amp; vv:V) os&lt;&lt;vv&lt;&lt;<span class="string">&quot;,&quot;</span>;os&lt;&lt;<span class="string">&quot;]&quot;</span>;<span class="keyword">return</span> os;&#125;</span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> gdb(...) _debug((char*)#__VA_ARGS__,__VA_ARGS__)</span></span><br><span class="line">&#125;<span class="keyword">using</span> <span class="keyword">namespace</span> Debug;</span><br><span class="line"><span class="type">int</span> T,m1,m2,n;</span><br><span class="line"><span class="type">int</span> a[maxn];</span><br><span class="line"><span class="type">int</span> d1[maxn],d2[maxn],dp[maxn],prime[maxn];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">solve</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> i,j,k,tot1=<span class="number">0</span>,tot2=<span class="number">0</span>,cnt=<span class="number">0</span>,ans1=<span class="number">0</span>,ans2=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">read</span>(n);<span class="built_in">read</span>(m1);<span class="built_in">read</span>(m2);</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i*i&lt;=m1;i++) <span class="keyword">if</span> (m1%i==<span class="number">0</span>) d1[++tot1]=i,d1[++tot1]=m1/i;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i*i&lt;=m2;i++) <span class="keyword">if</span> (m2%i==<span class="number">0</span>) d2[++tot2]=i,d2[++tot2]=m2/i;</span><br><span class="line">	</span><br><span class="line">	<span class="type">int</span> now=m1,nums=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">2</span>;i*i&lt;=m1;i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (now%i==<span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">while</span> (now%i==<span class="number">0</span>) now/=i;</span><br><span class="line">			prime[++nums]=i;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (now&gt;<span class="number">1</span>) prime[++nums]=now;</span><br><span class="line">	now=m2;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">2</span>;i*i&lt;=m2;i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (now%i==<span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">while</span> (now%i==<span class="number">0</span>) now/=i;</span><br><span class="line">			prime[++nums]=i;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (now&gt;<span class="number">1</span>) prime[++nums]=now;</span><br><span class="line">	<span class="built_in">sort</span>(prime+<span class="number">1</span>,prime+<span class="number">1</span>+nums);</span><br><span class="line">	nums=<span class="built_in">unique</span>(prime+<span class="number">1</span>,prime+<span class="number">1</span>+nums)-prime<span class="number">-1</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=tot1;i++)</span><br><span class="line">		<span class="keyword">for</span> (j=<span class="number">1</span>;j&lt;=tot2;j++) </span><br><span class="line">			a[++cnt]=d1[i]*d2[j];</span><br><span class="line">	<span class="built_in">sort</span>(a+<span class="number">1</span>,a+<span class="number">1</span>+cnt);</span><br><span class="line">	cnt=<span class="built_in">unique</span>(a+<span class="number">1</span>,a+<span class="number">1</span>+cnt)-a<span class="number">-1</span>;</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=cnt;i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (a[i]&lt;=n) dp[i]=a[i];<span class="keyword">else</span> &#123;</span><br><span class="line">			dp[i]=<span class="number">0</span>;</span><br><span class="line">			<span class="keyword">for</span> (j=<span class="number">1</span>;j&lt;=nums;j++) <span class="keyword">if</span> (a[i]%prime[j]==<span class="number">0</span>) dp[i]=<span class="built_in">max</span>(dp[i],dp[<span class="built_in">lower_bound</span>(a+<span class="number">1</span>,a+<span class="number">1</span>+cnt,a[i]/prime[j])-a]);	</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (dp[i]&amp;&amp;a[i]/dp[i]&lt;=n) ans1++,ans2^=(a[i]/dp[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld %lld\n&quot;</span>,ans1,ans2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">	<span class="built_in">read</span>(T);<span class="keyword">while</span> (T--) <span class="built_in">solve</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>dp</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>CF1830D Mex Tree</title>
    <url>/2023/08/24/CF1830D-Mex-Tree/</url>
    <content><![CDATA[<h1 id="CF1830D-Mex-Tree"><a href="#CF1830D-Mex-Tree" class="headerlink" title="CF1830D Mex Tree"></a>CF1830D Mex Tree</h1><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>给定一棵 $n$ 个结点的树，点有点权，点权为 0 或 1。你需要给一种指定点权的方案，使得每一条路径的点权 $\operatorname{mex}$ 之和最大。</p>
<p>$n\le 2\times 10^5$，多组数据。</p>
<p>3s , 250MB</p>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>显然答案的上界是所有点对的贡献都是 $2$，上界为 $n(n+1)$ 。</p>
<p>有一种显然的构造方法，黑白交替染色，答案的下界是 $n(n+1)-n-\sum[p_i&#x3D;1]$。</p>
<p>考虑计算贡献差 $2$ 的最小值。</p>
<p>而贡献不为 $2$ 的点对都是在同色的连通块中。颜色为 $c$，大小为 $k$ 的同色极大连通块的贡献为 $(c+1)k(k+1)&#x2F;2$。</p>
<p>那么就可以 $dp$ 了。令 $f_{x,j,0&#x2F;1}$ 表示在 $x$ 的子树内，颜色为 $0&#x2F;1$，当前的极大连通块大小为 $j$。这是好转移的。但是状态大小是 $O(n^2)$ 的，有点愚蠢。</p>
<p>考虑优化掉无效状态。因为已经构造出一种黑白交替的方案，最多只会减 $2n$。而一个连通块的贡献是 $O(n^2)$ 级别的，所以 $dp$ 的第二维只需要开 $\sqrt n$。这样的时间复杂度参考树上背包，是 $O(n\sqrt n) $。</p>
<p>但是如果数组直接开这么大也会 GG。考虑用动态数组。转移完以后用 <code>shrink_to_fit()</code> 清空内存。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 200005</span></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;to[maxn];</span><br><span class="line"><span class="type">int</span> siz[maxn];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;f[maxn][<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> K,g[<span class="number">505</span>][<span class="number">2</span>];</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf=<span class="number">1e9</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> pre)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> i,j;siz[x]=<span class="number">1</span>;</span><br><span class="line">	f[x][<span class="number">0</span>].<span class="built_in">pb</span>(inf),f[x][<span class="number">1</span>].<span class="built_in">pb</span>(inf),f[x][<span class="number">0</span>].<span class="built_in">pb</span>(<span class="number">1</span>),f[x][<span class="number">1</span>].<span class="built_in">pb</span>(<span class="number">2</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> y:to[x]) <span class="keyword">if</span> (y^pre) &#123;</span><br><span class="line">		<span class="built_in">dfs</span>(y,x);</span><br><span class="line">		<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=<span class="built_in">min</span>(K,siz[x]+siz[y]);i++) g[i][<span class="number">0</span>]=g[i][<span class="number">1</span>]=inf; </span><br><span class="line">		<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=<span class="built_in">min</span>(K,siz[x]);i++) </span><br><span class="line">			<span class="keyword">for</span> (j=<span class="number">1</span>;j&lt;=<span class="built_in">min</span>(K-i,siz[y]);j++)&#123;</span><br><span class="line">				g[i+j][<span class="number">0</span>]=<span class="built_in">min</span>(g[i+j][<span class="number">0</span>],f[x][<span class="number">0</span>][i]+f[y][<span class="number">0</span>][j]-i*(i+<span class="number">1</span>)/<span class="number">2</span>-j*(j+<span class="number">1</span>)/<span class="number">2</span>+(i+j)*(i+j+<span class="number">1</span>)/<span class="number">2</span>);</span><br><span class="line">				g[i+j][<span class="number">1</span>]=<span class="built_in">min</span>(g[i+j][<span class="number">1</span>],f[x][<span class="number">1</span>][i]+f[y][<span class="number">1</span>][j]-i*(i+<span class="number">1</span>)-j*(j+<span class="number">1</span>)+(i+j)*(i+j+<span class="number">1</span>));</span><br><span class="line">			&#125;</span><br><span class="line">		<span class="type">int</span> ans1=inf,ans2=inf;</span><br><span class="line">		<span class="keyword">for</span> (j=<span class="number">1</span>;j&lt;=<span class="built_in">min</span>(K,siz[y]);j++) ans1=<span class="built_in">min</span>(ans1,f[y][<span class="number">0</span>][j]),ans2=<span class="built_in">min</span>(ans2,f[y][<span class="number">1</span>][j]);</span><br><span class="line">		<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=<span class="built_in">min</span>(K,siz[x]);i++) </span><br><span class="line">			g[i][<span class="number">0</span>]=<span class="built_in">min</span>(g[i][<span class="number">0</span>],f[x][<span class="number">0</span>][i]+ans2),g[i][<span class="number">1</span>]=<span class="built_in">min</span>(g[i][<span class="number">1</span>],f[x][<span class="number">1</span>][i]+ans1);</span><br><span class="line">		<span class="keyword">for</span> (i=siz[x]+<span class="number">1</span>;i&lt;=<span class="built_in">min</span>(K,siz[x]+siz[y]);i++) f[x][<span class="number">0</span>].<span class="built_in">pb</span>(inf),f[x][<span class="number">1</span>].<span class="built_in">pb</span>(inf);</span><br><span class="line">		siz[x]+=siz[y];</span><br><span class="line">		<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=<span class="built_in">min</span>(K,siz[x]);i++) f[x][<span class="number">0</span>][i]=g[i][<span class="number">0</span>],f[x][<span class="number">1</span>][i]=g[i][<span class="number">1</span>]; </span><br><span class="line">		f[y][<span class="number">0</span>].<span class="built_in">clear</span>();f[y][<span class="number">0</span>].<span class="built_in">shrink_to_fit</span>();</span><br><span class="line">		f[y][<span class="number">1</span>].<span class="built_in">clear</span>(),f[y][<span class="number">1</span>].<span class="built_in">shrink_to_fit</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">solve</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> i,x,y;</span><br><span class="line">	<span class="built_in">read</span>(n);K=<span class="built_in">min</span>(<span class="number">500ll</span>,<span class="number">2</span>+(<span class="type">int</span>)<span class="built_in">sqrt</span>(n)*<span class="number">2</span>);</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		to[i].<span class="built_in">clear</span>();</span><br><span class="line">		f[i][<span class="number">0</span>].<span class="built_in">clear</span>(),f[i][<span class="number">0</span>].<span class="built_in">shrink_to_fit</span>();</span><br><span class="line">		f[i][<span class="number">1</span>].<span class="built_in">clear</span>(),f[i][<span class="number">1</span>].<span class="built_in">shrink_to_fit</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;n;i++) &#123;</span><br><span class="line">		<span class="built_in">read</span>(x),<span class="built_in">read</span>(y);</span><br><span class="line">		to[x].<span class="built_in">push_back</span>(y);</span><br><span class="line">		to[y].<span class="built_in">push_back</span>(x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">	<span class="type">int</span> ans=inf;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=<span class="built_in">min</span>(K,siz[<span class="number">1</span>]);i++) ans=<span class="built_in">min</span>(ans,<span class="built_in">min</span>(f[<span class="number">1</span>][<span class="number">0</span>][i],f[<span class="number">1</span>][<span class="number">1</span>][i]));</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,n*(n+<span class="number">1</span>)-ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> T;</span><br><span class="line">	<span class="built_in">read</span>(T);</span><br><span class="line">	<span class="keyword">while</span> (T--) <span class="built_in">solve</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <tags>
        <tag>dp</tag>
        <tag>背包</tag>
        <tag>优化状态</tag>
      </tags>
  </entry>
  <entry>
    <title>CF19E&amp;CF1680F</title>
    <url>/2022/06/29/CF19E-CF1680F/</url>
    <content><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>给定一个无向图，求所有删去一条边可以使原图变成二分图的边。</p>
<p>$n,m\le 10^6$</p>
<h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><p>如果这张图本身就是二分图，那么随便删一条边即可。</p>
<p>抛开这种特殊情况，我们可以想到这种边的必要条件：所有奇环的交。</p>
<p>但是考虑一种情况，如果这条边同时在某个偶环上，若删掉这条边，则原来的偶环与包括这条边的奇环除去这条边后依然是一个奇环，$(\text{偶环}-1)+(\text{奇环}-1)&#x3D;\text{奇环}$。</p>
<p>所以这种边的充要条件为，在所有奇环的交并且不在任意一个偶环上。<br>于是我们可以在二分图染色的过程中遍历这个无向图，遇到非树边时如果为奇环或者偶环通过类似于树上差分的方式打上标记。</p>
<p>本来树上差分需要带上 $\log $ 求  $lca$ ，但是<strong>在 $dfs$ 的过程中所有非树边都是返祖边</strong>。于是可以 $O(n+m)$ 解决。</p>
<h3 id="code（CF19E）"><a href="#code（CF19E）" class="headerlink" title="code（CF19E）"></a>code（CF19E）</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 2000005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> put() putchar(<span class="string">&#x27;\n&#x27;</span>)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(<span class="type">int</span> &amp;x)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> f=<span class="number">1</span>;x=<span class="number">0</span>;<span class="type">char</span> c=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span> (c&lt;<span class="string">&#x27;0&#x27;</span>||c&gt;<span class="string">&#x27;9&#x27;</span>) &#123;<span class="keyword">if</span> (c==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">-1</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">while</span> (c&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;c&lt;=<span class="string">&#x27;9&#x27;</span>) &#123;x=x*<span class="number">10</span>+c-<span class="string">&#x27;0&#x27;</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> head=<span class="number">1</span>,h[maxn];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">yyy</span>&#123;</span><br><span class="line">	<span class="type">int</span> to,z,flag;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">		to=y;z=h[x];h[x]=head;flag=<span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;a[maxn*<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> c[maxn],fa[maxn],cnt[<span class="number">2</span>][maxn];</span><br><span class="line"><span class="type">int</span> n,m,tot,times,dfn[maxn];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> pre,<span class="type">int</span> color)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> i;c[x]=color;dfn[x]=++times;</span><br><span class="line">	<span class="keyword">for</span> (i=h[x];i;i=a[i].z) </span><br><span class="line">	    <span class="keyword">if</span> ((i^<span class="number">1</span>)!=fa[x]) &#123;</span><br><span class="line">	    	<span class="keyword">if</span> (!c[a[i].to]) fa[a[i].to]=i,a[i].flag=a[i^<span class="number">1</span>].flag=<span class="number">1</span>,<span class="built_in">dfs</span>(a[i].to,x,<span class="number">3</span>-color);</span><br><span class="line">	    	<span class="keyword">else</span> <span class="keyword">if</span> (dfn[a[i].to]&lt;dfn[x])&#123;</span><br><span class="line">	    		<span class="keyword">if</span> (c[a[i].to]!=c[x]) cnt[<span class="number">0</span>][fa[x]]++,cnt[<span class="number">0</span>][fa[a[i].to]]--,cnt[<span class="number">0</span>][i]++;</span><br><span class="line">	    		<span class="keyword">else</span> cnt[<span class="number">1</span>][fa[x]]++,cnt[<span class="number">1</span>][fa[a[i].to]]--,cnt[<span class="number">1</span>][i]++,tot++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> vis[maxn];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> pre)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> i;vis[x]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (i=h[x];i;i=a[i].z)</span><br><span class="line">	    <span class="keyword">if</span> (a[i].to!=pre&amp;&amp;!vis[a[i].to]) &#123;</span><br><span class="line">	    	<span class="built_in">dfs2</span>(a[i].to,x);</span><br><span class="line">	    	cnt[<span class="number">0</span>][fa[x]]+=cnt[<span class="number">0</span>][i];</span><br><span class="line">	    	cnt[<span class="number">1</span>][fa[x]]+=cnt[<span class="number">1</span>][i];</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">dfs3</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> pre,<span class="type">int</span> color)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> i,tmp=<span class="number">0</span>;c[x]=color;</span><br><span class="line">	<span class="keyword">for</span> (i=h[x];i;i=a[i].z)</span><br><span class="line">	    <span class="keyword">if</span> (a[i].to!=pre&amp;&amp;a[i].flag==<span class="number">0</span>) &#123;</span><br><span class="line">	    	<span class="keyword">if</span> (!c[a[i].to]) tmp|=<span class="built_in">dfs3</span>(a[i].to,x,<span class="number">3</span>-color);</span><br><span class="line">	    	<span class="keyword">else</span> <span class="keyword">if</span> (c[a[i].to]==c[x]) tmp=<span class="number">1</span>; </span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">solve</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> i,x,y,ans=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">read</span>(n);<span class="built_in">read</span>(m);</span><br><span class="line">	head=<span class="number">1</span>,tot=<span class="number">0</span>;times=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) h[i]=vis[i]=c[i]=fa[i]=dfn[i]=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=<span class="number">2</span>*m+<span class="number">1</span>;i++) cnt[<span class="number">0</span>][i]=cnt[<span class="number">1</span>][i]=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=m;i++) &#123;</span><br><span class="line">		<span class="built_in">read</span>(x);<span class="built_in">read</span>(y);</span><br><span class="line">		a[++head].<span class="built_in">add</span>(x,y);</span><br><span class="line">		a[++head].<span class="built_in">add</span>(y,x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) <span class="keyword">if</span> (!dfn[i]) <span class="built_in">dfs</span>(i,<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) <span class="keyword">if</span> (!vis[i]) <span class="built_in">dfs2</span>(i,<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) c[i]=<span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> flag=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">2</span>;i&lt;=head;i+=<span class="number">2</span>) cnt[<span class="number">0</span>][i]+=cnt[<span class="number">0</span>][i^<span class="number">1</span>],cnt[<span class="number">1</span>][i]+=cnt[<span class="number">1</span>][i^<span class="number">1</span>];</span><br><span class="line">	<span class="keyword">if</span> (tot==<span class="number">0</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,m);</span><br><span class="line">		<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=m;i++) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,i);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">2</span>;i&lt;=head;i+=<span class="number">2</span>) <span class="keyword">if</span> (!cnt[<span class="number">0</span>][i]&amp;&amp;cnt[<span class="number">1</span>][i]==tot) ans++;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">2</span>;i&lt;=head;i+=<span class="number">2</span>) <span class="keyword">if</span> (!cnt[<span class="number">0</span>][i]&amp;&amp;cnt[<span class="number">1</span>][i]==tot) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,i/<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">	<span class="built_in">solve</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>CF</tag>
        <tag>二分图</tag>
        <tag>构造</tag>
      </tags>
  </entry>
  <entry>
    <title>CF402E</title>
    <url>/2022/07/14/CF402E/</url>
    <content><![CDATA[<p>因为有 $a_{i,j}\ge 0$ ，而题目要我们判断的是不是所有点都 $&gt;0$，所以我们可以把所有 $&gt;0$ 的点都看为 $1$。</p>
<p>考虑其图上的意义。若看成 $01$ 的邻接矩阵，则 $A^k$ 表示经过<strong>恰好</strong> $k$ 步后整张图是否是一个强连通。</p>
<p>我们可以把 $k$ 想象的很大。因为有：<br>$$<br>\sum a_{i,i}&gt;0<br>$$<br>说明有自环的存在。问题转化为图是否为强连通。因为可以在这个点上一直绕。</p>
<p>tarjan 判即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 2005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> put() putchar(<span class="string">&#x27;\n&#x27;</span>)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(<span class="type">int</span> &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> f=<span class="number">1</span>;x=<span class="number">0</span>;<span class="type">char</span> c=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (c&lt;<span class="string">&#x27;0&#x27;</span>||c&gt;<span class="string">&#x27;9&#x27;</span>) &#123;<span class="keyword">if</span> (c==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">-1</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span> (c&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;c&lt;=<span class="string">&#x27;9&#x27;</span>) &#123;x=x*<span class="number">10</span>+c-<span class="string">&#x27;0&#x27;</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> dfn[maxn],low[maxn],vis[maxn],stac[maxn],tot,sccnum,times;</span><br><span class="line"><span class="type">int</span> a[maxn][maxn],n;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//printf(&quot;%d %d\n&quot;,x,sccnum);</span></span><br><span class="line">	<span class="type">int</span> i;dfn[x]=low[x]=++times;vis[x]=<span class="number">1</span>;stac[++tot]=x;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!a[x][i]||i==x) <span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">if</span> (!dfn[i]) <span class="built_in">dfs</span>(i),low[x]=<span class="built_in">min</span>(low[x],low[i]);</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (vis[i]) low[x]=<span class="built_in">min</span>(low[x],dfn[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (dfn[x]==low[x]) &#123;</span><br><span class="line">		++sccnum;</span><br><span class="line">		<span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">			vis[stac[tot]]=<span class="number">0</span>;</span><br><span class="line">			<span class="keyword">if</span> (stac[tot--]==x) <span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="comment">//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);</span></span><br><span class="line">	<span class="type">int</span> i,j,tot=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">read</span>(n);</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) <span class="keyword">for</span> (j=<span class="number">1</span>;j&lt;=n;j++) <span class="built_in">read</span>(a[i][j]);</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) <span class="keyword">if</span> (!dfn[i]) <span class="built_in">dfs</span>(i);</span><br><span class="line">	<span class="built_in">puts</span>(sccnum==<span class="number">1</span>?<span class="string">&quot;YES&quot;</span>:<span class="string">&quot;NO&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>CF</tag>
        <tag>矩阵</tag>
      </tags>
  </entry>
  <entry>
    <title>CF505E Mr. Kitayuta vs. Bamboos</title>
    <url>/2023/08/21/CF505E-Mr-Kitayuta-vs-Bamboos/</url>
    <content><![CDATA[<h1 id="Mr-Kitayuta-vs-Bamboos"><a href="#Mr-Kitayuta-vs-Bamboos" class="headerlink" title="Mr. Kitayuta vs. Bamboos"></a>Mr. Kitayuta vs. Bamboos</h1><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><ul>
<li>给定 $n$ 个数 $h_{1 \dots n}$。</li>
<li>你需要进行 $m$ 轮操作，每轮操作为 $k$ 次修改，每次修改可以选择一个数 $h_i$ 修改为 $\max(h_i - p, 0)$。</li>
<li>每轮操作后每个 $h_i$ 将会被修改为 $h_i + a_i$。</li>
<li>你需要最小化最终 $h_{1 \dots n}$ 中的最大值。</li>
<li>$n \le 10^5$，$m \le 5 \times 10^3$，$k \le 10$。</li>
</ul>
<p>2s , 250MB</p>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p><strong>贺的。</strong></p>
<p>观察到最小化最大值，考虑二分答案，转化为判断性问题。</p>
<p>令现在要判断的最后的最大值为 $H$。这个修改 $\max$ 不好搞，考虑反着来（正难则反）。原来的操作变为：</p>
<ul>
<li>每个 $h_i$ 减去 $a_i$，需要保证减去之后 $\ge 0$。</li>
<li>选择 $k$ 个 $h_i$ 加上 $p$。</li>
</ul>
<p>$m$ 次上述操作后，最后的值 $\ge h_i$。</p>
<p>我们贪心的选择如果不加上 $p$ 离 $&lt;0$ 最快的点。如果怎么加都不能 $\ge 0$，则返回无解。</p>
<p>如果不加上 $p$ 已经可以 $\ge h_i$  ，就不去维护它。用堆实现。</p>
<p>复杂度 $O(n+mk)\log n\log v$</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 100005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> put() putchar(<span class="string">&#x27;\n&#x27;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Tp template<span class="string">&lt;typename Ty&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Ts template<span class="string">&lt;typename Ty,typename... Ar&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(<span class="type">int</span> &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> f=<span class="number">1</span>;x=<span class="number">0</span>;<span class="type">char</span> c=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (c&lt;<span class="string">&#x27;0&#x27;</span>||c&gt;<span class="string">&#x27;9&#x27;</span>) &#123;<span class="keyword">if</span> (c==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">-1</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span> (c&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;c&lt;=<span class="string">&#x27;9&#x27;</span>) &#123;x=x*<span class="number">10</span>+c-<span class="string">&#x27;0&#x27;</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> Debug&#123;</span><br><span class="line">	Tp <span class="type">void</span> _debug(<span class="type">char</span>* f,Ty t)&#123;cerr&lt;&lt;f&lt;&lt;<span class="string">&#x27;=&#x27;</span>&lt;&lt;t&lt;&lt;endl;&#125;</span><br><span class="line">	Ts <span class="type">void</span> _debug(<span class="type">char</span>* f,Ty x,Ar... y)&#123;<span class="keyword">while</span>(*f!=<span class="string">&#x27;,&#x27;</span>) cerr&lt;&lt;*f++;cerr&lt;&lt;<span class="string">&#x27;=&#x27;</span>&lt;&lt;x&lt;&lt;<span class="string">&quot;,&quot;</span>;_debug(f+<span class="number">1</span>,y...);&#125;</span><br><span class="line">	Tp ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; os,vector&lt;Ty&gt;&amp; V)&#123;os&lt;&lt;<span class="string">&quot;[&quot;</span>;<span class="keyword">for</span>(<span class="keyword">auto</span>&amp; vv:V) os&lt;&lt;vv&lt;&lt;<span class="string">&quot;,&quot;</span>;os&lt;&lt;<span class="string">&quot;]&quot;</span>;<span class="keyword">return</span> os;&#125;</span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> gdb(...) _debug((char*)#__VA_ARGS__,__VA_ARGS__)</span></span><br><span class="line">&#125;<span class="keyword">using</span> <span class="keyword">namespace</span> Debug;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mk make_pair</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">power</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y=mod<span class="number">-2</span>)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> sum=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (y) &#123;</span><br><span class="line">		<span class="keyword">if</span> (y&amp;<span class="number">1</span>) sum=sum*x%mod;</span><br><span class="line">		x=x*x%mod;y&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,m,k,p,h[maxn],a[maxn],f[maxn],c[maxn];</span><br><span class="line">priority_queue&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; &gt; q;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> i,j;</span><br><span class="line">	<span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) q.<span class="built_in">pop</span>();</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		f[i]=val,c[i]=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span> (val-m*a[i]&lt;h[i]) q.<span class="built_in">push</span>(<span class="built_in">mk</span>(-(val/a[i]),i));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (j=<span class="number">1</span>;j&lt;=m&amp;&amp;!q.<span class="built_in">empty</span>();j++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=k;i++) <span class="keyword">if</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">			<span class="keyword">auto</span> tmp=q.<span class="built_in">top</span>().se;q.<span class="built_in">pop</span>();</span><br><span class="line">			<span class="keyword">if</span> ((val+c[tmp]*p)/a[tmp]&lt;j) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">			++c[tmp];</span><br><span class="line">			<span class="keyword">if</span> (val+c[tmp]*p-m*a[tmp]&lt;h[tmp]) q.<span class="built_in">push</span>(<span class="built_in">mk</span>(-(val+c[tmp]*p)/a[tmp],tmp));</span><br><span class="line">		&#125; </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> q.<span class="built_in">empty</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="built_in">read</span>(n);<span class="built_in">read</span>(m);<span class="built_in">read</span>(k);<span class="built_in">read</span>(p);</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">read</span>(h[i]),<span class="built_in">read</span>(a[i]);</span><br><span class="line">	<span class="type">int</span> l=<span class="number">0</span>,r=<span class="number">1e15</span>,mid;</span><br><span class="line">	<span class="keyword">while</span> (l+<span class="number">1</span>&lt;r) &#123;</span><br><span class="line">		<span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">check</span>(mid)) r=mid;</span><br><span class="line">		<span class="keyword">else</span> l=mid;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,r);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>正难则反</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>CF962F</title>
    <url>/2022/10/21/CF962F/</url>
    <content><![CDATA[<p>正好复习一下点双。</p>
<p>简单环中的边当且仅当一个点双中点数等于边数。</p>
<p>边数可以在递归子节点之前记录一下，相减便是点双中的边数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 100005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> put() putchar(<span class="string">&#x27;\n&#x27;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Tp template<span class="string">&lt;typename Ty&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Ts template<span class="string">&lt;typename Ty,typename... Ar&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(<span class="type">int</span> &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> f=<span class="number">1</span>;x=<span class="number">0</span>;<span class="type">char</span> c=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (c&lt;<span class="string">&#x27;0&#x27;</span>||c&gt;<span class="string">&#x27;9&#x27;</span>) &#123;<span class="keyword">if</span> (c==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">-1</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span> (c&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;c&lt;=<span class="string">&#x27;9&#x27;</span>) &#123;x=x*<span class="number">10</span>+c-<span class="string">&#x27;0&#x27;</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> Debug&#123;</span><br><span class="line">	Tp <span class="type">void</span> _debug(<span class="type">char</span>* f,Ty t)&#123;cerr&lt;&lt;f&lt;&lt;<span class="string">&#x27;=&#x27;</span>&lt;&lt;t&lt;&lt;endl;&#125;</span><br><span class="line">	Ts <span class="type">void</span> _debug(<span class="type">char</span>* f,Ty x,Ar... y)&#123;<span class="keyword">while</span>(*f!=<span class="string">&#x27;,&#x27;</span>) cerr&lt;&lt;*f++;cerr&lt;&lt;<span class="string">&#x27;=&#x27;</span>&lt;&lt;x&lt;&lt;<span class="string">&quot;,&quot;</span>;_debug(f+<span class="number">1</span>,y...);&#125;</span><br><span class="line">	Tp ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; os,vector&lt;Ty&gt;&amp; V)&#123;os&lt;&lt;<span class="string">&quot;[&quot;</span>;<span class="keyword">for</span>(<span class="keyword">auto</span>&amp; vv:V) os&lt;&lt;vv&lt;&lt;<span class="string">&quot;,&quot;</span>;os&lt;&lt;<span class="string">&quot;]&quot;</span>;<span class="keyword">return</span> os;&#125;</span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> gdb(...) _debug((char*)#__VA_ARGS__,__VA_ARGS__)</span></span><br><span class="line">&#125;<span class="keyword">using</span> <span class="keyword">namespace</span> Debug;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> h[maxn],head=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">yyy</span>&#123;</span><br><span class="line">	<span class="type">int</span> to,z,flag;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">		to=y;z=h[x];h[x]=head;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;a[maxn*<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> cnt;</span><br><span class="line"><span class="type">int</span> dfn[maxn],low[maxn],times,stac[maxn],tot,stace[maxn];</span><br><span class="line"><span class="type">int</span> Ans[maxn];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">tarjan</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> pre)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	dfn[x]=low[x]=++times;stac[++tot]=x;</span><br><span class="line">	<span class="keyword">for</span> (i=h[x];i;i=a[i].z)	&#123;</span><br><span class="line">		<span class="type">int</span> m=cnt;</span><br><span class="line">		<span class="keyword">if</span> (!a[i].flag) stace[++cnt]=i/<span class="number">2</span>,a[i].flag=a[i^<span class="number">1</span>].flag=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span> (!dfn[a[i].to]) &#123;</span><br><span class="line">			<span class="built_in">tarjan</span>(a[i].to,x);</span><br><span class="line">			low[x]=<span class="built_in">min</span>(low[x],low[a[i].to]);</span><br><span class="line">			<span class="keyword">if</span> (dfn[x]&lt;=low[a[i].to]) &#123;</span><br><span class="line">				<span class="type">int</span> num=<span class="number">1</span>;</span><br><span class="line">				<span class="keyword">while</span> (stac[tot+<span class="number">1</span>]!=a[i].to) tot--,num++;</span><br><span class="line"><span class="comment">//				gdb(x,cnt,num,a[i].to);</span></span><br><span class="line">				<span class="type">int</span> flag=(num==cnt-m);</span><br><span class="line">				<span class="keyword">while</span> (cnt&gt;m) Ans[stace[cnt]]=flag,cnt--;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (a[i].to^pre) low[x]=<span class="built_in">min</span>(low[x],dfn[a[i].to]);</span><br><span class="line"> 	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> i,x,y;</span><br><span class="line">	<span class="built_in">read</span>(n);<span class="built_in">read</span>(m);</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=m;i++) &#123;</span><br><span class="line">		<span class="built_in">read</span>(x);<span class="built_in">read</span>(y);</span><br><span class="line">		a[++head].<span class="built_in">add</span>(x,y);</span><br><span class="line">		a[++head].<span class="built_in">add</span>(y,x); </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) <span class="keyword">if</span> (!dfn[i]) <span class="built_in">tarjan</span>(i,<span class="number">0</span>);</span><br><span class="line">	<span class="type">int</span> num=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=m;i++) num+=Ans[i];</span><br><span class="line">	<span class="keyword">for</span> (<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,num),i=<span class="number">1</span>;i&lt;=m;i++) <span class="keyword">if</span> (Ans[i]) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,i);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>感觉求边双来判断边数是否等于点数应该是等价的。没实践过。</p>
]]></content>
      <tags>
        <tag>tarjan</tag>
        <tag>点双</tag>
      </tags>
  </entry>
  <entry>
    <title>CF453E Little Pony and Lord Tirek</title>
    <url>/2023/09/02/CF453E-Little-Pony-and-Lord-Tirek/</url>
    <content><![CDATA[<h1 id="Little-Pony-and-Lord-Tirek"><a href="#Little-Pony-and-Lord-Tirek" class="headerlink" title="Little Pony and Lord Tirek"></a>Little Pony and Lord Tirek</h1><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p><a href="https://www.luogu.com.cn/problem/CF453E">https://www.luogu.com.cn/problem/CF453E</a></p>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>看见有区间推平操作，考虑珂朵莉树的思想。</p>
<p>记录上次相同操作的序列 $(l,r,x)$。考虑现在的时间为中间间隔的时间为 $t$ 。考虑快速计算。以 $\dfrac{m_i}{r_i}+1$ 为权值，建立两棵主席树，一颗的权值为 $r_i$，一颗的权值为 $m_i$。</p>
<p>由于每次加入相同操作的序列区间是 $O(1)$ 的，操作完以后就被删除了，所以复杂度即使没有随机化这个性质，也是 $O((n+m)\log n)$ 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 100005</span></span><br><span class="line"><span class="type">int</span> n,q,c[maxn],b[maxn],a[maxn],s[maxn];</span><br><span class="line">set&lt;<span class="type">int</span>&gt;tr;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">	<span class="type">int</span> l,r,t;</span><br><span class="line">	<span class="built_in">node</span>(<span class="type">int</span> a=<span class="number">0</span>,<span class="type">int</span> b=<span class="number">0</span>,<span class="type">int</span> c=<span class="number">0</span>) &#123;l=a;r=b;t=c;&#125;</span><br><span class="line">	<span class="type">bool</span> <span class="keyword">operator</span> &lt;(<span class="type">const</span> node &amp;x) <span class="type">const</span> &#123;<span class="keyword">return</span> r&lt;x.r;&#125;</span><br><span class="line">&#125;tmp;</span><br><span class="line">set&lt;node&gt;t;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;O[maxn];</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> base=<span class="number">1e5</span>+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">yyy</span>&#123;</span><br><span class="line">	<span class="type">int</span> ls,rs,sum;</span><br><span class="line">&#125;f[maxn*<span class="number">100</span>];</span><br><span class="line"><span class="type">int</span> rt1[maxn],rt2[maxn],cnt;</span><br><span class="line"><span class="keyword">namespace</span> seg&#123;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">Update</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> pre,<span class="type">int</span> head,<span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">		<span class="type">int</span> rt=++cnt;f[rt]=f[pre];f[rt].sum+=k;</span><br><span class="line">		<span class="keyword">if</span> (l==r) <span class="keyword">return</span> rt;</span><br><span class="line">		<span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span> (head&lt;=mid) f[rt].ls=<span class="built_in">Update</span>(l,mid,f[rt].ls,head,k);</span><br><span class="line">		<span class="keyword">else</span> f[rt].rs=<span class="built_in">Update</span>(mid+<span class="number">1</span>,r,f[rt].rs,head,k);</span><br><span class="line">		<span class="keyword">return</span> rt;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">Query</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> rt,<span class="type">int</span> head,<span class="type">int</span> tail)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (!rt) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span> (head&lt;=l&amp;&amp;r&lt;=tail) <span class="keyword">return</span> f[rt].sum;</span><br><span class="line">		<span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>,tmp=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span> (head&lt;=mid) tmp+=<span class="built_in">Query</span>(l,mid,f[rt].ls,head,tail);</span><br><span class="line">		<span class="keyword">if</span> (tail&gt;mid)  tmp+=<span class="built_in">Query</span>(mid+<span class="number">1</span>,r,f[rt].rs,head,tail);</span><br><span class="line">		<span class="keyword">return</span> tmp;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">calc</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> t1,<span class="type">int</span> t2)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> len=<span class="built_in">min</span>(t2-t1,base);</span><br><span class="line">	<span class="type">int</span> sum=seg::<span class="built_in">Query</span>(<span class="number">1</span>,n,rt1[len],l,r)*(t2-t1)+seg::<span class="built_in">Query</span>(<span class="number">1</span>,n,rt2[len],l,r);</span><br><span class="line">	<span class="keyword">return</span> sum;</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> i,x,y,times,l,r;</span><br><span class="line">	<span class="built_in">read</span>(n);</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="built_in">read</span>(c[i]),<span class="built_in">read</span>(a[i]),<span class="built_in">read</span>(b[i]);</span><br><span class="line">		<span class="keyword">if</span> (b[i]) O[a[i]/b[i]+<span class="number">1</span>].<span class="built_in">push_back</span>(i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) tr.<span class="built_in">insert</span>(i);  </span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) rt1[<span class="number">0</span>]=seg::<span class="built_in">Update</span>(<span class="number">1</span>,n,rt1[<span class="number">0</span>],i,b[i]);</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=base;i++) &#123;</span><br><span class="line">		rt1[i]=rt1[i<span class="number">-1</span>];</span><br><span class="line">		rt2[i]=rt2[i<span class="number">-1</span>];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> tmp:O[i]) </span><br><span class="line">			rt1[i]=seg::<span class="built_in">Update</span>(<span class="number">1</span>,n,rt1[i],tmp,-b[tmp]),rt2[i]=seg::<span class="built_in">Update</span>(<span class="number">1</span>,n,rt2[i],tmp,a[tmp]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">read</span>(q);</span><br><span class="line">	<span class="built_in">gdb</span>(q);</span><br><span class="line">	<span class="keyword">while</span> (q--) &#123;</span><br><span class="line">		<span class="built_in">read</span>(times);<span class="built_in">read</span>(l);<span class="built_in">read</span>(r);</span><br><span class="line">		<span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">auto</span> it2=t.<span class="built_in">lower_bound</span>(<span class="built_in">node</span>(l,l,<span class="number">0</span>)),io=it2;</span><br><span class="line">		<span class="keyword">if</span> (io!=t.<span class="built_in">end</span>()&amp;&amp;(*io).l&lt;l) &#123;</span><br><span class="line">			tmp=(*io);</span><br><span class="line">			sum+=<span class="built_in">calc</span>(l,<span class="built_in">min</span>(tmp.r,r),tmp.t,times);</span><br><span class="line">			t.<span class="built_in">erase</span>(io);</span><br><span class="line">			<span class="keyword">if</span> (tmp.l&lt;l) t.<span class="built_in">insert</span>(<span class="built_in">node</span>(tmp.l,l<span class="number">-1</span>,tmp.t));</span><br><span class="line">			<span class="keyword">if</span> (tmp.r&gt;r) t.<span class="built_in">insert</span>(<span class="built_in">node</span>(r+<span class="number">1</span>,tmp.r,tmp.t));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (io=t.<span class="built_in">lower_bound</span>(<span class="built_in">node</span>(l,l,<span class="number">0</span>));io!=t.<span class="built_in">end</span>();io=it2) &#123;</span><br><span class="line">			tmp=*io;</span><br><span class="line">			<span class="keyword">if</span> (tmp.r&gt;r) <span class="keyword">break</span>;</span><br><span class="line">			sum+=<span class="built_in">calc</span>(tmp.l,tmp.r,tmp.t,times);</span><br><span class="line">			it2=io;it2++;</span><br><span class="line">			t.<span class="built_in">erase</span>(io);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (io!=t.<span class="built_in">end</span>()&amp;&amp;(*io).l&lt;=r) &#123;</span><br><span class="line">			tmp=*io;</span><br><span class="line">			sum+=<span class="built_in">calc</span>(tmp.l,r,tmp.t,times);</span><br><span class="line">			t.<span class="built_in">erase</span>(io);</span><br><span class="line">			<span class="keyword">if</span> (r&lt;tmp.r) t.<span class="built_in">insert</span>(<span class="built_in">node</span>(r+<span class="number">1</span>,tmp.r,tmp.t));</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">auto</span> it=tr.<span class="built_in">lower_bound</span>(l);</span><br><span class="line">		<span class="keyword">while</span> (it!=tr.<span class="built_in">end</span>()&amp;&amp;(*it)&lt;=r) &#123;</span><br><span class="line">			<span class="type">int</span> id=*it;sum+=<span class="built_in">min</span>(c[id]+b[id]*times,a[id]);</span><br><span class="line">			tr.<span class="built_in">erase</span>(it);it=tr.<span class="built_in">lower_bound</span>(l);</span><br><span class="line">		&#125;</span><br><span class="line">		t.<span class="built_in">insert</span>(<span class="built_in">node</span>(l,r,times));</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,sum);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>数据结构</tag>
        <tag>珂朵莉树</tag>
        <tag>主席树</tag>
      </tags>
  </entry>
  <entry>
    <title>CF526F Pudding Monsters</title>
    <url>/2023/08/28/CF526F-Pudding-Monsters/</url>
    <content><![CDATA[<h1 id="CF526F-Pudding-Monsters"><a href="#CF526F-Pudding-Monsters" class="headerlink" title="CF526F Pudding Monsters"></a>CF526F Pudding Monsters</h1><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>给定一个 $n \times n$ 的棋盘，其中有 $n$ 个棋子，每行每列恰好有一个棋子。</p>
<p>求有多少个 $k \times k$ 的子棋盘中恰好有 $k$ 个棋子。</p>
<p>$n \le 3 \times 10^5$。</p>
<p>2s 256MB</p>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>二维问题转化为一维问题：每列上的棋子正在 $a_i$ 行，$a$ 是个排列，求有多少区间 $[l,r]$ 是连续的。</p>
<p>一种可行的方法是分治，但是有点愚蠢。</p>
<p>另外一种方法是枚举区间右端点，用单调栈分别维护最大值和最小值。求极差 $-$ 区间长度的最小值，观察到这个值一定大于等于 $-1$，而等于 $-1$ 的地方即对答案产生贡献。</p>
<p>线段树区间加减，维护区间最小值及其个数。</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 300005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> put() putchar(<span class="string">&#x27;\n&#x27;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Tp template<span class="string">&lt;typename Ty&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Ts template<span class="string">&lt;typename Ty,typename... Ar&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(<span class="type">int</span> &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> f=<span class="number">1</span>;x=<span class="number">0</span>;<span class="type">char</span> c=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (c&lt;<span class="string">&#x27;0&#x27;</span>||c&gt;<span class="string">&#x27;9&#x27;</span>) &#123;<span class="keyword">if</span> (c==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">-1</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span> (c&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;c&lt;=<span class="string">&#x27;9&#x27;</span>) &#123;x=x*<span class="number">10</span>+c-<span class="string">&#x27;0&#x27;</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> Debug&#123;</span><br><span class="line">	Tp <span class="type">void</span> _debug(<span class="type">char</span>* f,Ty t)&#123;cerr&lt;&lt;f&lt;&lt;<span class="string">&#x27;=&#x27;</span>&lt;&lt;t&lt;&lt;endl;&#125;</span><br><span class="line">	Ts <span class="type">void</span> _debug(<span class="type">char</span>* f,Ty x,Ar... y)&#123;<span class="keyword">while</span>(*f!=<span class="string">&#x27;,&#x27;</span>) cerr&lt;&lt;*f++;cerr&lt;&lt;<span class="string">&#x27;=&#x27;</span>&lt;&lt;x&lt;&lt;<span class="string">&quot;,&quot;</span>;_debug(f+<span class="number">1</span>,y...);&#125;</span><br><span class="line">	Tp ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; os,vector&lt;Ty&gt;&amp; V)&#123;os&lt;&lt;<span class="string">&quot;[&quot;</span>;<span class="keyword">for</span>(<span class="keyword">auto</span>&amp; vv:V) os&lt;&lt;vv&lt;&lt;<span class="string">&quot;,&quot;</span>;os&lt;&lt;<span class="string">&quot;]&quot;</span>;<span class="keyword">return</span> os;&#125;</span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> gdb(...) _debug((char*)#__VA_ARGS__,__VA_ARGS__)</span></span><br><span class="line">&#125;<span class="keyword">using</span> <span class="keyword">namespace</span> Debug;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mk make_pair</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">power</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y=mod<span class="number">-2</span>)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> sum=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (y) &#123;</span><br><span class="line">		<span class="keyword">if</span> (y&amp;<span class="number">1</span>) sum=sum*x%mod;</span><br><span class="line">		x=x*x%mod;y&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,a[maxn];</span><br><span class="line"><span class="keyword">namespace</span> seg&#123;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">yyy</span>&#123;</span><br><span class="line">		<span class="type">int</span> lazy,Min,sum;</span><br><span class="line">	&#125;f[maxn&lt;&lt;<span class="number">2</span>];</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Pushup</span><span class="params">(<span class="type">int</span> rt)</span> </span>&#123;</span><br><span class="line">		f[rt].Min=<span class="built_in">min</span>(f[rt&lt;&lt;<span class="number">1</span>].Min,f[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].Min);</span><br><span class="line">		f[rt].sum=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span> (f[rt&lt;&lt;<span class="number">1</span>].Min==f[rt].Min) f[rt].sum+=f[rt&lt;&lt;<span class="number">1</span>].sum;</span><br><span class="line">		<span class="keyword">if</span> (f[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].Min==f[rt].Min) f[rt].sum+=f[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].sum;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Pushdown</span><span class="params">(<span class="type">int</span> rt)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (f[rt].lazy) &#123;</span><br><span class="line">			<span class="type">int</span> k=f[rt].lazy;f[rt].lazy=<span class="number">0</span>;</span><br><span class="line">			f[rt&lt;&lt;<span class="number">1</span>].Min+=k;</span><br><span class="line">			f[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].Min+=k;</span><br><span class="line">			f[rt&lt;&lt;<span class="number">1</span>].lazy+=k;</span><br><span class="line">			f[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].lazy+=k;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Build</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> rt)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (l==r) <span class="keyword">return</span> f[rt].Min=<span class="number">0</span>,f[rt].sum=<span class="number">1</span>,<span class="built_in">void</span>();</span><br><span class="line">		<span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">		<span class="built_in">Build</span>(l,mid,rt&lt;&lt;<span class="number">1</span>);</span><br><span class="line">		<span class="built_in">Build</span>(mid+<span class="number">1</span>,r,rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line">		<span class="built_in">Pushup</span>(rt);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Update</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> rt,<span class="type">int</span> head,<span class="type">int</span> tail,<span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line"><span class="comment">//		if (l==1&amp;&amp;r==5) gdb(l,r,rt,head,tail,k,f[rt].sum,f[rt].Min,f[rt].lazy);</span></span><br><span class="line">		<span class="keyword">if</span> (head&lt;=l&amp;&amp;r&lt;=tail) <span class="keyword">return</span> f[rt].Min+=k,f[rt].lazy+=k,<span class="built_in">void</span>();</span><br><span class="line">		<span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">		<span class="built_in">Pushdown</span>(rt);</span><br><span class="line">		<span class="keyword">if</span> (head&lt;=mid) <span class="built_in">Update</span>(l,mid,rt&lt;&lt;<span class="number">1</span>,head,tail,k);</span><br><span class="line">		<span class="keyword">if</span> (tail&gt;mid)  <span class="built_in">Update</span>(mid+<span class="number">1</span>,r,rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,head,tail,k);</span><br><span class="line">		<span class="built_in">Pushup</span>(rt);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> s1[maxn],tot1,s2[maxn],tot2;ll ans;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> i,x,y;</span><br><span class="line">	<span class="built_in">read</span>(n);</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">read</span>(x),<span class="built_in">read</span>(y),a[x]=y;</span><br><span class="line">	seg::<span class="built_in">Build</span>(<span class="number">1</span>,n,<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="keyword">while</span> (tot1&amp;&amp;a[s1[tot1]]&gt;a[i]) &#123;<span class="comment">//Min</span></span><br><span class="line">			seg::<span class="built_in">Update</span>(<span class="number">1</span>,n,<span class="number">1</span>,s1[tot1<span class="number">-1</span>]+<span class="number">1</span>,s1[tot1],a[s1[tot1]]-a[i]);</span><br><span class="line">			tot1--;</span><br><span class="line">		&#125;</span><br><span class="line">		s1[++tot1]=i;</span><br><span class="line">		<span class="keyword">while</span> (tot2&amp;&amp;a[s2[tot2]]&lt;a[i]) &#123;<span class="comment">//Max</span></span><br><span class="line">			seg::<span class="built_in">Update</span>(<span class="number">1</span>,n,<span class="number">1</span>,s2[tot2<span class="number">-1</span>]+<span class="number">1</span>,s2[tot2],-a[s2[tot2]]+a[i]);</span><br><span class="line">			tot2--;</span><br><span class="line">		&#125;</span><br><span class="line">		s2[++tot2]=i;</span><br><span class="line">		seg::<span class="built_in">Update</span>(<span class="number">1</span>,n,<span class="number">1</span>,<span class="number">1</span>,i,<span class="number">-1</span>);</span><br><span class="line">		ans+=seg::f[<span class="number">1</span>].sum;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>线段树</tag>
        <tag>计数</tag>
        <tag>单调栈</tag>
      </tags>
  </entry>
  <entry>
    <title>CSP2019</title>
    <url>/2019/12/30/CSP2019/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>别问我为什么快一整年的游记现在才写。</p>
<h2 id="DAY-100000"><a href="#DAY-100000" class="headerlink" title="DAY -100000"></a>DAY -100000</h2><p>链式前向星不会，dp只会01，排列组合不会，初赛凉凉预定。</p>
<h2 id="DAY-30"><a href="#DAY-30" class="headerlink" title="DAY -30"></a>DAY -30</h2><p>初赛前一天，刷了10张历年卷，希望能过。</p>
<h2 id="DAY-29"><a href="#DAY-29" class="headerlink" title="DAY -29"></a>DAY -29</h2><p>初赛考完以后跟FXT和老师对了手答案基本不同，废了，准备退役。</p>
<h2 id="DAY-25"><a href="#DAY-25" class="headerlink" title="DAY -25"></a>DAY -25</h2><p>凭着小道消息搞来了初赛成绩，FXTAK了，我只有91.5qwq，还是勉强苟进了线。</p>
<p>第二天开始就被拉出去做准备复赛了。</p>
<h2 id="DAY-20"><a href="#DAY-20" class="headerlink" title="DAY -20"></a>DAY -20</h2><p>成绩出来了，五个80分以上的都留了下来，其他的就大多数退役了。</p>
<p>想到自己的未来。</p>
<h2 id="DAY-14"><a href="#DAY-14" class="headerlink" title="DAY -14"></a>DAY -14</h2><p>开始集训了，这个星期是只是晚上。下个星期就是每天的下午停课。不得不说我们学校集训的时间真的是有点晚。可能是因为我们是初一就不太管。</p>
<p>开始上dp，一堆没听懂。</p>
<h2 id="DAY-5"><a href="#DAY-5" class="headerlink" title="DAY -5"></a>DAY -5</h2><p>刷了几个板子。看见WYTDL在刷单调队列，因为我和XYH是比较晚进机房的，所以就找吴老师学了手单调队列和单调栈，直到打联赛的时候还是只会单调队列板子。</p>
<p>晚上的模拟赛又垫底，多重背包板子不会打，博弈论被XYHDL给暴解，又是垫底我太快乐了。</p>
<h2 id="DAY-3-2"><a href="#DAY-3-2" class="headerlink" title="DAY -3~-2"></a>DAY -3~-2</h2><p>这两天期中考屁都没复习。晚上本来答疑的，我跑去训练了qwq。</p>
<p>其他年级的都不去考，老师说初一时第一次考试就让我们去考了。。</p>
<h2 id="DAY-1"><a href="#DAY-1" class="headerlink" title="DAY -1"></a>DAY -1</h2><p>最后一天的集训，颓废了一天，太快乐了。</p>
<p>晚上的模拟赛T1找规律我暴力spfa结果数组开大爆零，最后的一题骗了3分。总分 ：3；倒数第二一百多。。。</p>
<p>又垫底了我太快乐了。</p>
<h2 id="DAY-0"><a href="#DAY-0" class="headerlink" title="DAY 0"></a>DAY 0</h2><p>上午最后的挣扎。先是把机房大扫除了一番，然后跟XYH跑到寝室里整理点东西（指拿一条内裤）。跑到食堂随便吃了一点，跟班里的同学道别以后就爬去二中做车去了。</p>
<p>车上我们机房的5个人坐在车的最前面讲话。剩下的二十几个初三的和高中的在敲板子和睡觉。好像就我们5个是第一次参赛。</p>
<p>晚上我爸妈打电话来，看见我5天扔在寝室的水盆里的袜子把我教训了一顿，真的是没时间洗了啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊。</p>
<p>下午到了一个叫做范艺术（好奇怪的名字）酒店。跟XYH一个房间，房间环境不错，窗子还是落地窗。晚上去旁边的一个快餐店吃饭。每人最多30块钱。老叶让我们做个背包。。。</p>
<p>吃完以后买个泡面，就看了一晚的奇葩说，吃了碗泡面，十点多就睡了。</p>
<p>睡觉前老师把我们5个第一次参加的叫过去讲防爆零。但还是有人爆零了qwq，本来他三百多分的，好可惜。</p>
<h2 id="DAY-1-1"><a href="#DAY-1-1" class="headerlink" title="DAY 1"></a>DAY 1</h2><p>颓废了一上午。</p>
<p>下午进考场，见识了下文渊的寝室，羡慕啊。</p>
<p>然后进了地下车库，跟FXT,XYH,RSJ,WYT约定好在哪里集合就自己找考场了。</p>
<p>考前上了个厕所，发现移动厕所好臭。。。</p>
<p>开始了，解密码还花了五分钟。。</p>
<p>开T1，发现今年T1是来搞笑的吗，3分钟切完搞T2。</p>
<p>T2一开始就感觉跟最近学的单调队列有点像，然后开始莽队列。然后发现需要开两个。调了20分钟，把大样例过了就爬了。</p>
<p>开T3，一眼dp，不会，开T4。</p>
<p>之间上了个厕所。还跟监考老师讲了一声，发现根本不理我，之后我就直接去上了。。</p>
<p>T4没什么思路（当时我最短路只会FLoyd），先是打了个搜索，发现可以记忆化，就把80%的部分分打了。</p>
<p>发现不太可能拿那么多分（CCF又不是脑子有问题），然后填了个60%的数据上去爬了。</p>
<p>中途发生了亿点小故障，调试的时候想要调试但是找不到，之前我都是直接来Devc++左边直接调的。。</p>
<p>问了下监考老师，老师白了我一眼我就瞎调，调了一个小时终于调出来了。</p>
<p>上了个厕所，想T3。</p>
<p>想了半小时没什么思路，爆搜也不会，把T3 $t&#x3D;1$ 的情况打了骗了10分，就去检查前面三题。</p>
<p>最后一个小时不知道在干嘛，去厕所3,4次，监考老师以为我在作弊就盯着我。。</p>
<p>考完了。</p>
<p>出考场以后问了下几个同个学校了，人均350+，我感觉我要没了&#x2F;dk。</p>
<p>车上XJZ老师问我们预估分数，我瞎报了个260，丢人。</p>
<p>十一点到回家。</p>
<h2 id="DAY-不知道"><a href="#DAY-不知道" class="headerlink" title="DAY 不知道"></a>DAY 不知道</h2><p>看了眼分数 265，FXT 315，据说是T3随机数骗了5分；RSJ炸了，XYH炸了，T2没打出来，WYT文件的问题爆零。</p>
<p>老师说分数线应该在260~280，整个晚上都在%FXT保佑线260.</p>
<h2 id="DAY-不知道-不知道"><a href="#DAY-不知道-不知道" class="headerlink" title="DAY 不知道+不知道"></a>DAY 不知道+不知道</h2><p>上cyb的时候，XYH告诉我是线265。</p>
<p>啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊。</p>
<p>高兴了一个上午。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li><p>最后集训的那几天一定要通校</p>
</li>
<li><p>去杭州一定带手机不然要无聊死</p>
</li>
<li><p>初赛好好搞</p>
</li>
</ul>
<h2 id="END"><a href="#END" class="headerlink" title="END"></a>END</h2><p>希望我明天初赛能过</p>
]]></content>
      <tags>
        <tag>游记</tag>
      </tags>
  </entry>
  <entry>
    <title>COCI2018-2019#6 Mobitel</title>
    <url>/2022/10/21/COCI2018-2019-6-Mobitel/</url>
    <content><![CDATA[<p>直接做是 $O(rsn)$ 的，显然会炸。</p>
<p>考虑反着做，$f[i][j][k]$ 表示 $(i,j)$ 走出去还至少要当前价值为 $k$。</p>
<p>转移枚举前一个，向上取整。</p>
<p>打表发现，对于 $1\le n\le 10^6$，$k$ 的有效个数最多只有 $2\times 10^3$ 个左右。故映射一下即可。</p>
<p>还有要滚动数组，不然空间会炸。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 1000005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> put() putchar(<span class="string">&#x27;\n&#x27;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Tp template<span class="string">&lt;typename Ty&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Ts template<span class="string">&lt;typename Ty,typename... Ar&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(<span class="type">int</span> &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> f=<span class="number">1</span>;x=<span class="number">0</span>;<span class="type">char</span> c=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (c&lt;<span class="string">&#x27;0&#x27;</span>||c&gt;<span class="string">&#x27;9&#x27;</span>) &#123;<span class="keyword">if</span> (c==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">-1</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span> (c&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;c&lt;=<span class="string">&#x27;9&#x27;</span>) &#123;x=x*<span class="number">10</span>+c-<span class="string">&#x27;0&#x27;</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> Debug&#123;</span><br><span class="line">	Tp <span class="type">void</span> _debug(<span class="type">char</span>* f,Ty t)&#123;cerr&lt;&lt;f&lt;&lt;<span class="string">&#x27;=&#x27;</span>&lt;&lt;t&lt;&lt;endl;&#125;</span><br><span class="line">	Ts <span class="type">void</span> _debug(<span class="type">char</span>* f,Ty x,Ar... y)&#123;<span class="keyword">while</span>(*f!=<span class="string">&#x27;,&#x27;</span>) cerr&lt;&lt;*f++;cerr&lt;&lt;<span class="string">&#x27;=&#x27;</span>&lt;&lt;x&lt;&lt;<span class="string">&quot;,&quot;</span>;_debug(f+<span class="number">1</span>,y...);&#125;</span><br><span class="line">	Tp ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; os,vector&lt;Ty&gt;&amp; V)&#123;os&lt;&lt;<span class="string">&quot;[&quot;</span>;<span class="keyword">for</span>(<span class="keyword">auto</span>&amp; vv:V) os&lt;&lt;vv&lt;&lt;<span class="string">&quot;,&quot;</span>;os&lt;&lt;<span class="string">&quot;]&quot;</span>;<span class="keyword">return</span> os;&#125;</span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> gdb(...) _debug((char*)#__VA_ARGS__,__VA_ARGS__)</span></span><br><span class="line">&#125;<span class="keyword">using</span> <span class="keyword">namespace</span> Debug;</span><br><span class="line"><span class="type">int</span> vis[maxn],id[maxn],cnt,g[maxn];</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> base=<span class="number">1e6</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> &amp;x,<span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (x+y&gt;mod) x=x-mod+y;<span class="keyword">else</span> x+=y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> l,r;</span><br><span class="line">	<span class="keyword">if</span> (!vis[x]) vis[x]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> ;</span><br><span class="line">	<span class="keyword">for</span> (l=<span class="number">1</span>;l&lt;=x;l++) &#123;</span><br><span class="line">		r=<span class="built_in">min</span>(x,(x/(x/l)));</span><br><span class="line">		<span class="built_in">dfs</span>((x+l<span class="number">-1</span>)/l);</span><br><span class="line">		<span class="built_in">dfs</span>((x+r<span class="number">-1</span>)/r);</span><br><span class="line">		l=r;		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> r,s;</span><br><span class="line"><span class="type">int</span> f[<span class="number">2</span>][<span class="number">305</span>][<span class="number">2005</span>],a[<span class="number">305</span>][<span class="number">305</span>];</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line"> <span class="comment">// freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);</span></span><br><span class="line">	<span class="type">int</span> i,j,k,sum=<span class="number">0</span>,n,tmp,pre,x;</span><br><span class="line">	<span class="built_in">read</span>(r);<span class="built_in">read</span>(s);<span class="built_in">read</span>(n);</span><br><span class="line">	<span class="built_in">dfs</span>(n);</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;=n;i++) <span class="keyword">if</span> (vis[i]) id[i]=++cnt,g[cnt]=i;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=r;i++) <span class="keyword">for</span> (j=<span class="number">1</span>;j&lt;=s;j++) <span class="built_in">read</span>(a[i][j]); </span><br><span class="line">	f[r&amp;<span class="number">1</span>][s+<span class="number">1</span>][id[n]]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (i=r;i&gt;=<span class="number">1</span>;i--) &#123;</span><br><span class="line">		tmp=i&amp;<span class="number">1</span>,pre=tmp^<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span> (i^r) <span class="built_in">memset</span>(f[tmp],<span class="number">0</span>,<span class="built_in">sizeof</span>(f[tmp]));</span><br><span class="line">		<span class="keyword">for</span> (j=s;j&gt;=<span class="number">1</span>;j--) &#123;</span><br><span class="line">			x=a[i][j];</span><br><span class="line">			<span class="keyword">for</span> (k=cnt;k&gt;=<span class="number">1</span>;k--) &#123;	</span><br><span class="line">				<span class="built_in">add</span>(f[tmp][j][id[(g[k]+x<span class="number">-1</span>)/x]],f[pre][j][k]);</span><br><span class="line">				<span class="built_in">add</span>(f[tmp][j][id[(g[k]+x<span class="number">-1</span>)/x]],f[tmp][j+<span class="number">1</span>][k]);</span><br><span class="line"><span class="comment">//				if (f[pre][j][k]) gdb(i+1,j,k,f[pre][j][k]);</span></span><br><span class="line"><span class="comment">//				if (f[tmp][j+1][k]) gdb(i,j+1,k,f[tmp][j+1][k]);</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,f[<span class="number">1</span>][<span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title>CSP2020</title>
    <url>/2020/12/30/CSP2020/</url>
    <content><![CDATA[<h2 id="DAY-初赛前一天"><a href="#DAY-初赛前一天" class="headerlink" title="DAY 初赛前一天"></a>DAY 初赛前一天</h2><p>明天初赛加油。</p>
<p>第一次打CSP-S有点紧张qwq。</p>
<p>搞不好明天就是退役日了。</p>
<p>乱搞几张初赛卷睡觉去了。</p>
<p>rp++.</p>
<h2 id="DAY-初赛"><a href="#DAY-初赛" class="headerlink" title="DAY 初赛"></a>DAY 初赛</h2><p>人在机房，主场作战，还有1个小时CSP-S开考。</p>
<p>学校门卫脑子有问题就是要把比赛说成考试害我在外面吹了10分钟冷风。</p>
<p>预祝FXTAK初赛。开始临时抱佛脚。</p>
<p>rp++.</p>
<p>考之前因为去年考了状压，就狂背逻辑运算符优先级。背了个卡特兰数通项公式就爬了。</p>
<p>进考场看见小学一起学信息的同学。前面的前面是ZJ。监考老师是三楼实验室的化学老师。</p>
<p>发考卷，开局一个一百行左右的阅读程序，凉了。</p>
<p>选择题15分钟做完。第一道一个sb题，第二道一眼一个快排，再一眼就是个求第 $k$ 大的快排分治，然后花了25分钟左右写完了前两题。第三题100多行看了1分钟发现是个一大堆 $\text{STL}$ 的合集手写。剩下就没看出来啥，就跳了。</p>
<p>完形填空T1是个sb题，T2按着dp的定义乱搞做完了，大概花了30分钟左右。</p>
<p>T3阴间题我tm没看出来双向广搜，乱搞了半小时爬了。</p>
<p>然后开始检查。阅读程序的T2选择1看错题目改了。</p>
<p>出考场感觉还行，应该有90分(flag)。</p>
<p>吃饭之前跟FXT对了下，不一样的有14.5，感觉怎么算都稳。选择题最后一题我蒙错了。</p>
<p>吃饭以后看见兔队发了答案对了一手，发现只有83分，顿时在考虑我的未来。</p>
<p>完形填空T2sb题错了6分，本来挺稳的，现在感觉有点慌。</p>
<p>希望能进，没进的话，游记大概就写到这里了，今年的大概就没什么动力学OI了，CSP-J由于比过了就不是很想写了。</p>
<p>还有记得<strong>膜拜香农</strong>。</p>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/6mq81bvy.png"></p>
<p>分数没出，还是写一下CSP-J吧。。</p>
<p>好的瞬间来到了下午。</p>
<p>因为上午心里有底了，下午就不太紧张了。考场门口看见好多小学生。</p>
<p>开局15分钟，秒完选择题，<del>竟然没有考香农</del>。</p>
<p>然后10分钟看阅读程序T1没看进去，就看T2，又没看进去，看T3太长就直接完形填空了。T1比较水，T2我想到一道线段树优化dp的题，按右端点排序以后,就不太会了。我看了眼天空感觉4点了就马上开始看阅读程序。</p>
<p>发现T1是个sb题，T2是个10进制转k进制，求进位次数。T3是个我玄学贪心蒙了贪心结论然后对了（？）。</p>
<p>最后一题发现就是按左端点排序然后把包含的区间去掉，最后贪心就好了。</p>
<p>乱检查了一下，发现错了3个判断题和一个冒泡排序。</p>
<p>发现一个小学生在吃糖（？）。</p>
<p>出来跟FXT对了一发95，回去跟老师发的答案又对了一发98（？）</p>
<p>PJ还行。应该能进。</p>
<h2 id="DAY-初赛-1"><a href="#DAY-初赛-1" class="headerlink" title="DAY 初赛+1"></a>DAY 初赛+1</h2><p>TG初赛感觉还是非常悬啊啊啊啊啊啊啊啊啊啊，搞不好一年的努力就没了awa。</p>
<p>晚上问了下老师，10钟没回我就睡了。</p>
<h2 id="DAY-初赛-2"><a href="#DAY-初赛-2" class="headerlink" title="DAY 初赛+2"></a>DAY 初赛+2</h2><p>准备退役。</p>
<h2 id="DAY-初赛-6"><a href="#DAY-初赛-6" class="headerlink" title="DAY 初赛+6"></a>DAY 初赛+6</h2><p>在外面跟ZJ（初三的一位去学车的）院士吃饭结果看了眼手机出成绩了？</p>
<p>我手机没电拿我妈的看了眼，结果忘记准考证awa。</p>
<p>还好我之前叫我妈打印的准考证的记录没删。</p>
<p>TG83，PJ98跟之前估的一样。</p>
<p>本来以为TG贼悬，结果发现三百多名（？）</p>
<p>ZJ感觉今年有点假。</p>
<p>大概是进了，要好好训练了,大概不能AFO了。</p>
<p>先去打今晚9点的CF去了。</p>
<h2 id="DAY-初赛-7"><a href="#DAY-初赛-7" class="headerlink" title="DAY 初赛+7"></a>DAY 初赛+7</h2><p>昨天CF切了三题回去B作业果然下分了我太快乐了。</p>
<p>D题洗澡的时候构造出来了，E题听FXT讲是个sb题。</p>
<p>接下来就等老师通知了，不过我最近的计划和执行结果差不多就堆在这里了。</p>
<p>计划：</p>
<ul>
<li>dp</li>
<li>dp</li>
<li>dp</li>
<li>dp</li>
<li>dp</li>
<li>dp</li>
</ul>
<p><del>大概就这些差不多</del></p>
<p>准备去学校补作业然后练点可能会考的东西。</p>
<p>爬了</p>
<p>upt on 2020.11.08:cnm一道没考</p>
<h2 id="DAY-20号"><a href="#DAY-20号" class="headerlink" title="DAY 20号"></a>DAY 20号</h2><p>学校运动会跑到机房里打代码。</p>
<p>等到下午分数线还没出</p>
<h2 id="DAY-21号"><a href="#DAY-21号" class="headerlink" title="DAY 21号"></a>DAY 21号</h2><p>早上又来机房，发现老师说从xxy那里的“可靠消息”大概有800台机子。</p>
<p>PJ的线大概在78左右。</p>
<p>反正跟我没关系。</p>
<p>晚上吃完饭lzy跟我讲线出来了？？？</p>
<p>PJ77.5，TG他没看，反正跟我没关系。</p>
<p>ZJ老鸽子了。</p>
<h2 id="DAY-12"><a href="#DAY-12" class="headerlink" title="DAY -12"></a>DAY -12</h2><p>晚上CF打了3000多名，自闭了。</p>
<h2 id="DAY-9"><a href="#DAY-9" class="headerlink" title="DAY -9"></a>DAY -9</h2><p>突然知道自己进了物理复赛，还是 $11.1$ 号考试，我tm直接自闭。</p>
<h2 id="DAY-8"><a href="#DAY-8" class="headerlink" title="DAY -8"></a>DAY -8</h2><p>学校终于开始停课了，这两天是只停下午和晚上，午休还要在学校。</p>
<p>明天秋游还不能请假我tm…</p>
<p>今天下午TG模拟赛 $3$ 道题全是暴力拿了 $203$ 分rank1还行。</p>
<p>orz FXT 3题全想出来正解可惜打挂了 </p>
<p>orz jtz PJ模拟赛 rk1</p>
<p>爬了</p>
<h2 id="DAY-3"><a href="#DAY-3" class="headerlink" title="DAY -3"></a>DAY -3</h2><p>又是摸你赛，PJ这次考FXTDL的题，我验了三道，对他们的期望分数 $200$ 分。</p>
<p>打了一大堆，本来对T3最有信心，结果就T3炸了。。。</p>
<p>FXT好像又打挂了，然后我就苟到一个rk1。</p>
<p>话说PJ最高怎么才 $100$ 出头啊。。</p>
<h2 id="DAY-2"><a href="#DAY-2" class="headerlink" title="DAY -2"></a>DAY -2</h2><p>模拟赛，好像是春晖中学<del>没听说过的野鸡中学</del>出的。</p>
<p>T1A了，T2少讨论一种情况60pts，T3因为数组越界 $90-&gt;65-&gt;20pts$ 我太快乐了。</p>
<p>垫底。</p>
<p>晚上艹了 20 个PJ板子，发现还是有很多问题啊啊啊啊啊啊啊啊啊啊。</p>
<h2 id="DAY-1"><a href="#DAY-1" class="headerlink" title="DAY -1"></a>DAY -1</h2><p>下午先艹了 9 个TG板子，然后做了下老师发下来的以前的模拟赛。</p>
<p>T1sb结论题，T3sb最小生成树上倍增，T2第一问是个结论，第二问尺取挂了我太快乐了。</p>
<p>没人打，那我就rk1（。</p>
<p>晚上先颓废了一下，最后一个小时刷了2道真题然后看了几眼去年的题我平均情况能打几分。</p>
<p>好像全暴力拿省一没有很难吧(flag*1 于 2020.11.05</p>
<h2 id="DAY-0"><a href="#DAY-0" class="headerlink" title="DAY 0"></a>DAY 0</h2><p>早上艹了手树套树调了一年，然后颓废颓废颓废颓废。</p>
<p>突然想起来Prim和数论板子没打，就再打了Prim和BSGS，复习了手exgcd。</p>
<p>现在刚刚想到树的重心和直径没打，去年又考了，爬去复习。</p>
<p>中午随便吃了点饭出发了。</p>
<p>车上下了个皇室战争van了一下，发现FXT竟然也打(</p>
<p>住希尔顿，亚运会对面。</p>
<p>晚上吃完晚饭跑到江边玩了一下，本来想过江的发现太远了()</p>
<h2 id="DAY-1-1"><a href="#DAY-1-1" class="headerlink" title="DAY 1"></a>DAY 1</h2><p>早饭挺好吃的()</p>
<p>上路的时候讨论怎么才能爆零（）</p>
<p>来到文渊第三考场——两个监考女老师太好看了吧，厕所很香，键盘手感很好，电脑很好玩，没扫雷差评()</p>
<p>开题。</p>
<p>T1感觉是个二进制拆分的板子。</p>
<p>T2一眼平衡树？？cao普及现在这么难了吗</p>
<p>T3给30分暴力分差评，T4没一眼。</p>
<p>先把T1T2草了，T2草完以后发现数据范围 $0\le w \le600$，不管了()。</p>
<p>T4发现一个非常有用的性质，每列只会从上一列转移一次，前缀和乱搞一下。</p>
<p>T3先扔了个暴力，上了个车硕冷静了一下。突然想到笛卡尔树，把中序遍历搞成一棵树。被自己hack了。</p>
<p>然后想到数值作为叶子节点，字符作为非叶子节点，然后字符两边是要运算的表达式。通过分类讨论判断改变左右两边是否会改变当前子树运算的值，打懒标记，最后没有被打上那么改变肯定会改变整个结果。</p>
<p>脚模了下两个样例没什么问题，就开始打。</p>
<p>四道题总共打了两个小时。</p>
<p>感觉T3会出点事情，就写了个拍子拍了一下。造数据程序写了半个小时()</p>
<p>然后开始拍，上了个厕所，回来发现电脑风扇响了还以为电脑要炸了()</p>
<p>出考场发现fxt也AK了。yzxDL好像是因为T4没打出来，我以为他在装弱，后来发现真挂了。。。。</p>
<p>吃饭以后去打TG，想睡觉但是没睡着。</p>
<p>第四考场——监考老师也太好看了吧，<del>话说我是不是lsp啊</del></p>
<p>开题。</p>
<p>T1，一眼带模拟，下一个。</p>
<p>T2感觉一眼sb题</p>
<p>T3，感觉像个数据结构或者拓扑？</p>
<p>T4像个博弈论（dp）。</p>
<p>话说怎么没有纯dp啊，感觉这次分数线要240+(flag*2</p>
<p>于是按照我的判断，先开T1,。</p>
<p>草了半个小时以后没打完，就草T2，发现就是个xxs分类讨论。</p>
<p>10分钟打完+过大样例，“这是TG题？我绝对切”（flag*3</p>
<p>心想有100了，于是继续开T1。</p>
<p>两个半小时过后，T1对着大样例调过了就不管了，开始T4。</p>
<p>打了10分钟 $n\le10$ 的暴力，没草数来就只草 $n&#x3D;3$ 的暴力。</p>
<p>开 T3 暴力。</p>
<p>先扔了个 $n???$ 的暴力，然后发现只有操作 $1,3$ 的很好想，直接拓扑算贡献就好了。然后再打了个只有 $2,3$ 操作的记忆化搜索暴力。</p>
<p>只剩下二十分钟不到，不知道干什么，就吃士力架(。</p>
<p>结束了以后出来 。</p>
<p>FXT :”我估分大概290——T1没挂的话”</p>
<p>RSJ :”我两题正解”</p>
<p>我:”我跟你一样”(flag*4</p>
<p>回去的时候看见闪指导落泪，应该是T1挂了或者因为T1浪费太多时间。</p>
<p>车上，发现计蒜客上出数据了，就拿ZJDL的电脑测了下。</p>
<p>FXT，我，RSJAK了，CBW，WYT挂几十分了，其他我们机房的人都挺好。</p>
<p>TG就没去理。</p>
<h2 id="DAY-2-1"><a href="#DAY-2-1" class="headerlink" title="DAY 2"></a>DAY 2</h2><p>早上发现代码来了，发现电脑没电了，于是想中午再测。</p>
<p>快中午的时候，FXT跟我讲 :”帮你测了下 ，0+0+45+15”</p>
<p>我人傻了。。。</p>
<p>然后就是猛  男  落  泪</p>
<p>下午FXT又发来一张图片，说我在lg上只有300了PJ，wcx测的。</p>
<p>我问了下老师，说freopen关了，我  人  傻  了。</p>
<p>于是连续四天都没睡好，包括期中考试也一直在想。</p>
<h2 id="DAY-6"><a href="#DAY-6" class="headerlink" title="DAY 6"></a>DAY 6</h2><p>期中考考完了。全炸。不能完全怪罪于我的 $300pts$ 和TG爆炸 ，但也占了挺大一部分原因，主要还是没调整好心态，在信奥这方便没经历过挫折。</p>
<p>然后来机房，测了手PJT3，准备改了下，就发现A了？？？</p>
<p>突然想起来我的暴力代码粘在下面，老师可能删的freopen是暴力代码被注释掉的freopen，真正的<strong>freopen</strong>并没有被删去。</p>
<p><strong>我  人  傻  了</strong></p>
<p>然后跟FXT一起帮我调爆零的TGT2，我一对思路都是对的，代码也是对的。</p>
<p>测了下样例，没过？？？</p>
<p>设了个断点，发现我的 $2^{k-a}$ 中的 $a$ 的没有清零。。。</p>
<p>$[90,95]-&gt;0$ 我太快乐了。</p>
<p>开始辱骂学军的电脑+准备学习Linux</p>
<p>我人没了。。。</p>
<h2 id="DAY-8-1"><a href="#DAY-8-1" class="headerlink" title="DAY 8"></a>DAY 8</h2><p>成绩出来了</p>
<p>PJ&#x3D;100+100+100+100&#x3D;400 可算没炸</p>
<p>TG&#x3D;20+0+35+20&#x3D;75 还没别人一题分高</p>
<p>FXT本来可能1&#x3D;结果因为T1数据水了，其他人分都高起来，AC的就没什么用了。</p>
<p>ZJDL 175，RSJDL本来民间数据只有一百出头结果直接205？ 不过还是祝贺1&#x3D;。</p>
<p>线我也不想管了，反正两条线都跟我没关系。本来还想混个6级蓝勾进LA群玩玩，现在算是没什么希望了。</p>
<p><strong>AK普及算是对我TG爆炸的一种安慰吧。</strong></p>
<h2 id="DAY"><a href="#DAY" class="headerlink" title="DAY ??"></a>DAY ??</h2><p>线出来了。</p>
<p>ZJTG今年线高的离谱，RSJ只有二等了，不过有了7级蓝钩。</p>
<p>不过今年TG2&#x3D;线低的离谱，我还是混到了个名誉二等。虽然没什么用，但是听说老师的奖金又可以多几百RMB(</p>
<p>二中只有3个TG一等，预言一波NOIP翻盘。</p>
<h2 id="DAY-？？-？"><a href="#DAY-？？-？" class="headerlink" title="DAY ？？+？"></a>DAY ？？+？</h2><p>陈指导NOIP320+，估计有个省前二十。</p>
<p>预言对一个跟我一点关系没有的比赛..</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>对于平时的训练，自认为做的还算不错。机房的9人中每次都可以在OI赛之中挂分控制在 $[-10,0]$，待NOIP结束，就去第四机房多参加模拟赛。</p>
<p>对于比赛前一天的休息，还是要早点睡，不然就会遇到打完PJ后打TG非常想睡觉。</p>
<p>对于比赛的心态，无意的发现今年的TG ZJ人相比去年水了很多，本来考场上看完题目后以为线至少有240的就一定要把T1刚出来，后来发现这真是个错误的选择。导致了人均70+我只有20还险些爆零。</p>
<p>然后就是T2，因为打完T1心态炸了，T2就一眼正解，10分钟打完+调试，结果因为定义在主函数中的变量没清零而学军的机子是默认清零的，我就没了。看来与计数或者输出答案有关的东西一定要扔到主函数里。</p>
<p>T3好像有70分的暴力没拿满很奇怪，T4起码没耽误太多时间。</p>
<p>总的来说，今年是一场特殊的比赛。起码我才初二。</p>
<p>如果政策好些，今年争取学习完除多项式外的大多省选算法，整理一些套路，明年在CSP-S2中取得一个好成绩，希望有280+或者300+，参加人生中的第一次省选。</p>
<p>不负众望，砥砺前行。</p>
]]></content>
      <tags>
        <tag>游记</tag>
      </tags>
  </entry>
  <entry>
    <title>CSP2021</title>
    <url>/2021/12/30/CSP2021/</url>
    <content><![CDATA[<h2 id="DAY-？-初赛日"><a href="#DAY-？-初赛日" class="headerlink" title="DAY ？ 初赛日"></a>DAY ？ 初赛日</h2><p>来到了兴华中学。说实话华茂是真的好，各种方面上的。</p>
<p>TG 的 base64 和四毛子很是阴间，错了几个傻逼题，还好没到不能过初赛的程度，起码也有 80。</p>
<p>PJ 怎么还考 base64 ，扣 6 分，真nm一年不如一年。初一 PJ 好歹也上 90 了。。。</p>
<p>准备月考了。</p>
<h2 id="前两个星期"><a href="#前两个星期" class="headerlink" title="前两个星期"></a>前两个星期</h2><p>每天一场模拟赛，完全不能订正的过来。</p>
<h2 id="前一个星期"><a href="#前一个星期" class="headerlink" title="前一个星期"></a>前一个星期</h2><p>在我们的花言巧语下，还是让老叶给我们把每天下午的课停了。</p>
<p>每天大概就是刷个两三道CF题，写两三个模板，颓一下死神vs火影。</p>
<p><del>真好玩，学nmOI</del></p>
<p>每天晚上还是毒瘤们轮流出题，天天下大分真nm好玩。</p>
<p>下午可以提早吃饭还是不错的。</p>
<p>星期四晚上发现电脑可以升 win11 了就赶快升，第二天带到学校里用了一下，似乎没 win10 顺手，但是莫名感觉屏幕变大了(?)</p>
<p>中午比较意外的是临走前校长还有烟宏来讲话，大概就记得 “付出了更多的精力和时间”，“给我们送点小礼物”之类的。</p>
<p>不过打乒乓球的时间变多了，而且<del>华茂奖学金还没发蓝建龙你说是不是</del>。</p>
<p>下午打了一下王者，颓了一下团战经理。晚上出去走路，杭州还是大啊，即使是余杭区，晚上酒店网不好战地5根本登不上去。</p>
<p><strong>见到了 FLY，意外收获</strong>。</p>
<p>比较意外的发现根根和他npy洗澡的时候还在语音通话，<del>不知道是不是视屏聊天</del>。</p>
<p>工地很吵，11点才睡，早上五点五十就醒了。</p>
<h2 id="比赛日"><a href="#比赛日" class="headerlink" title="比赛日"></a>比赛日</h2><h3 id="PJ"><a href="#PJ" class="headerlink" title="PJ"></a>PJ</h3><p>题目很长，差评。</p>
<p>键盘手感不好，差评。</p>
<p><del>监考老师不是漂亮小姐姐，差评。</del></p>
<p>可以玩扫雷，好评</p>
<p>T1 就是个傻子题。T2 一眼平衡树，T3 大概就是 map 搞搞，T4 有点像链表。</p>
<p>一个小时多写完了前三题，最后一题边写边拍，维护链表和两个并查集，写了两个多小时结束了。</p>
<p>最后玩了两把扫雷。</p>
<h3 id="TG"><a href="#TG" class="headerlink" title="TG"></a>TG</h3><p>考完很累，很想睡觉，买了杯咖啡和一罐红牛。</p>
<p>事实证明咖啡还是很管用的，一下午精神饱满。</p>
<p>题目还是很长。不过换了个手感很好的键盘。</p>
<p>T1 感觉很简单，一眼三分。(flag+1)</p>
<p>T2 一眼区间dp，感觉一个小时前两题就可以打完。(flag+2)</p>
<p>T3 暴力不是随便打打。</p>
<p>T4 怎么题目没看懂，第一眼像个网络流（前一天晚上还在狗哥面前写了一次）。</p>
<p>中间因为提前碰键盘还被警告了，丢人。</p>
<p>T1 写了半个小时三分，第一次写三分，之前都是二分斜率。这次听了 fls 的劝告。感觉很简单，直接没对拍。</p>
<p>T2 区间 dp ，一个维护答案，一个维护 <code>AS</code> 的情况个数，然后乱退一下就好了。</p>
<p>调了半天第二个样例没过去，然后写了个暴力手动对拍。半小时之后发现 <code>()()()()</code> 的情况会算很多次。</p>
<p>然后多维护一个 <code>(...)</code> 的数量和 <code>(..)(..)(..)</code> 的数量，乱草了一下就好了。</p>
<p>已经过去了两个多小时。</p>
<p>T3 乱搞一小时未果，T4 还没有看懂题目，血压已经上来了。</p>
<p>最后一个小时发现 T3 如果可以选的，一定剩下没选的就分成两段。</p>
<p>搞了二十分钟过了大样例，发现第一个样例首尾相同的情况判断错了。然后特判一手。</p>
<p>最后 $10$ 分钟发现数组大小开了 $5000$，赶快改成 $10^6$ 。</p>
<p>最后 $5$ 分钟感觉 $2^{2n}\cdot 2n$ 暴力范围会 T，于是删了数据分治。</p>
<h3 id="出考场"><a href="#出考场" class="headerlink" title="出考场"></a>出考场</h3><p>发现 T1 假了，不过我觉得能骗点分。可惜没数据分治。</p>
<p>T3 还是很慌，因为没数据分治，一直给自己 “暴力跑不过去” 的心理暗示。</p>
<p>晚上车上网很卡，打了一个多小时王者，然后睡了一下。最后半小时集体迫害 fls。</p>
<h3 id="Day2"><a href="#Day2" class="headerlink" title="Day2"></a>Day2</h3><p>PJ 400 </p>
<p>TG 65+100+88+0。</p>
<p>很无语 T3 数据分治我就 100 了，T1 数据分治 80。</p>
<p>infoj 测了下 TG :40+100+80，T3 数据分治也是 $100$…</p>
<p>感觉就是我的下限和上线，应该可以 TG1&#x3D; 吧。</p>
<h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>55+100+56&#x3D;211</p>
<p>为什么有人三分都A了？？？</p>
<p>大概是1&#x3D;了</p>
]]></content>
      <tags>
        <tag>游记</tag>
      </tags>
  </entry>
  <entry>
    <title>CSP2022游记</title>
    <url>/2022/11/05/CSP2022%E6%B8%B8%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="CSP2022-绍兴一日游"><a href="#CSP2022-绍兴一日游" class="headerlink" title="CSP2022 绍兴一日游"></a>CSP2022 绍兴一日游</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>停课两个星期，去年老叶可没有这样的力度。看来是真想出点成绩了。</p>
<p>可惜的是停课的第二个星期是运动会，没法好好玩了（悲。</p>
<p>讲讲停课生活也没什么意思，不如直接讲讲比赛。</p>
<p>宣传一下<a href="https://www.bilibili.com/video/BV1fe4y177T5">运动会拍的视频</a></p>
<h3 id="Day0"><a href="#Day0" class="headerlink" title="Day0"></a>Day0</h3><h4 id="01"><a href="#01" class="headerlink" title="01"></a>01</h4><p>去绍兴。</p>
<p><img src="https://s2.loli.net/2022/11/06/d9oh7D5VufLsEYO.jpg"></p>
<p>世界名画。</p>
<h4 id="02"><a href="#02" class="headerlink" title="02"></a>02</h4><p><img src="https://s2.loli.net/2022/11/10/YxyNUW5Os1ebd3G.jpg"></p>
<p>车上打了两把五排全输了，索性就开始干点别的。车程大概4个小时，挺无趣的。</p>
<p>酒店是<strong>全季</strong>酒店，预示着要全季了。</p>
<p>住是和 xyh 一起的。</p>
<h4 id="03"><a href="#03" class="headerlink" title="03"></a>03</h4><p>晚饭不出意外的是老娘舅。于是七点多和 js 去外面找点乐子。</p>
<p>然后刚出去五分钟，yzx 就打电话问我们要不要出来。</p>
<p>腾讯的共享定位重合了，但是我还是没看见他在哪里。</p>
<p>”您在哪里“</p>
<p>”我们不是重合了吗？“</p>
<p>”我好像听见你声音了“</p>
<p>”有没有一种可能他在我们对面“</p>
<p>”你在马路左边还是右边“</p>
<p>”左右不是相对的吗“</p>
<p>”你在马路东边还是西边“</p>
<p>原来真在马路对面。</p>
<p><img src="https://s2.loli.net/2022/11/10/9eEqMx6h73jvVSl.jpg"></p>
<h4 id="04"><a href="#04" class="headerlink" title="04"></a>04</h4><p>然后去坐地铁，说是要体验一点大城市不一样的。</p>
<p>yzx 说坐一站就有万达，遂跟着他走。</p>
<p><img src="https://s2.loli.net/2022/11/10/exouqHiEUpbyDdn.jpg"></p>
<h4 id="05"><a href="#05" class="headerlink" title="05"></a>05</h4><p>P都没有。开始咒骂 yzx。</p>
<p>倒是看见了一家火锅店，我跟cqy都想吃火锅了。</p>
<p>yzx说再找找，然后就在一个神奇会所旁边找到了麦当劳。</p>
<p>虽然没有第二个半价，不得不说麦旋风真的香。</p>
<p><img src="https://s2.loli.net/2022/11/10/WmFt8phavOgMPeV.jpg"></p>
<h4 id="06"><a href="#06" class="headerlink" title="06"></a>06</h4><p>我们应该在郊区。</p>
<p>天空飘起了小雨，不得不说绍兴还是很美的。水很多，桥也很多。</p>
<p>雨不大，也更愿意看看绍兴，就四个人去骑自行车了。</p>
<p><img src="https://s2.loli.net/2022/11/10/h4n2FoB7TyH9MPJ.jpg"></p>
<h4 id="07"><a href="#07" class="headerlink" title="07"></a>07</h4><p>yzx 骑得很快，但是他想回去了。cqy 不太会骑，js 的自行车不是很正常。</p>
<p>我就带着两个<del>残废</del>开始游绍兴。</p>
<p>小河旁边的路骑起来很舒服，有微风，但也不会特别冷。</p>
<p>这个地方在我看来有点神秘。抬头是随处可见的高楼，低头确实县城小巷般的街，零星几个很小的小卖部和几家新开的饭店。</p>
<p><img src="https://s2.loli.net/2022/11/10/LTGArVoM3QZkKE6.jpg"></p>
<p><img src="https://s2.loli.net/2022/11/10/VlKUN3SOCERMTXu.jpg"></p>
<h4 id="08"><a href="#08" class="headerlink" title="08"></a>08</h4><p>打车回酒店，剪了会视频，就睡觉了。</p>
<p>第二天被工地吵醒，原来是窗户没关。</p>
<p>为什么每年比赛旁边的酒店都有工地。</p>
<p>因为昨天晚上既没去成万达，也没吃上火锅。9点就开始规划去哪里吃火锅了。</p>
<h3 id="Day1"><a href="#Day1" class="headerlink" title="Day1"></a>Day1</h3><h4 id="09"><a href="#09" class="headerlink" title="09"></a>09</h4><p>搞了半天 yzx 不去。</p>
<p>有 cqy 狗哥 yjc wyt ，坐电梯的时候碰见 hzy，就一起叫上了。</p>
<p>到了才发现，是昨天晚上看见的那个火锅店。</p>
<p><img src="https://s2.loli.net/2022/11/10/EkBulQisNPRHXKM.jpg"></p>
<p>吃了六百多，味道还可以，就是量有点少。难得出来不得奢侈一把&#x2F;se</p>
<h4 id="10"><a href="#10" class="headerlink" title="10"></a>10</h4><p>走路回去。</p>
<p>蓝天，白云，河流，同学。</p>
<p><img src="https://s2.loli.net/2022/11/10/EftdBbZA2ng1iD6.jpg"></p>
<p><img src="https://s2.loli.net/2022/11/10/TQbaVUtYB1ndOq6.jpg"></p>
<h3 id="比赛"><a href="#比赛" class="headerlink" title="比赛"></a>比赛</h3><h4 id="11"><a href="#11" class="headerlink" title="11"></a>11</h4><p>讲讲比赛。</p>
<p>旁边的初二的，看上去比我还成熟，张的不错，一进来就跟我打招呼。</p>
<p>开考前十分钟就有密码了。</p>
<p>第一眼看T1看成恰好为 $k$ 次，怎么想矩阵乘法还是暴力，预处理就T了。</p>
<p>然后去看T2，是个傻子题。</p>
<p>回来看T1，原来是最短路，没事了。</p>
<p>继续想，枚举 BC，然后取前三个最大值就好了。写完大概开考20min。</p>
<p>码完线段树暴力枚举上去，一遍过大样例，大概40min。</p>
<p>开 T3。</p>
<p>大概在 5min 就想到了充要条件是每个点的出度都为 $1$。然后就会了 $60$ 分的暴力。</p>
<p>然后就开始往入度上的充要条件去想，发现如果是充要的就跟连通性有关。就去看 T4。</p>
<p>一眼有点像 ddp，还是不带修的。</p>
<p>然后推矩阵，发现不太好维护（赛后：我就是个傻逼</p>
<p>看见随即性质，一定是在提醒我树高！于是码了个点分树。</p>
<p>发现 $k&#x3D;3$ 的点死活过不去。原来是可以走到路径的旁边节点中转一下再跳，发现点分树处理不了，悲伤。但是 $k&#x3D;2$ 的情况似乎可以做。然后就开开心心开始写数据分治。</p>
<p>$k&#x3D;3$ 的小数据一下就过去了，大数据没过去。然后去把 T3 暴力写完了。回来又想了 1h ，发现是可以连续跳的链外面的点的。</p>
<p>还有半个小时码完了 76 分。</p>
<p>最后没事干，感觉那个随机的点不就是把链拿出来做一遍线性dp。就开始魔改。</p>
<p>还有5分钟的时候写过的。有点惊险。</p>
<p>出考场估分：100+100+60+88</p>
<h4 id="12"><a href="#12" class="headerlink" title="12"></a>12</h4><p>看来大家好像都很好，看来是比赛太简单了。fxt T3切了，zj T4切了，指导应该很早就AK了。</p>
<h4 id="13"><a href="#13" class="headerlink" title="13"></a>13</h4><p>回去的路上很有意思。一开始在看足球。后面就和 xjz 辩论了两个小时。意识很清醒，没有想睡觉的感觉。可能是愤怒，或者无语，抑或是别的？</p>
<h4 id="14"><a href="#14" class="headerlink" title="14"></a>14</h4><p>回家测民间数据。一分没挂。</p>
<p>就是T4因为开了map，有几个点是接近三秒跑过去的，可能会挂到72左右，不过前面没挂分也算很不错了。</p>
<h3 id="Day-？？？"><a href="#Day-？？？" class="headerlink" title="Day ？？？"></a>Day ？？？</h3><h4 id="15"><a href="#15" class="headerlink" title="15"></a>15</h4><p>似乎排名还不错。T3谁跟我提了一下哈希就想出来了。</p>
<p>C。</p>
<h3 id="Day"><a href="#Day" class="headerlink" title="Day ???"></a>Day ???</h3><p>100+100+60+88&#x3D;348</p>
<p>T3要是剩下情况全输出NO还能多20分，，，</p>
]]></content>
      <tags>
        <tag>游记</tag>
      </tags>
  </entry>
  <entry>
    <title>DS加训 [CSP-S2019] 树的重心</title>
    <url>/2023/09/06/DS%E5%8A%A0%E8%AE%AD-CSP-S2019-%E6%A0%91%E7%9A%84%E9%87%8D%E5%BF%83/</url>
    <content><![CDATA[<h1 id="P5666-CSP-S2019-树的重心"><a href="#P5666-CSP-S2019-树的重心" class="headerlink" title="P5666 [CSP-S2019] 树的重心"></a>P5666 [CSP-S2019] 树的重心</h1><p>DS加训！</p>
<h2 id="Solution1"><a href="#Solution1" class="headerlink" title="Solution1"></a>Solution1</h2><p>考虑一个经典结论，一棵树的重心是 <strong>dfs 序中位数的祖先</strong>。</p>
<p>然后直接对于断掉的每条边倍增找。注意如果<strong>有两个中位数，要取后面的那个</strong>。还要判断有两个重心的情况。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 300005</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt;to[maxn];</span><br><span class="line"><span class="type">int</span> n,times;</span><br><span class="line"><span class="type">int</span> siz[maxn],dfn[maxn],son[maxn],ss[maxn],fa[maxn][<span class="number">21</span>],lg[maxn],p[maxn];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">	<span class="type">int</span> l,r,flag;</span><br><span class="line">	<span class="built_in">node</span>(<span class="type">int</span> a=<span class="number">0</span>,<span class="type">int</span> b=<span class="number">0</span>,<span class="type">int</span> c=<span class="number">0</span>) &#123;l=a;r=b;flag=c;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;node&gt;O[maxn];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> pre)</span> </span>&#123;</span><br><span class="line">	fa[x][<span class="number">0</span>]=pre;siz[x]=<span class="number">1</span>;dfn[x]=++times;p[times]=x;son[x]=ss[x]=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">19</span>;i++) fa[x][i]=fa[fa[x][i<span class="number">-1</span>]][i<span class="number">-1</span>];	</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> y:to[x]) <span class="keyword">if</span> (y^pre) &#123;</span><br><span class="line">		<span class="built_in">dfs</span>(y,x);siz[x]+=siz[y];</span><br><span class="line">		<span class="keyword">if</span> (siz[son[x]]&lt;=siz[y]) ss[x]=son[x],son[x]=y;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (siz[ss[x]]&lt;=siz[y]) ss[x]=y;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">BIT</span>&#123;</span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> lowbit(x) ((x)&amp;(-x))</span></span><br><span class="line">	<span class="type">int</span> f[maxn];</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span> </span>&#123;<span class="keyword">for</span> (;x&lt;=n;x+=<span class="built_in">lowbit</span>(x)) f[x]+=y;&#125;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;<span class="type">int</span> sum=<span class="number">0</span>;x=<span class="built_in">max</span>(x,<span class="number">0</span>);<span class="keyword">for</span> (;x;x-=<span class="built_in">lowbit</span>(x)) sum+=f[x];<span class="keyword">return</span> sum;&#125;</span><br><span class="line">&#125;t;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">calcsiz</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (dfn[x]&lt;=dfn[y]&amp;&amp;dfn[y]&lt;dfn[x]+siz[x]) <span class="keyword">return</span> siz[x]-siz[y];</span><br><span class="line">	<span class="keyword">return</span> siz[x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> i,x,j,y;ll ans=<span class="number">0</span>;times=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">read</span>(n);</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) O[i].<span class="built_in">clear</span>(),to[i].<span class="built_in">clear</span>();</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;n;i++) <span class="built_in">read</span>(x),<span class="built_in">read</span>(y),to[x].<span class="built_in">push_back</span>(y),to[y].<span class="built_in">push_back</span>(x);</span><br><span class="line">	<span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">2</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		x=p[(dfn[i]+dfn[i]+siz[i])/<span class="number">2</span>];</span><br><span class="line">		<span class="keyword">if</span> (siz[i]-siz[x]&gt;siz[i]/<span class="number">2</span>) &#123;</span><br><span class="line">			<span class="keyword">for</span> (j=<span class="number">20</span>;j&gt;=<span class="number">0</span>;j--) <span class="keyword">if</span> (dfn[fa[x][j]]&gt;=dfn[i]&amp;&amp;siz[i]-siz[fa[x][j]]&gt;siz[i]/<span class="number">2</span>) x=fa[x][j];	</span><br><span class="line">			x=fa[x][<span class="number">0</span>];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (dfn[x]&lt;dfn[i]) <span class="keyword">continue</span>;</span><br><span class="line">		<span class="type">int</span> Max=siz[son[x]];</span><br><span class="line">		<span class="keyword">if</span> (Max&lt;=siz[i]/<span class="number">2</span>) ans+=x;</span><br><span class="line">		</span><br><span class="line">		x=fa[x][<span class="number">0</span>];<span class="keyword">if</span> (dfn[x]&lt;dfn[i]) <span class="keyword">continue</span>;</span><br><span class="line">		Max=siz[son[x]];</span><br><span class="line">		<span class="keyword">if</span> (Max&lt;=siz[i]/<span class="number">2</span>) ans+=x;</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">2</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="type">int</span> tmp=(<span class="number">2</span>+n-siz[i])/<span class="number">2</span>;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">tmp</span>&lt;dfn[i]) x=p[tmp];</span><br><span class="line">		<span class="keyword">else</span> x=p[tmp-dfn[i]+(dfn[i]+siz[i])];</span><br><span class="line">		<span class="keyword">if</span> (n-<span class="built_in">calcsiz</span>(x,i)-siz[i]&gt;(n-siz[i])/<span class="number">2</span>) &#123;</span><br><span class="line">			<span class="keyword">for</span> (j=<span class="number">20</span>;j&gt;=<span class="number">0</span>;j--) <span class="keyword">if</span> (fa[x][j]&amp;&amp;n-<span class="built_in">calcsiz</span>(fa[x][j],i)-siz[i]&gt;(n-siz[i])/<span class="number">2</span>) x=fa[x][j];</span><br><span class="line">			x=fa[x][<span class="number">0</span>];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (!x) <span class="keyword">continue</span>;</span><br><span class="line">		<span class="type">int</span> Max=<span class="built_in">max</span>(<span class="built_in">calcsiz</span>(son[x],i),<span class="built_in">calcsiz</span>(ss[x],i));</span><br><span class="line">		<span class="keyword">if</span> (Max&lt;=(n-siz[i])/<span class="number">2</span>) ans+=x;</span><br><span class="line">		x=fa[x][<span class="number">0</span>];<span class="keyword">if</span> (!x) <span class="keyword">continue</span>;</span><br><span class="line">		Max=<span class="built_in">max</span>(<span class="built_in">calcsiz</span>(son[x],i),<span class="built_in">calcsiz</span>(ss[x],i));</span><br><span class="line">		<span class="keyword">if</span> (Max&lt;=(n-siz[i])/<span class="number">2</span>) ans+=x;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> T;</span><br><span class="line">	<span class="built_in">read</span>(T);</span><br><span class="line">	<span class="keyword">while</span> (T--) <span class="built_in">solve</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="Solution2"><a href="#Solution2" class="headerlink" title="Solution2"></a>Solution2</h2><p>还有一种是算贡献。根据 $x$ 如果不是整颗树的重心，则要想 $x$ 删去一条边以后成为重心，删的边一定不在 $x$ 子树内这个性质，分成 $x$ 是否为整棵树的重心进行讨论。</p>
<p>但是已经过题了就不想写了。</p>
]]></content>
      <tags>
        <tag>数据结构</tag>
        <tag>树的重心</tag>
      </tags>
  </entry>
  <entry>
    <title>HHHOJ周赛01</title>
    <url>/2023/06/22/HHHOJ%E5%91%A8%E8%B5%9B01/</url>
    <content><![CDATA[<h2 id="A-「JOISC-2014」巴士走读"><a href="#A-「JOISC-2014」巴士走读" class="headerlink" title="A. 「JOISC 2014」巴士走读"></a><a href="https://loj.ac/p/2872">A. 「JOISC 2014」巴士走读</a></h2><p>考虑预处理出第 $t$ 时刻到 $x$ <strong>从起点出发</strong>的最大时刻，用 $f[x][t]$ 表示。</p>
<p>记一条边 $(x,y,a,b)$ 表示从 $x$ 到 $y$ ，第 $a$ 时刻开向 $b$ 时刻。让所有边按照 $b$ 升序排序。</p>
<p>对于一条边，找到从上一条边转移过来的最大时刻。</p>
<p>显然，如果 $a&lt;b,f[x][a]&gt;f[x][b]$ ，那么 $b$ 是没有意义的。</p>
<p>我们要对每个结点维护一个序列，二分查找，和从后面加入数。用 vector 解决。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 300005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> put() putchar(<span class="string">&#x27;\n&#x27;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Tp template<span class="string">&lt;typename Ty&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Ts template<span class="string">&lt;typename Ty,typename... Ar&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(<span class="type">int</span> &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> f=<span class="number">1</span>;x=<span class="number">0</span>;<span class="type">char</span> c=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (c&lt;<span class="string">&#x27;0&#x27;</span>||c&gt;<span class="string">&#x27;9&#x27;</span>) &#123;<span class="keyword">if</span> (c==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">-1</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span> (c&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;c&lt;=<span class="string">&#x27;9&#x27;</span>) &#123;x=x*<span class="number">10</span>+c-<span class="string">&#x27;0&#x27;</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> Debug&#123;</span><br><span class="line">	Tp <span class="type">void</span> _debug(<span class="type">char</span>* f,Ty t)&#123;cerr&lt;&lt;f&lt;&lt;<span class="string">&#x27;=&#x27;</span>&lt;&lt;t&lt;&lt;endl;&#125;</span><br><span class="line">	Ts <span class="type">void</span> _debug(<span class="type">char</span>* f,Ty x,Ar... y)&#123;<span class="keyword">while</span>(*f!=<span class="string">&#x27;,&#x27;</span>) cerr&lt;&lt;*f++;cerr&lt;&lt;<span class="string">&#x27;=&#x27;</span>&lt;&lt;x&lt;&lt;<span class="string">&quot;,&quot;</span>;_debug(f+<span class="number">1</span>,y...);&#125;</span><br><span class="line">	Tp ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; os,vector&lt;Ty&gt;&amp; V)&#123;os&lt;&lt;<span class="string">&quot;[&quot;</span>;<span class="keyword">for</span>(<span class="keyword">auto</span>&amp; vv:V) os&lt;&lt;vv&lt;&lt;<span class="string">&quot;,&quot;</span>;os&lt;&lt;<span class="string">&quot;]&quot;</span>;<span class="keyword">return</span> os;&#125;</span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> gdb(...) _debug((char*)#__VA_ARGS__,__VA_ARGS__)</span></span><br><span class="line">&#125;<span class="keyword">using</span> <span class="keyword">namespace</span> Debug;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">yyy</span>&#123;</span><br><span class="line">	<span class="type">int</span> x,y,a,b;</span><br><span class="line">&#125;a[maxn];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">cmp</span><span class="params">(yyy x,yyy y)</span> </span>&#123;<span class="keyword">return</span> x.b&lt;y.b;&#125;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;ans1[maxn],ans2[maxn];</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> i,x,y,tmp1,tmp2,tmp;</span><br><span class="line">	<span class="built_in">read</span>(n);<span class="built_in">read</span>(m);</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=m;i++) <span class="built_in">read</span>(a[i].x),<span class="built_in">read</span>(a[i].y),<span class="built_in">read</span>(a[i].a),<span class="built_in">read</span>(a[i].b);</span><br><span class="line">	<span class="built_in">sort</span>(a+<span class="number">1</span>,a+<span class="number">1</span>+m,cmp);</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) ans1[i].<span class="built_in">push_back</span>(<span class="number">-1</span>),ans2[i].<span class="built_in">push_back</span>(<span class="number">-1</span>);</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=m;i++) &#123;</span><br><span class="line">		x=a[i].x,y=a[i].y,tmp1=a[i].a,tmp2=a[i].b;</span><br><span class="line">		<span class="keyword">if</span> (x==<span class="number">1</span>) tmp=tmp1;</span><br><span class="line">		<span class="keyword">else</span> tmp=ans2[x][<span class="built_in">upper_bound</span>(ans1[x].<span class="built_in">begin</span>(),ans1[x].<span class="built_in">end</span>(),tmp1)-ans1[x].<span class="built_in">begin</span>()<span class="number">-1</span>];</span><br><span class="line">		<span class="keyword">if</span> (tmp&gt;ans2[y][ans2[y].<span class="built_in">size</span>()<span class="number">-1</span>]) ans2[y].<span class="built_in">push_back</span>(tmp),ans1[y].<span class="built_in">push_back</span>(tmp2);</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="type">int</span> Q;</span><br><span class="line">	<span class="built_in">read</span>(Q);</span><br><span class="line">	<span class="keyword">while</span> (Q--) &#123;</span><br><span class="line">		<span class="built_in">read</span>(x);</span><br><span class="line">		<span class="type">int</span> id=<span class="built_in">upper_bound</span>(ans1[n].<span class="built_in">begin</span>(),ans1[n].<span class="built_in">end</span>(),x)-ans1[n].<span class="built_in">begin</span>()<span class="number">-1</span>;</span><br><span class="line">		<span class="keyword">if</span> (id==<span class="number">0</span>) <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>);</span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans2[n][id]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="B-「JOISC-2014-Day1」有趣的家庭菜园"><a href="#B-「JOISC-2014-Day1」有趣的家庭菜园" class="headerlink" title="B.「JOISC 2014 Day1」有趣的家庭菜园"></a><a href="https://loj.ac/p/2873">B.「JOISC 2014 Day1」有趣的家庭菜园</a></h2><p>有一个非常愚蠢的想法。枚举最后最大值所在的位置，分别正反做两遍逆序对加起来求最小。这样是不对的。</p>
<p>考虑贪心。将 $h$ 升序排序。每次将在 $h$ 前面的个数和在 $h$ 后面的个数取最小值。表示放左边或者放右边产生的贡献。</p>
<p>$h$ 相同的情况特殊处理。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 300005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> put() putchar(<span class="string">&#x27;\n&#x27;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Tp template<span class="string">&lt;typename Ty&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Ts template<span class="string">&lt;typename Ty,typename... Ar&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(<span class="type">int</span> &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> f=<span class="number">1</span>;x=<span class="number">0</span>;<span class="type">char</span> c=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (c&lt;<span class="string">&#x27;0&#x27;</span>||c&gt;<span class="string">&#x27;9&#x27;</span>) &#123;<span class="keyword">if</span> (c==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">-1</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span> (c&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;c&lt;=<span class="string">&#x27;9&#x27;</span>) &#123;x=x*<span class="number">10</span>+c-<span class="string">&#x27;0&#x27;</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> Debug&#123;</span><br><span class="line">	Tp <span class="type">void</span> _debug(<span class="type">char</span>* f,Ty t)&#123;cerr&lt;&lt;f&lt;&lt;<span class="string">&#x27;=&#x27;</span>&lt;&lt;t&lt;&lt;endl;&#125;</span><br><span class="line">	Ts <span class="type">void</span> _debug(<span class="type">char</span>* f,Ty x,Ar... y)&#123;<span class="keyword">while</span>(*f!=<span class="string">&#x27;,&#x27;</span>) cerr&lt;&lt;*f++;cerr&lt;&lt;<span class="string">&#x27;=&#x27;</span>&lt;&lt;x&lt;&lt;<span class="string">&quot;,&quot;</span>;_debug(f+<span class="number">1</span>,y...);&#125;</span><br><span class="line">	Tp ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; os,vector&lt;Ty&gt;&amp; V)&#123;os&lt;&lt;<span class="string">&quot;[&quot;</span>;<span class="keyword">for</span>(<span class="keyword">auto</span>&amp; vv:V) os&lt;&lt;vv&lt;&lt;<span class="string">&quot;,&quot;</span>;os&lt;&lt;<span class="string">&quot;]&quot;</span>;<span class="keyword">return</span> os;&#125;</span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> gdb(...) _debug((char*)#__VA_ARGS__,__VA_ARGS__)</span></span><br><span class="line">&#125;<span class="keyword">using</span> <span class="keyword">namespace</span> Debug;</span><br><span class="line"><span class="type">int</span> n,cnt,f[maxn],g[maxn],ff[maxn],ans=<span class="number">1e18</span>,a[maxn],b[maxn]; </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">BIT</span>&#123;</span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> lowbit(x) ((x)&amp;(-x))</span></span><br><span class="line">	<span class="type">int</span> f[maxn];</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span> </span>&#123;<span class="keyword">for</span> (;x&lt;=n;x+=<span class="built_in">lowbit</span>(x)) f[x]+=y;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;<span class="type">int</span> sum=<span class="number">0</span>;<span class="keyword">for</span> (;x;x-=<span class="built_in">lowbit</span>(x)) sum+=f[x];<span class="keyword">return</span> sum;&#125;</span><br><span class="line">&#125;t;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;O[maxn];</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> i,j,x;</span><br><span class="line">	<span class="built_in">read</span>(n);</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">read</span>(a[i]),g[++cnt]=a[i];</span><br><span class="line">	<span class="built_in">sort</span>(g+<span class="number">1</span>,g+<span class="number">1</span>+cnt);</span><br><span class="line">	cnt=<span class="built_in">unique</span>(g+<span class="number">1</span>,g+<span class="number">1</span>+cnt)-g<span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) a[i]=<span class="built_in">lower_bound</span>(g+<span class="number">1</span>,g+<span class="number">1</span>+cnt,a[i])-g,O[a[i]].<span class="built_in">push_back</span>(i);</span><br><span class="line">	<span class="type">int</span> nums=<span class="number">0</span>,ans=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (i=cnt;i&gt;=<span class="number">1</span>;i--) &#123;</span><br><span class="line">		<span class="type">int</span> len=O[i].<span class="built_in">size</span>();</span><br><span class="line">		<span class="keyword">for</span> (j=<span class="number">0</span>;j&lt;len;j++) &#123;</span><br><span class="line">			</span><br><span class="line">			x=t.<span class="built_in">query</span>(O[i][j]);</span><br><span class="line">			ans+=<span class="built_in">min</span>(x,nums-x);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (j=<span class="number">0</span>;j&lt;len;j++) t.<span class="built_in">add</span>(O[i][j],<span class="number">1</span>),nums++;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">//	for (i=1;i&lt;=n;i++) &#123;</span></span><br><span class="line"><span class="comment">//		f[i]=f[i-1]+(i-1)-t.query(a[i]);</span></span><br><span class="line"><span class="comment">//		t.add(a[i],1);</span></span><br><span class="line"><span class="comment">//	&#125;</span></span><br><span class="line"><span class="comment">//	memset(t.f,0,sizeof(t.f));</span></span><br><span class="line"><span class="comment">//	for (i=1;i&lt;=n;i++) b[n-i+1]=a[i];</span></span><br><span class="line"><span class="comment">//	for (i=1;i&lt;=n;i++) &#123;</span></span><br><span class="line"><span class="comment">//		g[i]=g[i-1]+(i-1)-t.query(b[i]);</span></span><br><span class="line"><span class="comment">//		t.add(b[i],1);</span></span><br><span class="line"><span class="comment">//	&#125;</span></span><br><span class="line"><span class="comment">//	for (i=1;i&lt;=n;i++) ans=min(ans,f[i-1]+g[n-i+1]);</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="C-「JOISC-2014」历史研究"><a href="#C-「JOISC-2014」历史研究" class="headerlink" title="C. 「JOISC 2014」历史研究"></a>C. 「JOISC 2014」历史研究</h2><p>回滚莫队经典题。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 100005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> put() putchar(<span class="string">&#x27;\n&#x27;</span>)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(<span class="type">int</span> &amp;x)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> f=<span class="number">1</span>;x=<span class="number">0</span>;<span class="type">char</span> c=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span> (c&lt;<span class="string">&#x27;0&#x27;</span>||c&gt;<span class="string">&#x27;9&#x27;</span>) &#123;<span class="keyword">if</span> (c==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">-1</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">while</span> (c&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;c&lt;=<span class="string">&#x27;9&#x27;</span>) &#123;x=x*<span class="number">10</span>+c-<span class="string">&#x27;0&#x27;</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,m,block;</span><br><span class="line"><span class="type">int</span> t[maxn],a[maxn],g[maxn],w[maxn];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">yyy</span>&#123;</span><br><span class="line">	<span class="type">int</span> l,r,id,bl;</span><br><span class="line">&#125;q[maxn];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">cmp</span><span class="params">(yyy x,yyy y)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (x.bl==y.bl) <span class="keyword">return</span> x.r&lt;y.r;</span><br><span class="line">	<span class="keyword">return</span> x.bl&lt;y.bl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> stac[maxn],tot,ans,Ans[maxn];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">	t[a[x]]++;ans=<span class="built_in">max</span>(ans,t[a[x]]*w[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> l=<span class="number">1</span>,r=<span class="number">0</span>,last_block=<span class="number">0</span>,ql,qr,j,i;</span><br><span class="line">    <span class="built_in">read</span>(n);<span class="built_in">read</span>(m);block=n/<span class="built_in">sqrt</span>(m)+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">read</span>(a[i]),g[i]=w[i]=a[i];</span><br><span class="line">    <span class="built_in">sort</span>(g+<span class="number">1</span>,g+<span class="number">1</span>+n);<span class="type">int</span> tot=<span class="built_in">unique</span>(g+<span class="number">1</span>,g+<span class="number">1</span>+n)-g<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) a[i]=<span class="built_in">lower_bound</span>(g+<span class="number">1</span>,g+<span class="number">1</span>+tot,a[i])-g<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=m;i++) &#123;</span><br><span class="line">    	<span class="built_in">read</span>(q[i].l);<span class="built_in">read</span>(q[i].r);</span><br><span class="line">    	q[i].bl=(q[i].l<span class="number">-1</span>)/block+<span class="number">1</span>;</span><br><span class="line">    	q[i].id=i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">sort</span>(q+<span class="number">1</span>,q+<span class="number">1</span>+m,cmp);</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=m;i++) &#123;</span><br><span class="line">		ql=q[i].l,qr=q[i].r;</span><br><span class="line">		<span class="keyword">if</span> (last_block!=q[i].bl)&#123;</span><br><span class="line">			l=q[i].bl*block+<span class="number">1</span>;r=l<span class="number">-1</span>;</span><br><span class="line">			<span class="keyword">for</span> (j=<span class="number">0</span>;j&lt;=n;j++) t[j]=<span class="number">0</span>;</span><br><span class="line">			tot=<span class="number">0</span>;ans=<span class="number">0</span>;last_block=q[i].bl;</span><br><span class="line">		&#125;<span class="comment">//printf(&quot;%lld %lld %lld %lld %lld\n&quot;,ans,l,r,ql,qr);</span></span><br><span class="line">		<span class="keyword">if</span> ((q[i].l<span class="number">-1</span>)/block==(q[i].r<span class="number">-1</span>)/block) &#123;</span><br><span class="line">			<span class="keyword">for</span> (j=q[i].l;j&lt;=q[i].r;j++) t[a[j]]++;</span><br><span class="line">			<span class="keyword">for</span> (j=q[i].l;j&lt;=q[i].r;j++) ans=<span class="built_in">max</span>(ans,t[a[j]]*w[j]);</span><br><span class="line">			<span class="keyword">for</span> (j=q[i].l;j&lt;=q[i].r;j++) t[a[j]]=<span class="number">0</span>;</span><br><span class="line">			Ans[q[i].id]=ans;ans=<span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">while</span> (r&lt;qr) <span class="built_in">add</span>(++r);</span><br><span class="line">			<span class="keyword">while</span> (l&gt;ql) stac[++tot]=ans,<span class="built_in">add</span>(--l);</span><br><span class="line">			Ans[q[i].id]=ans;</span><br><span class="line">			<span class="keyword">while</span> (tot) &#123;</span><br><span class="line">				ans=stac[tot];</span><br><span class="line">				t[a[l]]--;l++;tot--;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=m;i++) <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,Ans[i]);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="D-「JOISC-2014」水壶"><a href="#D-「JOISC-2014」水壶" class="headerlink" title="D. 「JOISC 2014」水壶"></a>D. 「JOISC 2014」水壶</h2><p>bfs 建最小生成树，查询 lca 跑路径之间最大值。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 200005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxm 4005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> put() putchar(<span class="string">&#x27;\n&#x27;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Tp template<span class="string">&lt;typename Ty&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Ts template<span class="string">&lt;typename Ty,typename... Ar&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(<span class="type">int</span> &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> f=<span class="number">1</span>;x=<span class="number">0</span>;<span class="type">char</span> c=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (c&lt;<span class="string">&#x27;0&#x27;</span>||c&gt;<span class="string">&#x27;9&#x27;</span>) &#123;<span class="keyword">if</span> (c==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">-1</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span> (c&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;c&lt;=<span class="string">&#x27;9&#x27;</span>) &#123;x=x*<span class="number">10</span>+c-<span class="string">&#x27;0&#x27;</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> Debug&#123;</span><br><span class="line">	Tp <span class="type">void</span> _debug(<span class="type">char</span>* f,Ty t)&#123;cerr&lt;&lt;f&lt;&lt;<span class="string">&#x27;=&#x27;</span>&lt;&lt;t&lt;&lt;endl;&#125;</span><br><span class="line">	Ts <span class="type">void</span> _debug(<span class="type">char</span>* f,Ty x,Ar... y)&#123;<span class="keyword">while</span>(*f!=<span class="string">&#x27;,&#x27;</span>) cerr&lt;&lt;*f++;cerr&lt;&lt;<span class="string">&#x27;=&#x27;</span>&lt;&lt;x&lt;&lt;<span class="string">&quot;,&quot;</span>;_debug(f+<span class="number">1</span>,y...);&#125;</span><br><span class="line">	Tp ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; os,vector&lt;Ty&gt;&amp; V)&#123;os&lt;&lt;<span class="string">&quot;[&quot;</span>;<span class="keyword">for</span>(<span class="keyword">auto</span>&amp; vv:V) os&lt;&lt;vv&lt;&lt;<span class="string">&quot;,&quot;</span>;os&lt;&lt;<span class="string">&quot;]&quot;</span>;<span class="keyword">return</span> os;&#125;</span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> gdb(...) _debug((char*)#__VA_ARGS__,__VA_ARGS__)</span></span><br><span class="line">&#125;<span class="keyword">using</span> <span class="keyword">namespace</span> Debug;</span><br><span class="line"><span class="type">int</span> a[maxm][maxm],n,m,p,T;</span><br><span class="line"><span class="type">int</span> fa[maxn][<span class="number">21</span>],Max[maxn][<span class="number">21</span>],lg[maxn],deep[maxn];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">zyq</span>&#123;</span><br><span class="line">	<span class="type">int</span> to,w;</span><br><span class="line">	<span class="built_in">zyq</span>(<span class="type">int</span> a=<span class="number">0</span>,<span class="type">int</span> b=<span class="number">0</span>) &#123;to=a;w=b;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> ecnt;</span><br><span class="line">vector&lt;zyq&gt;to[<span class="number">200005</span>];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">	<span class="type">int</span> x,y,id;</span><br><span class="line">	<span class="built_in">node</span> (<span class="type">int</span> a=<span class="number">0</span>,<span class="type">int</span> b=<span class="number">0</span>,<span class="type">int</span> c=<span class="number">0</span>) &#123;</span><br><span class="line">		x=a;y=b;id=c;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;g[maxn];</span><br><span class="line">vector&lt;node&gt;e[<span class="number">4000005</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> pre,<span class="type">int</span> w)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> i;deep[x]=deep[pre]+<span class="number">1</span>;fa[x][<span class="number">0</span>]=pre;Max[x][<span class="number">0</span>]=w;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=<span class="number">20</span>;i++) &#123;</span><br><span class="line">		fa[x][i]=fa[fa[x][i<span class="number">-1</span>]][i<span class="number">-1</span>];</span><br><span class="line">		Max[x][i]=<span class="built_in">max</span>(Max[x][i<span class="number">-1</span>],Max[fa[x][i<span class="number">-1</span>]][i<span class="number">-1</span>]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> tmp:to[x]) <span class="keyword">if</span> (tmp.to^pre) <span class="built_in">dfs</span>(tmp.to,x,tmp.w);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> ans=<span class="number">0</span>,i;</span><br><span class="line">	<span class="keyword">if</span> (deep[x]&lt;deep[y]) <span class="built_in">swap</span>(x,y);</span><br><span class="line">	<span class="keyword">while</span> (deep[x]&gt;deep[y]) ans=<span class="built_in">max</span>(ans,Max[x][lg[deep[x]-deep[y]]]),x=fa[x][lg[deep[x]-deep[y]]];</span><br><span class="line">	<span class="keyword">if</span> (x==y) <span class="keyword">return</span> ans;</span><br><span class="line">	<span class="keyword">for</span> (i=lg[deep[x]];i&gt;=<span class="number">0</span>;i--) <span class="keyword">if</span> (fa[x][i]^fa[y][i]) &#123;</span><br><span class="line">		ans=<span class="built_in">max</span>(ans,<span class="built_in">max</span>(Max[x][i],Max[y][i]));</span><br><span class="line">		x=fa[x][i],y=fa[y][i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">max</span>(ans,<span class="built_in">max</span>(Max[x][<span class="number">0</span>],Max[y][<span class="number">0</span>]));</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> fx[<span class="number">5</span>]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,fy[<span class="number">5</span>]=&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>&#125;;</span><br><span class="line"><span class="type">int</span> vis[maxm][maxm],dis[maxm][maxm];</span><br><span class="line"><span class="type">int</span> father[maxn];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">getfa</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;<span class="keyword">return</span> x==father[x]?x:father[x]=<span class="built_in">getfa</span>(father[x]);&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">cmp</span><span class="params">(node x,node y)</span> </span>&#123;<span class="keyword">return</span> x.id&lt;y.id;&#125;</span><br><span class="line">queue&lt;node&gt;q;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> i,j,k,xx,yy,x,y,z;<span class="type">char</span> ch;</span><br><span class="line">	<span class="built_in">read</span>(n);<span class="built_in">read</span>(m);<span class="built_in">read</span>(p);<span class="built_in">read</span>(T);</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		ch=<span class="built_in">getchar</span>();<span class="keyword">while</span> (ch!=<span class="string">&#x27;.&#x27;</span>&amp;&amp;ch!=<span class="string">&#x27;#&#x27;</span>) ch=<span class="built_in">getchar</span>();</span><br><span class="line">		<span class="keyword">for</span> (j=<span class="number">1</span>;j&lt;=m;j++) a[i][j]=(ch==<span class="string">&#x27;#&#x27;</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">2</span>;i&lt;=p;i++) lg[i]=lg[i/<span class="number">2</span>]+<span class="number">1</span>; </span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=p;i++) <span class="built_in">read</span>(g[i].x),<span class="built_in">read</span>(g[i].y),g[i].id=i,q.<span class="built_in">push</span>(<span class="built_in">node</span>(g[i].x,g[i].y,i)),vis[g[i].x][g[i].y]=i;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=p;i++) father[i]=i;</span><br><span class="line">	<span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">		<span class="keyword">auto</span> tmp=q.<span class="built_in">front</span>();q.<span class="built_in">pop</span>();</span><br><span class="line"><span class="comment">//		if (dis[tmp.x][tmp.y]&gt;n+m) continue;</span></span><br><span class="line">		<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=<span class="number">4</span>;i++) &#123;</span><br><span class="line">			xx=tmp.x+fx[i];yy=tmp.y+fy[i];</span><br><span class="line">			<span class="keyword">if</span> (xx&gt;=<span class="number">1</span>&amp;&amp;xx&lt;=n&amp;&amp;yy&gt;=<span class="number">1</span>&amp;&amp;yy&lt;=m&amp;&amp;!a[xx][yy]) &#123;</span><br><span class="line">				<span class="keyword">if</span> (vis[xx][yy]) &#123;</span><br><span class="line">					x=tmp.id,y=vis[xx][yy];</span><br><span class="line"><span class="comment">//					if (dis[xx][yy]+dis[tmp.x][tmp.y]&gt;4000000) printf(&quot;%d %d\n&quot;,dis[xx][yy],dis[tmp.x][tmp.y]); </span></span><br><span class="line">					<span class="built_in">assert</span>(dis[xx][yy]+dis[tmp.x][tmp.y]&lt;=<span class="number">4000000</span>);</span><br><span class="line">					e[dis[xx][yy]+dis[tmp.x][tmp.y]].<span class="built_in">push_back</span>(<span class="built_in">node</span>(x,y));</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> vis[xx][yy]=tmp.id,dis[xx][yy]=dis[tmp.x][tmp.y]+<span class="number">1</span>,q.<span class="built_in">push</span>(<span class="built_in">node</span>(xx,yy,tmp.id));</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;=n*m;i++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> tmp:e[i]) &#123;</span><br><span class="line">			x=tmp.x,y=tmp.y,z=i;</span><br><span class="line">			xx=<span class="built_in">getfa</span>(x),yy=<span class="built_in">getfa</span>(y);</span><br><span class="line">			<span class="keyword">if</span> (xx^yy) &#123;</span><br><span class="line">				to[x].<span class="built_in">push_back</span>(<span class="built_in">zyq</span>(y,z));</span><br><span class="line">				to[y].<span class="built_in">push_back</span>(<span class="built_in">zyq</span>(x,z));</span><br><span class="line">				father[xx]=yy;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=p;i++) <span class="keyword">if</span> (father[i]==i) <span class="built_in">dfs</span>(i,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">while</span> (T--) &#123;</span><br><span class="line">		<span class="built_in">read</span>(x);<span class="built_in">read</span>(y);</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">getfa</span>(x)!=<span class="built_in">getfa</span>(y)) <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>);</span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">query</span>(x,y));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="E-「JOISC-2014」邮戳拉力赛"><a href="#E-「JOISC-2014」邮戳拉力赛" class="headerlink" title="E. 「JOISC 2014」邮戳拉力赛"></a><a href="https://loj.ac/p/2878">E. 「JOISC 2014」邮戳拉力赛</a></h2><p>目前还不太会</p>
<h2 id="F-「JOISC-2014」稻草人"><a href="#F-「JOISC-2014」稻草人" class="headerlink" title="F. 「JOISC 2014」稻草人"></a><a href="https://loj.ac/p/2880">F. 「JOISC 2014」稻草人</a></h2><p>先按 $x$ 排序后，考虑分治。</p>
<p>分治的意义在于我们每次只需要经过中间的区间，也就是在左边的点集和右边的点集分别找一个，使区间合法。</p>
<p>考虑一个区间 $[L,R]$ 其分为两个区间 $[L,M],[M+1,R]$，两个区间内的点分别按 $y$ 降序排序。</p>
<p>枚举左区间内的点，计算过程是显然的。（不画图感觉很难简单的解释，但是没有数位板比较懒）分别用两个单调栈维护。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 200005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> put() putchar(<span class="string">&#x27;\n&#x27;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Tp template<span class="string">&lt;typename Ty&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Ts template<span class="string">&lt;typename Ty,typename... Ar&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(<span class="type">int</span> &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> f=<span class="number">1</span>;x=<span class="number">0</span>;<span class="type">char</span> c=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (c&lt;<span class="string">&#x27;0&#x27;</span>||c&gt;<span class="string">&#x27;9&#x27;</span>) &#123;<span class="keyword">if</span> (c==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">-1</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span> (c&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;c&lt;=<span class="string">&#x27;9&#x27;</span>) &#123;x=x*<span class="number">10</span>+c-<span class="string">&#x27;0&#x27;</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> Debug&#123;</span><br><span class="line">	Tp <span class="type">void</span> _debug(<span class="type">char</span>* f,Ty t)&#123;cerr&lt;&lt;f&lt;&lt;<span class="string">&#x27;=&#x27;</span>&lt;&lt;t&lt;&lt;endl;&#125;</span><br><span class="line">	Ts <span class="type">void</span> _debug(<span class="type">char</span>* f,Ty x,Ar... y)&#123;<span class="keyword">while</span>(*f!=<span class="string">&#x27;,&#x27;</span>) cerr&lt;&lt;*f++;cerr&lt;&lt;<span class="string">&#x27;=&#x27;</span>&lt;&lt;x&lt;&lt;<span class="string">&quot;,&quot;</span>;_debug(f+<span class="number">1</span>,y...);&#125;</span><br><span class="line">	Tp ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; os,vector&lt;Ty&gt;&amp; V)&#123;os&lt;&lt;<span class="string">&quot;[&quot;</span>;<span class="keyword">for</span>(<span class="keyword">auto</span>&amp; vv:V) os&lt;&lt;vv&lt;&lt;<span class="string">&quot;,&quot;</span>;os&lt;&lt;<span class="string">&quot;]&quot;</span>;<span class="keyword">return</span> os;&#125;</span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> gdb(...) _debug((char*)#__VA_ARGS__,__VA_ARGS__)</span></span><br><span class="line">&#125;<span class="keyword">using</span> <span class="keyword">namespace</span> Debug;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">	<span class="type">int</span> x,y;</span><br><span class="line">&#125;a[maxn],b[maxn];</span><br><span class="line">ll ans;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">cmp</span><span class="params">(node x,node y)</span> </span>&#123;<span class="keyword">return</span> x.x&lt;y.x;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">cmp2</span><span class="params">(node x,node y)</span> </span>&#123;<span class="keyword">return</span> x.y&gt;y.y;&#125;</span><br><span class="line"><span class="type">int</span> stac1[maxn],tot1,stac2[maxn],tot2,s1[maxn],s2[maxn];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add1</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (tot1&amp;&amp;stac1[tot1]&lt;=x) tot1--;</span><br><span class="line">	stac1[++tot1]=x;</span><br><span class="line">	s1[tot1]=y;</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add2</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (tot2&amp;&amp;stac2[tot2]&gt;=x) tot2--;</span><br><span class="line">	stac2[++tot2]=x;</span><br><span class="line">	s2[tot2]=y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> L,<span class="type">int</span> R)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (L==R) <span class="keyword">return</span> ;</span><br><span class="line">	<span class="type">int</span> mid=L+R&gt;&gt;<span class="number">1</span>,i;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> (i=L;i&lt;=R;i++) b[i]=a[i];</span><br><span class="line">	<span class="built_in">sort</span>(b+L,b+<span class="number">1</span>+mid,cmp2);</span><br><span class="line">	<span class="built_in">sort</span>(b+mid+<span class="number">1</span>,b+R+<span class="number">1</span>,cmp2);</span><br><span class="line">	<span class="type">int</span> it1,it2,now=mid;</span><br><span class="line">	s1[<span class="number">0</span>]=<span class="number">1e9</span>;tot1=tot2=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (i=L;i&lt;=mid;i++) &#123;</span><br><span class="line">		<span class="keyword">while</span> (now&lt;R&amp;&amp;b[now+<span class="number">1</span>].y&gt;=b[i].y) now++,<span class="built_in">add2</span>(b[now].x,b[now].y);</span><br><span class="line">		<span class="built_in">add1</span>(b[i].x,b[i].y);</span><br><span class="line">		it1=<span class="built_in">lower_bound</span>(s2+<span class="number">1</span>,s2+<span class="number">1</span>+tot2,s1[tot1<span class="number">-1</span>],[](<span class="type">int</span> x,<span class="type">int</span> y)&#123;<span class="keyword">return</span> x&gt;y;&#125;)-s2;</span><br><span class="line">		it2=<span class="built_in">lower_bound</span>(s2+<span class="number">1</span>,s2+<span class="number">1</span>+tot2,s1[tot1],[](<span class="type">int</span> x,<span class="type">int</span> y)&#123;<span class="keyword">return</span> x&gt;y;&#125;)-s2;</span><br><span class="line">		ans+=it2-it1;</span><br><span class="line"><span class="comment">//		gdb(i,now,it1,it2,stac1[tot1-1],stac1[tot1]);</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">solve</span>(L,mid);</span><br><span class="line">	<span class="built_in">solve</span>(mid+<span class="number">1</span>,R);</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">  <span class="built_in">freopen</span>(<span class="string">&quot;1.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line"><span class="comment">//  int c[3]=&#123;3,2,1&#125;;</span></span><br><span class="line"><span class="comment">//  cout&lt;&lt;lower_bound(c,c+3,0,[](int x,int y)&#123;return x&gt;y;&#125;)-c&lt;&lt;&#x27;\n&#x27;;</span></span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="built_in">read</span>(n);</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">read</span>(a[i].x),<span class="built_in">read</span>(a[i].y);</span><br><span class="line">	<span class="built_in">sort</span>(a+<span class="number">1</span>,a+<span class="number">1</span>+n,cmp);</span><br><span class="line">	<span class="built_in">solve</span>(<span class="number">1</span>,n);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="G-「JOISC-2014」电压"><a href="#G-「JOISC-2014」电压" class="headerlink" title="G.「JOISC 2014」电压"></a>G.「JOISC 2014」电压</h2><p>bzoj4238 </p>
<p>二分图。我好像写过题解了。</p>
<h2 id="H-「JOISC-2014」挂饰"><a href="#H-「JOISC-2014」挂饰" class="headerlink" title="H.「JOISC 2014」挂饰"></a>H.「JOISC 2014」挂饰</h2><p>看上去是个平凡的背包题。</p>
<p>实际上也是。为了避免背包出现没有挂钩的情况。先将物品按挂钩个数从大到小排序。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 2005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> put() putchar(<span class="string">&#x27;\n&#x27;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Tp template<span class="string">&lt;typename Ty&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Ts template<span class="string">&lt;typename Ty,typename... Ar&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(<span class="type">int</span> &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> f=<span class="number">1</span>;x=<span class="number">0</span>;<span class="type">char</span> c=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (c&lt;<span class="string">&#x27;0&#x27;</span>||c&gt;<span class="string">&#x27;9&#x27;</span>) &#123;<span class="keyword">if</span> (c==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">-1</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span> (c&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;c&lt;=<span class="string">&#x27;9&#x27;</span>) &#123;x=x*<span class="number">10</span>+c-<span class="string">&#x27;0&#x27;</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> Debug&#123;</span><br><span class="line">	Tp <span class="type">void</span> _debug(<span class="type">char</span>* f,Ty t)&#123;cerr&lt;&lt;f&lt;&lt;<span class="string">&#x27;=&#x27;</span>&lt;&lt;t&lt;&lt;endl;&#125;</span><br><span class="line">	Ts <span class="type">void</span> _debug(<span class="type">char</span>* f,Ty x,Ar... y)&#123;<span class="keyword">while</span>(*f!=<span class="string">&#x27;,&#x27;</span>) cerr&lt;&lt;*f++;cerr&lt;&lt;<span class="string">&#x27;=&#x27;</span>&lt;&lt;x&lt;&lt;<span class="string">&quot;,&quot;</span>;_debug(f+<span class="number">1</span>,y...);&#125;</span><br><span class="line">	Tp ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; os,vector&lt;Ty&gt;&amp; V)&#123;os&lt;&lt;<span class="string">&quot;[&quot;</span>;<span class="keyword">for</span>(<span class="keyword">auto</span>&amp; vv:V) os&lt;&lt;vv&lt;&lt;<span class="string">&quot;,&quot;</span>;os&lt;&lt;<span class="string">&quot;]&quot;</span>;<span class="keyword">return</span> os;&#125;</span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> gdb(...) _debug(#__VA_ARGS__,__VA_ARGS__)</span></span><br><span class="line">&#125;<span class="keyword">using</span> <span class="keyword">namespace</span> Debug;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">	<span class="type">int</span> x,y;</span><br><span class="line">&#125;a[maxn];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> f[maxn][maxn],ans; </span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">cmp</span><span class="params">(node x,node y)</span> </span>&#123;<span class="keyword">return</span> x.x&gt;y.x;&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line"><span class="comment">//  freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);</span></span><br><span class="line">	<span class="type">int</span> i,j;</span><br><span class="line">	<span class="built_in">memset</span>(f,<span class="number">-0x3f</span>,<span class="built_in">sizeof</span>(f));</span><br><span class="line">	<span class="built_in">read</span>(n);</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">read</span>(a[i].x),<span class="built_in">read</span>(a[i].y);</span><br><span class="line">	<span class="built_in">sort</span>(a+<span class="number">1</span>,a+<span class="number">1</span>+n,cmp);</span><br><span class="line">	f[<span class="number">0</span>][<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (j=<span class="number">0</span>;j&lt;=n;j++) f[i][j]=<span class="built_in">max</span>(f[i<span class="number">-1</span>][<span class="built_in">max</span>(<span class="number">0ll</span>,j-a[i].x)+<span class="number">1</span>]+a[i].y,f[i<span class="number">-1</span>][j]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (j=<span class="number">0</span>;j&lt;=n;j++) ans=<span class="built_in">max</span>(ans,f[n][j]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>JOI</tag>
        <tag>HHHOJ周赛</tag>
      </tags>
  </entry>
  <entry>
    <title>IOI2007 Pairs 动物对数</title>
    <url>/2022/07/12/IOI2007-pairs-%E5%8A%A8%E7%89%A9%E5%AF%B9%E6%95%B0/</url>
    <content><![CDATA[<p>曼哈顿距离转切比雪夫距离。</p>
<h2 id="B-x3D-1"><a href="#B-x3D-1" class="headerlink" title="B&#x3D;1"></a>B&#x3D;1</h2><p>排序直接搞。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> n,d,m;</span><br><span class="line"><span class="keyword">namespace</span> Solve1&#123;</span><br><span class="line">	<span class="type">int</span> a[<span class="number">100005</span>];ll ans;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">		<span class="type">int</span> i;</span><br><span class="line">		<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">read</span>(a[i]);</span><br><span class="line">		<span class="built_in">sort</span>(a+<span class="number">1</span>,a+<span class="number">1</span>+n);</span><br><span class="line">		<span class="type">int</span> now=<span class="number">0</span>,tot=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">			<span class="keyword">while</span> (now&lt;n&amp;&amp;a[now+<span class="number">1</span>]+d&lt;a[i]) now++,tot--;</span><br><span class="line">			ans+=tot;tot++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,ans);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="B-x3D-2"><a href="#B-x3D-2" class="headerlink" title="B&#x3D;2"></a>B&#x3D;2</h3><p>对于所有点 $(x,y)$ ，变换为 $(x+y,x-y)$ 。变换前的曼哈顿距离等于变换后的切比雪夫距离。</p>
<p>然后就是二维偏序。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> Solve2&#123;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">yyy</span>&#123;</span><br><span class="line">	<span class="type">int</span> x,y;</span><br><span class="line">	&#125;a[maxn];</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">cmp</span><span class="params">(yyy x,yyy y)</span> </span>&#123;<span class="keyword">return</span> x.x==y.x?x.y&lt;y.y:x.x&lt;y.x;&#125;</span><br><span class="line">	<span class="type">int</span> root,cnt;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">		<span class="type">int</span> ls,rs,size;</span><br><span class="line">	&#125;f[maxn*<span class="number">30</span>];</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Update</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> &amp;rt,<span class="type">int</span> head,<span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (!rt) rt=++cnt;f[rt].size+=k;</span><br><span class="line">		<span class="keyword">if</span> (l==r) <span class="keyword">return</span> ;</span><br><span class="line">		<span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span> (head&lt;=mid) <span class="built_in">Update</span>(l,mid,f[rt].ls,head,k);</span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">Update</span>(mid+<span class="number">1</span>,r,f[rt].rs,head,k);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">Query</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> rt,<span class="type">int</span> head,<span class="type">int</span> tail)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (!rt) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span> (head&lt;=l&amp;&amp;r&lt;=tail) <span class="keyword">return</span> f[rt].size;</span><br><span class="line">		<span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>,sum=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span> (head&lt;=mid) sum+=<span class="built_in">Query</span>(l,mid,f[rt].ls,head,tail);</span><br><span class="line">		<span class="keyword">if</span> (tail&gt;mid) sum+=<span class="built_in">Query</span>(mid+<span class="number">1</span>,r,f[rt].rs,head,tail);</span><br><span class="line">		<span class="keyword">return</span> sum;</span><br><span class="line">	&#125;</span><br><span class="line">	ll ans;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">		<span class="type">int</span> i,x,y;</span><br><span class="line">		<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">read</span>(x),<span class="built_in">read</span>(y),a[i].x=x+y,a[i].y=x-y;</span><br><span class="line">		<span class="built_in">sort</span>(a+<span class="number">1</span>,a+<span class="number">1</span>+n,cmp);</span><br><span class="line">		<span class="type">int</span> now=<span class="number">0</span>,tot=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">			<span class="keyword">while</span> (now&lt;n&amp;&amp;a[now+<span class="number">1</span>].x+d&lt;a[i].x) now++,<span class="built_in">Update</span>(-m,m*<span class="number">2</span>,root,a[now].y,<span class="number">-1</span>);</span><br><span class="line">			ans+=<span class="built_in">Query</span>(-m,m*<span class="number">2</span>,root,<span class="built_in">max</span>(-m,a[i].y-d),<span class="built_in">min</span>(<span class="number">2</span>*m,a[i].y+d));</span><br><span class="line">			<span class="built_in">Update</span>(-m,<span class="number">2</span>*m,root,a[i].y,<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,ans);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="B-x3D-3"><a href="#B-x3D-3" class="headerlink" title="B&#x3D;3"></a>B&#x3D;3</h3><p>同样的，$(x,y,z)$ 变换为 $(x+y+z,x+y-z,x-y+z,-x+y+z)$</p>
<p>四维偏序，支持点的增加与删除。排序去掉一维以后用三维树状数组维护。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> Solve3&#123;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">yyy</span>&#123;</span><br><span class="line">		<span class="type">int</span> x,y,z,w;</span><br><span class="line">	&#125;a[maxn];</span><br><span class="line">	ll ans;</span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> lowbit(x) ((x)&amp;(-x))</span></span><br><span class="line">	<span class="type">int</span> f[<span class="number">250</span>][<span class="number">250</span>][<span class="number">250</span>];</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> z,<span class="type">int</span> w)</span> </span>&#123;</span><br><span class="line">		<span class="type">int</span> i,j,k;</span><br><span class="line">		<span class="keyword">for</span> (i=x;i&lt;=m;i+=<span class="built_in">lowbit</span>(i))</span><br><span class="line">			<span class="keyword">for</span> (j=y;j&lt;=m;j+=<span class="built_in">lowbit</span>(j))</span><br><span class="line">				<span class="keyword">for</span> (k=z;k&lt;=m;k+=<span class="built_in">lowbit</span>(k))</span><br><span class="line">					f[i][j][k]+=w;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> z)</span> </span>&#123;</span><br><span class="line">		<span class="type">int</span> i,j,k,sum=<span class="number">0</span>;<span class="comment">//printf(&quot;%d %d %d &quot;,x,y,z);</span></span><br><span class="line">		<span class="keyword">for</span> (i=x;i;i-=<span class="built_in">lowbit</span>(i))</span><br><span class="line">			<span class="keyword">for</span> (j=y;j;j-=<span class="built_in">lowbit</span>(j))</span><br><span class="line">				<span class="keyword">for</span> (k=z;k;k-=<span class="built_in">lowbit</span>(k))</span><br><span class="line">					sum+=f[i][j][k];	</span><br><span class="line">		<span class="keyword">return</span> sum;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">cmp</span><span class="params">(yyy x,yyy y)</span></span>&#123;<span class="keyword">return</span> x.w&lt;y.w;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="type">int</span> i,j,k,l,x,y,z;</span><br><span class="line">		<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">			<span class="built_in">read</span>(x);<span class="built_in">read</span>(y);<span class="built_in">read</span>(z);</span><br><span class="line">			a[i].w=x+y+z+m;</span><br><span class="line">			a[i].x=x+y-z+m;</span><br><span class="line">			a[i].y=x-y+z+m;</span><br><span class="line">			a[i].z=y+z-x+m;</span><br><span class="line">	<span class="comment">//		printf(&quot;%d %d %d\n&quot;,a[i].x,a[i].y,a[i].z);</span></span><br><span class="line">		&#125;</span><br><span class="line">		m*=<span class="number">3</span>;</span><br><span class="line">		<span class="built_in">sort</span>(a+<span class="number">1</span>,a+<span class="number">1</span>+n,cmp);</span><br><span class="line">		<span class="type">int</span> now=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">			<span class="keyword">while</span> (now&lt;n&amp;&amp;a[now+<span class="number">1</span>].w+d&lt;a[i].w) now++,<span class="built_in">add</span>(a[now].x,a[now].y,a[now].z,<span class="number">-1</span>);</span><br><span class="line">			<span class="type">int</span> rx=<span class="built_in">min</span>(m,a[i].x+d),ry=<span class="built_in">min</span>(m,a[i].y+d),rz=<span class="built_in">min</span>(m,a[i].z+d);</span><br><span class="line">			<span class="type">int</span> lx=<span class="built_in">max</span>(<span class="number">0</span>,a[i].x-d<span class="number">-1</span>),ly=<span class="built_in">max</span>(<span class="number">0</span>,a[i].y-d<span class="number">-1</span>),lz=<span class="built_in">max</span>(<span class="number">0</span>,a[i].z-d<span class="number">-1</span>);</span><br><span class="line">			ans+=<span class="built_in">query</span>(rx,ry,rz)</span><br><span class="line">			-<span class="built_in">query</span>(lx,ry,rz)-<span class="built_in">query</span>(rx,ly,rz)-<span class="built_in">query</span>(rx,ry,lz)</span><br><span class="line">			+<span class="built_in">query</span>(lx,ly,rz)+<span class="built_in">query</span>(lx,ry,lz)+<span class="built_in">query</span>(rx,ly,lz)</span><br><span class="line">			-<span class="built_in">query</span>(lx,ly,lz);			</span><br><span class="line">			<span class="built_in">add</span>(a[i].x,a[i].y,a[i].z,<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,ans);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>数据结构</tag>
        <tag>IOI</tag>
      </tags>
  </entry>
  <entry>
    <title>Hall定理小结</title>
    <url>/2023/02/28/Hall%E5%AE%9A%E7%90%86%E5%B0%8F%E7%BB%93/</url>
    <content><![CDATA[<h2 id="Hall-定理小结"><a href="#Hall-定理小结" class="headerlink" title="Hall 定理小结"></a>Hall 定理小结</h2><h3 id="Hall-定理"><a href="#Hall-定理" class="headerlink" title="Hall 定理"></a>Hall 定理</h3><p>对于二分图 $G&#x3D;(V,E)$ ，令 $N(v)$ 表示与点 $v$ 相邻的点集，则关于最大匹配，我们有如下结论：</p>
<p>设二分图 $G$ 的两部分 $X,Y$，且 $|X|\le |Y|$ ，则 $|X|$ 存在完美匹配（存在一个大小为 $|X|$ 的匹配）当且仅当 $\forall S\subseteq X$，都有 $S\le |N(S)|$。</p>
<p>证明网上很多，这里不再赘述。</p>
<h4 id="推论1"><a href="#推论1" class="headerlink" title="推论1"></a>推论1</h4><p>如果一个无向图的每个点度数都为 $k$，则成为其为 $k$ 正则图。</p>
<p>那么左右点数相等的 $k$ 正则二分图必有完美匹配。$k\ge 1$</p>
<p>证明：</p>
<blockquote>
<p>若不然，考虑一个左部点集 $L$，则存在 $R&#x3D;N(L),|R|&lt;|L|$。考虑到 $|R|$ 的所有点的度数和不小于 $|L|\times k$ ，但是 $|R|&lt;|L|$，这与每个点的度数都为 $k$ 矛盾。</p>
</blockquote>
<h4 id="推论2"><a href="#推论2" class="headerlink" title="推论2"></a>推论2</h4><p>Hall 定理可以用于点有权值的情况。左部点 $i$ 需要匹配 $a_i$ 个右部点，右部点 $i$ 需要匹配 $b_i$ 个左部点。<strong>匹配是可重复的。</strong>只需要将定理改写一下。其有完美匹配的充要条件为：<br>$$<br>\forall S\subseteq X,|\sum\limits_{x\in S}a_x|\le |\sum\limits_{y\in N(S)}b_y|<br>$$<br>证明可以将左部点 $i$ 拆成 $a_i$ 个点，右部点同样。发现此条件和原本的 Hall 定理是等价的。</p>
<h4 id="CF1373F-Network-Coverage"><a href="#CF1373F-Network-Coverage" class="headerlink" title="CF1373F Network Coverage"></a>CF1373F Network Coverage</h4><h5 id="题意："><a href="#题意：" class="headerlink" title="题意："></a>题意：</h5><p> $n$ 个城市，这 $n$个城市首尾相接形成一个环。每个城市需要 $a_i$ 个网络数量。$n$ 个网络基站，第 $i$ 个网络基站有 $b_i$ 的网络数量，可以给 $i$ 和 $i+1$ 提供 网络。（第 $n$ 个网络基站可以给第 $n$ 座城市和第 $1$ 座城市提供网络）。</p>
<p>判断能否使得所有的家庭都获得网络。</p>
<p>$n\le 10^6$</p>
<h5 id="做法"><a href="#做法" class="headerlink" title="做法"></a>做法</h5><p>显然是个带权二分图求完美匹配的题。</p>
<p>考虑枚举城市的集合 $L$，如果 $L$ 不是一个连续的区间，判断其是否合法，与其中每个连续的区间分别同时满足判定的条件是等价的。</p>
<p>转化为对于任意区间 $[l,r]$ ，$\sum\limits_{i&#x3D;l}^r a_i\le \sum\limits_{i&#x3D;l-1}^rb_i$ 都成立。</p>
<p>前缀和+后缀最大值即可。题目要求为环的情况，断环为链。</p>
<h5 id="CODE"><a href="#CODE" class="headerlink" title="CODE"></a>CODE</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a[maxn],b[maxn],n,d[maxn],suf[maxn];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">solve</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> i,sum1=<span class="number">0</span>,sum2=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">read</span>(n);</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">read</span>(a[i]);</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">read</span>(b[i]),d[i]=a[i]-b[i],sum1+=d[i];</span><br><span class="line">	<span class="keyword">if</span> (sum1&gt;<span class="number">0</span>) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;NO&quot;</span>);</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) a[i+n]=a[i],b[i+n]=b[i];</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n*<span class="number">2</span>;i++) d[i]=d[i<span class="number">-1</span>]+b[i]-a[i];</span><br><span class="line">	<span class="keyword">for</span> (suf[n*<span class="number">2</span>+<span class="number">1</span>]=<span class="number">1e18</span>,i=n*<span class="number">2</span>;i&gt;=<span class="number">1</span>;i--) suf[i]=<span class="built_in">min</span>(suf[i+<span class="number">1</span>],d[i]);</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (suf[i+<span class="number">1</span>]-d[i]+b[i]&lt;<span class="number">0</span>) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;NO&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;YES&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="推论3"><a href="#推论3" class="headerlink" title="推论3"></a>推论3</h4><p>设二分图 $G$ 的两部分分别为 $X,Y$，则最大匹配为 $|X|-\max\limits_{S\subseteq X}(|S|-|N(S)|)$</p>
<p>证明不再赘述。<del>主要是不会</del></p>
<h4 id="ARC076F"><a href="#ARC076F" class="headerlink" title="ARC076F"></a>ARC076F</h4><h5 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h5><p>第 $i$ 个人可以与第 $[1,l_i]\bigcup[r_i,m]$ 的凳子相连。求最大匹配。</p>
<p>$n,m\le 2\times10^5$</p>
<h5 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h5><p>考虑按 $l_i$ 升序排序。 当前枚举到 $i$。必须去 $i$ ，则：<br>$$<br>|X|-\max_{S\subseteq}(|S|-|N(S)|)<br>&#x3D;|X|-\max_{S\subseteq X}(|S|+m-\bigcup_{j\in S}(l_i,r_i)<br>$$<br> 枚举并集，不妨枚举的区间为 $(l_i,k),k&gt;l_i$<br>$$<br>n+m-\max_{S\subseteq X}{(\sum\limits_{j\le i}1[l_j\le l_i][k\le r_j]+k-l_i-1})<br>$$<br>用线段树维护 $r_j$ 即可。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#define ll long long</span><br><span class="line">#define ull unsigned long long</span><br><span class="line">#define maxn 200005</span><br><span class="line">#define put() putchar(&#x27;\n&#x27;)</span><br><span class="line">#define Tp template&lt;typename Ty&gt;</span><br><span class="line">#define Ts template&lt;typename Ty,typename... Ar&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">inline void read(int &amp;x)&#123;</span><br><span class="line">    int f=1;x=0;char c=getchar();</span><br><span class="line">    while (c&lt;&#x27;0&#x27;||c&gt;&#x27;9&#x27;) &#123;if (c==&#x27;-&#x27;) f=-1;c=getchar();&#125;</span><br><span class="line">    while (c&gt;=&#x27;0&#x27;&amp;&amp;c&lt;=&#x27;9&#x27;) &#123;x=x*10+c-&#x27;0&#x27;;c=getchar();&#125;</span><br><span class="line">    x*=f;</span><br><span class="line">&#125;</span><br><span class="line">namespace Debug&#123;</span><br><span class="line">	Tp void _debug(char* f,Ty t)&#123;cerr&lt;&lt;f&lt;&lt;&#x27;=&#x27;&lt;&lt;t&lt;&lt;endl;&#125;</span><br><span class="line">	Ts void _debug(char* f,Ty x,Ar... y)&#123;while(*f!=&#x27;,&#x27;) cerr&lt;&lt;*f++;cerr&lt;&lt;&#x27;=&#x27;&lt;&lt;x&lt;&lt;&quot;,&quot;;_debug(f+1,y...);&#125;</span><br><span class="line">	Tp ostream&amp; operator&lt;&lt;(ostream&amp; os,vector&lt;Ty&gt;&amp; V)&#123;os&lt;&lt;&quot;[&quot;;for(auto&amp; vv:V) os&lt;&lt;vv&lt;&lt;&quot;,&quot;;os&lt;&lt;&quot;]&quot;;return os;&#125;</span><br><span class="line">	#define gdb(...) _debug((char*)#__VA_ARGS__,__VA_ARGS__)</span><br><span class="line">&#125;using namespace Debug;</span><br><span class="line">struct node&#123;</span><br><span class="line">	int l,r;</span><br><span class="line">&#125;g[maxn];</span><br><span class="line">inline bool cmp(node x,node y) &#123;return x.l&lt;y.l;&#125;</span><br><span class="line">int n,m;</span><br><span class="line">namespace Seg&#123;</span><br><span class="line">	struct yyy&#123;</span><br><span class="line">		int Max,lazy;</span><br><span class="line">	&#125;f[maxn&lt;&lt;2];</span><br><span class="line">	inline void Pushup(int rt) &#123;f[rt].Max=max(f[rt&lt;&lt;1].Max,f[rt&lt;&lt;1|1].Max);&#125;</span><br><span class="line">	inline void Pushdown(int l,int r,int rt) &#123;</span><br><span class="line">		if (f[rt].lazy) &#123;</span><br><span class="line">			int mid=l+r&gt;&gt;1,k=f[rt].lazy;f[rt].lazy=0;</span><br><span class="line">			f[rt&lt;&lt;1].Max+=k,f[rt&lt;&lt;1|1].Max+=k;</span><br><span class="line">			f[rt&lt;&lt;1].lazy+=k,f[rt&lt;&lt;1|1].lazy+=k;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	inline void Update(int l,int r,int rt,int head,int tail,int k) &#123;</span><br><span class="line">		if (head&lt;=l&amp;&amp;r&lt;=tail) return f[rt].Max+=k,f[rt].lazy+=k,void();</span><br><span class="line">		int mid=l+r&gt;&gt;1;Pushdown(l,r,rt);</span><br><span class="line">		if (head&lt;=mid) Update(l,mid,rt&lt;&lt;1,head,tail,k);</span><br><span class="line">		if (tail&gt;mid)  Update(mid+1,r,rt&lt;&lt;1|1,head,tail,k);</span><br><span class="line">		Pushup(rt); </span><br><span class="line">	&#125;</span><br><span class="line">	inline int Query(int l,int r,int rt,int head,int tail) &#123;</span><br><span class="line">		if (head&lt;=l&amp;&amp;r&lt;=tail) return f[rt].Max;</span><br><span class="line">		int mid=l+r&gt;&gt;1,tmp1=0,tmp2=0;Pushdown(l,r,rt);</span><br><span class="line">		if (head&lt;=mid) tmp1=Query(l,mid,rt&lt;&lt;1,head,tail);</span><br><span class="line">		if (tail&gt;mid)  tmp2=Query(mid+1,r,rt&lt;&lt;1|1,head,tail);</span><br><span class="line">		return max(tmp1,tmp2);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">using Seg::Update;</span><br><span class="line">using Seg::Query;</span><br><span class="line">signed main(void)&#123;</span><br><span class="line">	int i,ans=0; </span><br><span class="line">	read(n);read(m);</span><br><span class="line">	for (i=1;i&lt;=n;i++) read(g[i].l),read(g[i].r); </span><br><span class="line">	sort(g+1,g+1+n,cmp);m++;</span><br><span class="line">	for (i=0;i&lt;=m;i++) Update(0,m,1,i,i,i);</span><br><span class="line">	for (i=1;i&lt;=n;i++) &#123;</span><br><span class="line">		Update(0,m,1,0,g[i].r,1);</span><br><span class="line">		ans=max(ans,Query(0,m,1,g[i].l,m)-g[i].l);</span><br><span class="line">	&#125;</span><br><span class="line">	printf(&quot;%d&quot;,max(max(0,n-m+1),ans-m));</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="CF338E"><a href="#CF338E" class="headerlink" title="CF338E"></a>CF338E</h4><h5 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h5><p>$A$ 的长度为 $n$，$B$ 的长度为 $m$。</p>
<p>求 $A$ 有多少长度为 $m$ 的区间中的数和 $B$ 中的数完美匹配。</p>
<p>两个数匹配当且仅当其和不小于 $h$。 (区间必须连续)</p>
<p>$n,m\le 1.5\times 10^5$</p>
<h5 id="解法-1"><a href="#解法-1" class="headerlink" title="解法"></a>解法</h5><p>顺序与连边无关。考虑将 $B$ 先从大到小排序。那么对于 $a_i$ ，其向 $B$ 连边的节点一定为区间 $[1,l_i]$ 。这是容易计算的。</p>
<p>考虑 Hall 定理。枚举 $N(S)&#x3D;[1,j]$，则有：<br>$$<br>\text{最大匹配}&#x3D;|X|-\max_{S\subseteq X}(|S|-|N(S)|)&#x3D;|X|-\max_{S\subseteq X}(\sum\limits 1[l_i\le j]-j)<br>$$<br>线段树维护 $l_i$ 即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 200005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> put() putchar(<span class="string">&#x27;\n&#x27;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Tp template<span class="string">&lt;typename Ty&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Ts template<span class="string">&lt;typename Ty,typename... Ar&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(<span class="type">int</span> &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> f=<span class="number">1</span>;x=<span class="number">0</span>;<span class="type">char</span> c=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (c&lt;<span class="string">&#x27;0&#x27;</span>||c&gt;<span class="string">&#x27;9&#x27;</span>) &#123;<span class="keyword">if</span> (c==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">-1</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span> (c&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;c&lt;=<span class="string">&#x27;9&#x27;</span>) &#123;x=x*<span class="number">10</span>+c-<span class="string">&#x27;0&#x27;</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> Debug&#123;</span><br><span class="line">	Tp <span class="type">void</span> _debug(<span class="type">char</span>* f,Ty t)&#123;cerr&lt;&lt;f&lt;&lt;<span class="string">&#x27;=&#x27;</span>&lt;&lt;t&lt;&lt;endl;&#125;</span><br><span class="line">	Ts <span class="type">void</span> _debug(<span class="type">char</span>* f,Ty x,Ar... y)&#123;<span class="keyword">while</span>(*f!=<span class="string">&#x27;,&#x27;</span>) cerr&lt;&lt;*f++;cerr&lt;&lt;<span class="string">&#x27;=&#x27;</span>&lt;&lt;x&lt;&lt;<span class="string">&quot;,&quot;</span>;_debug(f+<span class="number">1</span>,y...);&#125;</span><br><span class="line">	Tp ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; os,vector&lt;Ty&gt;&amp; V)&#123;os&lt;&lt;<span class="string">&quot;[&quot;</span>;<span class="keyword">for</span>(<span class="keyword">auto</span>&amp; vv:V) os&lt;&lt;vv&lt;&lt;<span class="string">&quot;,&quot;</span>;os&lt;&lt;<span class="string">&quot;]&quot;</span>;<span class="keyword">return</span> os;&#125;</span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> gdb(...) _debug((char*)#__VA_ARGS__,__VA_ARGS__)</span></span><br><span class="line">&#125;<span class="keyword">using</span> <span class="keyword">namespace</span> Debug;</span><br><span class="line"><span class="type">int</span> n,m,K;</span><br><span class="line"><span class="type">int</span> a[maxn],b[maxn],r[maxn],g[maxn];</span><br><span class="line"><span class="keyword">namespace</span> Seg&#123;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">yyy</span>&#123;</span><br><span class="line">		<span class="type">int</span> lazy,Max; </span><br><span class="line">	&#125;f[maxn&lt;&lt;<span class="number">2</span>];</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Pushup</span><span class="params">(<span class="type">int</span> rt)</span> </span>&#123;f[rt].Max=<span class="built_in">max</span>(f[rt&lt;&lt;<span class="number">1</span>].Max,f[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].Max);&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Pushdown</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> rt)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (f[rt].lazy) &#123;</span><br><span class="line">			<span class="type">int</span> k=f[rt].lazy;f[rt].lazy=<span class="number">0</span>;</span><br><span class="line">			f[rt&lt;&lt;<span class="number">1</span>].Max+=k,f[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].Max+=k;</span><br><span class="line">			f[rt&lt;&lt;<span class="number">1</span>].lazy+=k,f[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].lazy+=k;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Update</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> rt,<span class="type">int</span> head,<span class="type">int</span> tail,<span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (head&lt;=l&amp;&amp;r&lt;=tail) <span class="keyword">return</span> f[rt].lazy+=k,f[rt].Max+=k,<span class="built_in">void</span>();</span><br><span class="line">		<span class="built_in">Pushdown</span>(l,r,rt);<span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span> (head&lt;=mid) <span class="built_in">Update</span>(l,mid,rt&lt;&lt;<span class="number">1</span>,head,tail,k);</span><br><span class="line">		<span class="keyword">if</span> (tail&gt;mid)  <span class="built_in">Update</span>(mid+<span class="number">1</span>,r,rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,head,tail,k);</span><br><span class="line">		<span class="built_in">Pushup</span>(rt);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> Seg::Update;</span><br><span class="line"><span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="built_in">read</span>(n);<span class="built_in">read</span>(m);<span class="built_in">read</span>(K);</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=m;i++) <span class="built_in">read</span>(b[i]);<span class="built_in">sort</span>(b+<span class="number">1</span>,b+<span class="number">1</span>+m),<span class="built_in">reverse</span>(b+<span class="number">1</span>,b+<span class="number">1</span>+m);</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=m;i++) g[i]=K-b[i];</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="built_in">read</span>(a[i]);</span><br><span class="line">		<span class="keyword">if</span> (a[i]&gt;=g[<span class="number">1</span>]) r[i]=<span class="built_in">lower_bound</span>(g+<span class="number">1</span>,g+<span class="number">1</span>+m,a[i]+<span class="number">1</span>)-g<span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;=m;i++) <span class="built_in">Update</span>(<span class="number">0</span>,m,<span class="number">1</span>,i,i,-i);</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (i&gt;m) &#123;</span><br><span class="line">			<span class="built_in">Update</span>(<span class="number">0</span>,m,<span class="number">1</span>,r[i-m],m,<span class="number">-1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">Update</span>(<span class="number">0</span>,m,<span class="number">1</span>,r[i],m,<span class="number">1</span>);</span><br><span class="line">		<span class="keyword">if</span> (i&gt;=m) &#123;</span><br><span class="line">			<span class="keyword">if</span> (Seg::f[<span class="number">1</span>].Max==<span class="number">0</span>) ans++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="可能的例题"><a href="#可能的例题" class="headerlink" title="可能的例题"></a>可能的例题</h3><ul>
<li>CF1373G</li>
<li>CF1718D</li>
</ul>
]]></content>
      <tags>
        <tag>Hall定理</tag>
        <tag>二分图</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>JLOI2013 卡牌游戏</title>
    <url>/2023/03/13/JLOI2013-%E5%8D%A1%E7%89%8C%E6%B8%B8%E6%88%8F/</url>
    <content><![CDATA[<h1 id="JLOI2013-卡牌游戏"><a href="#JLOI2013-卡牌游戏" class="headerlink" title="[JLOI2013] 卡牌游戏"></a>[JLOI2013] 卡牌游戏</h1><p>最近想刷点真题。感觉基础不够（体现在这题都需要看一眼题解），所以从简单一点的开始。</p>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>正难则反，倒序考虑。</p>
<p><strong>不考虑序号</strong>，假设我们已经知道第 $i+1$ 轮的情况，其中钦定第一个为庄，$f[i+1][j]$ 表示 $j$ 获胜的概率。</p>
<p>考虑转移，在第 $i$ 轮中，以第 $1$ 个人为庄，使用第 $j$ 张卡牌以后是第 $x$ 个人，则可以从第 $i+1$ 轮中以 $x+1$ 为庄的情况转移。只考虑相对顺序，显然是不影响的。</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 55</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> put() putchar(<span class="string">&#x27;\n&#x27;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Tp template<span class="string">&lt;typename Ty&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Ts template<span class="string">&lt;typename Ty,typename... Ar&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(<span class="type">int</span> &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> f=<span class="number">1</span>;x=<span class="number">0</span>;<span class="type">char</span> c=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (c&lt;<span class="string">&#x27;0&#x27;</span>||c&gt;<span class="string">&#x27;9&#x27;</span>) &#123;<span class="keyword">if</span> (c==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">-1</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span> (c&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;c&lt;=<span class="string">&#x27;9&#x27;</span>) &#123;x=x*<span class="number">10</span>+c-<span class="string">&#x27;0&#x27;</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> Debug&#123;</span><br><span class="line">	Tp <span class="type">void</span> _debug(<span class="type">char</span>* f,Ty t)&#123;cerr&lt;&lt;f&lt;&lt;<span class="string">&#x27;=&#x27;</span>&lt;&lt;t&lt;&lt;endl;&#125;</span><br><span class="line">	Ts <span class="type">void</span> _debug(<span class="type">char</span>* f,Ty x,Ar... y)&#123;<span class="keyword">while</span>(*f!=<span class="string">&#x27;,&#x27;</span>) cerr&lt;&lt;*f++;cerr&lt;&lt;<span class="string">&#x27;=&#x27;</span>&lt;&lt;x&lt;&lt;<span class="string">&quot;,&quot;</span>;_debug(f+<span class="number">1</span>,y...);&#125;</span><br><span class="line">	Tp ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; os,vector&lt;Ty&gt;&amp; V)&#123;os&lt;&lt;<span class="string">&quot;[&quot;</span>;<span class="keyword">for</span>(<span class="keyword">auto</span>&amp; vv:V) os&lt;&lt;vv&lt;&lt;<span class="string">&quot;,&quot;</span>;os&lt;&lt;<span class="string">&quot;]&quot;</span>;<span class="keyword">return</span> os;&#125;</span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> gdb(...) _debug((char*)#__VA_ARGS__,__VA_ARGS__)</span></span><br><span class="line">&#125;<span class="keyword">using</span> <span class="keyword">namespace</span> Debug;</span><br><span class="line"><span class="type">int</span> n,m,a[maxn];</span><br><span class="line"><span class="type">double</span> f[maxn][maxn];</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> i,j,x,o,y;</span><br><span class="line">	<span class="built_in">read</span>(n);<span class="built_in">read</span>(m);</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=m;i++) <span class="built_in">read</span>(a[i]);</span><br><span class="line">	f[<span class="number">1</span>][<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">2</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (o=<span class="number">1</span>;o&lt;=m;o++) &#123;</span><br><span class="line">			x=(a[o]<span class="number">-1</span>)%i+<span class="number">1</span>;</span><br><span class="line">			<span class="keyword">for</span> (j=<span class="number">1</span>;j&lt;i;j++) &#123;</span><br><span class="line">				y=(x+j<span class="number">-1</span>)%i+<span class="number">1</span>;</span><br><span class="line">				f[i][y]+=<span class="number">1.0</span>/m*f[i<span class="number">-1</span>][j];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;n;i++) <span class="built_in">printf</span>(<span class="string">&quot;%.2lf&quot;</span>,f[n][i]*<span class="number">100</span>),<span class="built_in">putchar</span>(<span class="string">&#x27;%&#x27;</span>),<span class="built_in">putchar</span>(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%.2lf&quot;</span>,f[n][n]*<span class="number">100</span>);<span class="built_in">putchar</span>(<span class="string">&#x27;%&#x27;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title>NOIOnline1 跑步</title>
    <url>/2022/10/11/NOIOnline1-%E8%B7%91%E6%AD%A5/</url>
    <content><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>求正整数 $n$ 的划分个数</p>
<h4 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h4><p>五边形数定理不太会而且也没有什么运用价值，<del>说白了就算我看懂了我也用不来</del>，所以考虑 dp。</p>
<p>令 $f[i][j]$ 表示前 $i$ 个正整数，之和为 $j$ 的方案数。</p>
<p>转移有 $f[i][j]&#x3D;f[i-1][j]+f[i][j-i]$ 。保证了有序性。</p>
<p>但是显然这样复杂度是接受不了的，考虑根号分治。</p>
<p>$f[i][j]$ 的 $i$ 只计算到前 $m-1$ 个。</p>
<p>对于 $\ge m$ 的数，我们令有 $i$ 个 $\ge m$ 的数，之和为 $j$ 的方案数，由 $g[i][j]$ 表示。</p>
<p>$g[i][j]&#x3D;g[i-1][j-m]+g[i][j-i]$。前者表示新增一个大小为 $m$ 的数，后者表示将当前的 $i$ 个数都增加 $1$。由于确保了加入数的大小是从大到小的，所以可以不重不漏的计算完。</p>
<p>计算答案， $ans&#x3D;\sum\limits_{i&#x3D;0}^{n}(f[m-1][i]\times\sum\limits_{j&#x3D;0}^mg[j][n-i])$</p>
<h4 id="code"><a href="#code" class="headerlink" title="code"></a>code</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 100005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> put() putchar(<span class="string">&#x27;\n&#x27;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Tp template<span class="string">&lt;typename Ty&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Ts template<span class="string">&lt;typename Ty,typename... Ar&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(<span class="type">int</span> &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> f=<span class="number">1</span>;x=<span class="number">0</span>;<span class="type">char</span> c=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (c&lt;<span class="string">&#x27;0&#x27;</span>||c&gt;<span class="string">&#x27;9&#x27;</span>) &#123;<span class="keyword">if</span> (c==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">-1</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span> (c&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;c&lt;=<span class="string">&#x27;9&#x27;</span>) &#123;x=x*<span class="number">10</span>+c-<span class="string">&#x27;0&#x27;</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> Debug&#123;</span><br><span class="line">	Tp <span class="type">void</span> _debug(<span class="type">char</span>* f,Ty t)&#123;cerr&lt;&lt;f&lt;&lt;<span class="string">&#x27;=&#x27;</span>&lt;&lt;t&lt;&lt;endl;&#125;</span><br><span class="line">	Ts <span class="type">void</span> _debug(<span class="type">char</span>* f,Ty x,Ar... y)&#123;<span class="keyword">while</span>(*f!=<span class="string">&#x27;,&#x27;</span>) cerr&lt;&lt;*f++;cerr&lt;&lt;<span class="string">&#x27;=&#x27;</span>&lt;&lt;x&lt;&lt;<span class="string">&quot;,&quot;</span>;_debug(f+<span class="number">1</span>,y...);&#125;</span><br><span class="line">	Tp ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; os,vector&lt;Ty&gt;&amp; V)&#123;os&lt;&lt;<span class="string">&quot;[&quot;</span>;<span class="keyword">for</span>(<span class="keyword">auto</span>&amp; vv:V) os&lt;&lt;vv&lt;&lt;<span class="string">&quot;,&quot;</span>;os&lt;&lt;<span class="string">&quot;]&quot;</span>;<span class="keyword">return</span> os;&#125;</span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> gdb(...) _debug(#__VA_ARGS__,__VA_ARGS__)</span></span><br><span class="line">&#125;<span class="keyword">using</span> <span class="keyword">namespace</span> Debug;</span><br><span class="line"><span class="type">int</span> f[maxn],g[<span class="number">405</span>][maxn];</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line"><span class="comment">//  freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);</span></span><br><span class="line">	<span class="type">int</span> n,mod,ans=<span class="number">0</span>,i,j,k;</span><br><span class="line">	<span class="built_in">read</span>(n);<span class="built_in">read</span>(mod);</span><br><span class="line">	<span class="type">int</span> m=<span class="built_in">sqrt</span>(n)+<span class="number">1</span>;</span><br><span class="line">	f[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;m;i++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (j=i;j&lt;=n;j++) </span><br><span class="line">			f[j]+=f[j-i],f[j]%=mod;</span><br><span class="line">	&#125;</span><br><span class="line">	g[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=m;i++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (j=i;j&lt;=n;j++) &#123;</span><br><span class="line">			g[i][j]=g[i][j-i];</span><br><span class="line">			<span class="keyword">if</span> (j&gt;=m) g[i][j]=(g[i][j]+g[i<span class="number">-1</span>][j-m])%mod;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (j=<span class="number">0</span>;j&lt;=n;j++) &#123;</span><br><span class="line">		<span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;=m;i++) sum+=g[i][n-j],sum%=mod;</span><br><span class="line">		ans=(ans+f[j]*sum)%mod;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <tags>
        <tag>dp</tag>
        <tag>五边形数</tag>
      </tags>
  </entry>
  <entry>
    <title>NOIP2018 摆渡车</title>
    <url>/2022/11/14/NOIP2018-%E6%91%86%E6%B8%A1%E8%BD%A6/</url>
    <content><![CDATA[<h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><p>令 $f_i$ 表示在时刻 $i$ 这里上车，$i$ 之前的所有人都运送的最小等车时间之和。</p>
<p>$cnt_i$ 表示 $i$ 之前所有等车人的个数。</p>
<p>$sum_i$ 表示 $i$ 之前所有等车人的时刻之和。</p>
<p>容易列出转移方程<br>$$<br>f_i&#x3D;\min\limits_{j\le i-m}(f_j+(cnt_i-cnt_j)\times i-(sum_i-sum_j))<br>$$<br>出现了 $i$ 项和 $j$ 项之积，考虑斜率优化。</p>
<p>移项，有：<br>$$<br>f_j+sum_j&#x3D;f_i+sum_i-cnt_i\times i+cnt_j\times i<br>$$<br>目的是让截距最小，而切线斜率递增，所以考虑用单调队列维护。</p>
<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 4005005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> put() putchar(<span class="string">&#x27;\n&#x27;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Tp template<span class="string">&lt;typename Ty&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Ts template<span class="string">&lt;typename Ty,typename... Ar&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(<span class="type">int</span> &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> f=<span class="number">1</span>;x=<span class="number">0</span>;<span class="type">char</span> c=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (c&lt;<span class="string">&#x27;0&#x27;</span>||c&gt;<span class="string">&#x27;9&#x27;</span>) &#123;<span class="keyword">if</span> (c==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">-1</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span> (c&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;c&lt;=<span class="string">&#x27;9&#x27;</span>) &#123;x=x*<span class="number">10</span>+c-<span class="string">&#x27;0&#x27;</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> Debug&#123;</span><br><span class="line">	Tp <span class="type">void</span> _debug(<span class="type">char</span>* f,Ty t)&#123;cerr&lt;&lt;f&lt;&lt;<span class="string">&#x27;=&#x27;</span>&lt;&lt;t&lt;&lt;endl;&#125;</span><br><span class="line">	Ts <span class="type">void</span> _debug(<span class="type">char</span>* f,Ty x,Ar... y)&#123;<span class="keyword">while</span>(*f!=<span class="string">&#x27;,&#x27;</span>) cerr&lt;&lt;*f++;cerr&lt;&lt;<span class="string">&#x27;=&#x27;</span>&lt;&lt;x&lt;&lt;<span class="string">&quot;,&quot;</span>;_debug(f+<span class="number">1</span>,y...);&#125;</span><br><span class="line">	Tp ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; os,vector&lt;Ty&gt;&amp; V)&#123;os&lt;&lt;<span class="string">&quot;[&quot;</span>;<span class="keyword">for</span>(<span class="keyword">auto</span>&amp; vv:V) os&lt;&lt;vv&lt;&lt;<span class="string">&quot;,&quot;</span>;os&lt;&lt;<span class="string">&quot;]&quot;</span>;<span class="keyword">return</span> os;&#125;</span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> gdb(...) _debug((char*)#__VA_ARGS__,__VA_ARGS__)</span></span><br><span class="line">&#125;<span class="keyword">using</span> <span class="keyword">namespace</span> Debug;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf=<span class="number">1e18</span>;</span><br><span class="line"><span class="type">int</span> t[maxn],q[maxn],head,tail;</span><br><span class="line"><span class="type">int</span> cnt[maxn],sum[maxn],f[maxn];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">double</span> <span class="title">X</span><span class="params">(<span class="type">int</span> i)</span> </span>&#123;<span class="keyword">return</span> cnt[i];&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">double</span> <span class="title">Y</span><span class="params">(<span class="type">int</span> i)</span> </span>&#123;<span class="keyword">return</span> f[i]+sum[i];&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">double</span> <span class="title">slope1</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> j)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">X</span>(i)==<span class="built_in">X</span>(j)) &#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">Y</span>(i)&lt;<span class="built_in">Y</span>(j)) <span class="keyword">return</span> inf;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">return</span> -inf;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> (<span class="built_in">Y</span>(i)-<span class="built_in">Y</span>(j))/(<span class="built_in">X</span>(i)-<span class="built_in">X</span>(j));</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> base=<span class="number">4e6</span>+<span class="number">500</span>;</span><br><span class="line"><span class="type">int</span> Ans=inf;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> i,qw=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">read</span>(n);<span class="built_in">read</span>(m);</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="built_in">read</span>(t[i]);t[i]++;qw=<span class="built_in">max</span>(qw,t[i]);</span><br><span class="line">		cnt[t[i]]++;</span><br><span class="line">		sum[t[i]]+=t[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;=base;i++) cnt[i]+=cnt[i<span class="number">-1</span>],sum[i]+=sum[i<span class="number">-1</span>];</span><br><span class="line">	q[head=tail=<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=base;i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (i&gt;m) &#123;</span><br><span class="line">			<span class="keyword">while</span> (head&lt;tail&amp;&amp;<span class="built_in">slope1</span>(q[tail<span class="number">-1</span>],q[tail])&gt;<span class="built_in">slope1</span>(q[tail],i-m)) tail--;</span><br><span class="line">			<span class="keyword">if</span> (<span class="built_in">slope1</span>(q[tail],i-m)&lt;inf) q[++tail]=i-m;</span><br><span class="line">		&#125; </span><br><span class="line">		<span class="keyword">while</span> (head&lt;tail&amp;&amp;<span class="built_in">slope1</span>(q[head],q[head+<span class="number">1</span>])&lt;=i) head++;</span><br><span class="line">		<span class="type">int</span> j=q[head];</span><br><span class="line">		f[i]=f[j]+(cnt[i]-cnt[j])*i-(sum[i]-sum[j]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (i=qw;i&lt;=base;i++) Ans=<span class="built_in">min</span>(Ans,f[i]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,Ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意到 $t_i$ 可能有等于 $0$ 的情况。</p>
<p>计算斜率时，如果两个点的横坐标相等，注意特判。 </p>
<p>事实上，有效的点数只有 $O(nm)$ 个，所以应该可以做到 $O(nm)$ 的复杂度（？</p>
]]></content>
      <tags>
        <tag>dp</tag>
        <tag>斜率优化</tag>
      </tags>
  </entry>
  <entry>
    <title>NOIOnline 2022 讨论</title>
    <url>/2022/10/19/NOIOnline-2022-%E8%AE%A8%E8%AE%BA/</url>
    <content><![CDATA[<p>将每个人按会的题目 $k_i$ 从大到小排序。</p>
<p>按顺序枚举每个人 $x$，记录每道题目 $i$ 到当前会这道题的人且序号最小的人 $t_i$。</p>
<p>如果有两个不同的人与 $x$ 有交集。不妨设这两个人的题目集合为 $A,B$，$x$ 会的集合为 $S$。</p>
<ul>
<li>$A\subseteq B$ <ul>
<li>如果 $S \subseteq A$ ，显然就不会枚举到 $B$ 中的数了。</li>
<li>否则 $A$ 和 $S$ 有交集且会相互讨论。</li>
</ul>
</li>
<li>$B\subseteq A$ 同上</li>
<li>$A\cup B \not &#x3D; \varnothing$ ，如果不包含但有交集，应该在算法枚举到 $A$ 或者 $B$ 时就退出了，故不存在这种情况。</li>
<li>$A\cup B&#x3D;\varnothing$ ，随便出一个就是解。</li>
</ul>
<p>综上，如果和两个不同的人有交集，便一定有解。</p>
<p>如果只有一个有交集，判断是否为包含关系即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 1000005 </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> put() putchar(<span class="string">&#x27;\n&#x27;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Tp template<span class="string">&lt;typename Ty&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Ts template<span class="string">&lt;typename Ty,typename... Ar&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(<span class="type">int</span> &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> f=<span class="number">1</span>;x=<span class="number">0</span>;<span class="type">char</span> c=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (c&lt;<span class="string">&#x27;0&#x27;</span>||c&gt;<span class="string">&#x27;9&#x27;</span>) &#123;<span class="keyword">if</span> (c==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">-1</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span> (c&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;c&lt;=<span class="string">&#x27;9&#x27;</span>) &#123;x=x*<span class="number">10</span>+c-<span class="string">&#x27;0&#x27;</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> Debug&#123;</span><br><span class="line">	Tp <span class="type">void</span> _debug(<span class="type">char</span>* f,Ty t)&#123;cerr&lt;&lt;f&lt;&lt;<span class="string">&#x27;=&#x27;</span>&lt;&lt;t&lt;&lt;endl;&#125;</span><br><span class="line">	Ts <span class="type">void</span> _debug(<span class="type">char</span>* f,Ty x,Ar... y)&#123;<span class="keyword">while</span>(*f!=<span class="string">&#x27;,&#x27;</span>) cerr&lt;&lt;*f++;cerr&lt;&lt;<span class="string">&#x27;=&#x27;</span>&lt;&lt;x&lt;&lt;<span class="string">&quot;,&quot;</span>;_debug(f+<span class="number">1</span>,y...);&#125;</span><br><span class="line">	Tp ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; os,vector&lt;Ty&gt;&amp; V)&#123;os&lt;&lt;<span class="string">&quot;[&quot;</span>;<span class="keyword">for</span>(<span class="keyword">auto</span>&amp; vv:V) os&lt;&lt;vv&lt;&lt;<span class="string">&quot;,&quot;</span>;os&lt;&lt;<span class="string">&quot;]&quot;</span>;<span class="keyword">return</span> os;&#125;</span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> gdb(...) _debug(#__VA_ARGS__,__VA_ARGS__)</span></span><br><span class="line">&#125;<span class="keyword">using</span> <span class="keyword">namespace</span> Debug;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;a[maxn];</span><br><span class="line"><span class="type">int</span> t[<span class="number">2</span>*maxn],id[maxn],len[maxn];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span> </span>&#123;<span class="keyword">return</span> len[x]&gt;len[y];&#125;</span><br><span class="line"><span class="type">int</span> vis[<span class="number">2</span>*maxn]; </span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> j)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> flag1=<span class="number">0</span>,flag2=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> x:a[j]) vis[x]=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> x:a[i]) vis[x]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> x:a[j]) &#123;</span><br><span class="line">		vis[x]+=<span class="number">2</span>;</span><br><span class="line">		<span class="keyword">if</span> (vis[x]==<span class="number">2</span>) flag1=<span class="number">1</span>; </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> x:a[i]) flag2|=(vis[x]==<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span> flag1&amp;&amp;flag2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">solve</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> i,j,x;</span><br><span class="line">	<span class="built_in">read</span>(n);</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="built_in">read</span>(len[i]);a[i].<span class="built_in">clear</span>();id[i]=i;</span><br><span class="line">		<span class="keyword">for</span> (j=<span class="number">0</span>;j&lt;len[i];j++) <span class="built_in">read</span>(x),t[x]=<span class="number">0</span>,a[i].<span class="built_in">push_back</span>(x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">sort</span>(id+<span class="number">1</span>,id+<span class="number">1</span>+n,cmp);</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="type">int</span> las=<span class="number">0</span>,flag=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> x:a[id[i]]) </span><br><span class="line">			<span class="keyword">if</span> (!t[x]) flag=<span class="number">1</span>;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">if</span> (!las) las=t[x];</span><br><span class="line">				<span class="keyword">if</span> (t[x]!=las) &#123;</span><br><span class="line">					<span class="keyword">if</span> (<span class="built_in">check</span>(id[i],t[x])) <span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">&quot;YES\n%d %d\n&quot;</span>,id[i],t[x]),<span class="built_in">void</span>();</span><br><span class="line">					<span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">&quot;YES\n%d %d\n&quot;</span>,id[i],las),<span class="built_in">void</span>();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		<span class="keyword">if</span> (las&amp;&amp;flag) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">&quot;YES\n%d %d\n&quot;</span>,id[i],las),<span class="built_in">void</span>();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> x:a[id[i]]) t[x]=id[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;NO&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> T;</span><br><span class="line">	<span class="built_in">read</span>(T);</span><br><span class="line">	<span class="keyword">while</span> (T--) <span class="built_in">solve</span>(); </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>杂题</tag>
      </tags>
  </entry>
  <entry>
    <title>NOIP2022模拟赛 1</title>
    <url>/2022/06/29/NOIP2022%E6%A8%A1%E6%8B%9F%E8%B5%9B-1/</url>
    <content><![CDATA[<h2 id="NOIP2022-模拟赛-1-题解"><a href="#NOIP2022-模拟赛-1-题解" class="headerlink" title="NOIP2022 模拟赛 1 题解"></a>NOIP2022 模拟赛 1 题解</h2><h3 id="T1"><a href="#T1" class="headerlink" title="T1"></a>T1</h3><h4 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h4><p>$p_i$ 为第 $i$ 个质数。</p>
<p>$S_i&#x3D;(p_i\times i)\mod w$</p>
<p>$P_i&#x3D;S_i+S_{i&#x2F;10+1}$，$i&#x2F;10$ 向下取整。</p>
<p>$M(i,j)$ 表示 $P_i,P_{i+1},…,P_j$ 的中位数。</p>
<p>求 $\sum\limits_{i&#x3D;1}^{n-k+1}M(i,i+k-1)$</p>
<p>$w\le k\le n\le 1e7$</p>
<p>2s，512G。</p>
<h4 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h4><p><strong>首先，2s 是可以筛 2e8 个数中的质数的。</strong>大约为 1.1e7 个。</p>
<p>所以可以 $O(2e8)$ 的时间内求出 $S,P$ 。</p>
<p>因为 $S,P$ 非常随机，可以看为在 $w$ 中的随机分布。</p>
<p>每次更改两个点，对中位数的影响可以看为常数级别的。暴力即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 20000005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> put() putchar(<span class="string">&#x27;\n&#x27;</span>)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(<span class="type">int</span> &amp;x)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> f=<span class="number">1</span>;x=<span class="number">0</span>;<span class="type">char</span> c=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span> (c&lt;<span class="string">&#x27;0&#x27;</span>||c&gt;<span class="string">&#x27;9&#x27;</span>) &#123;<span class="keyword">if</span> (c==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">-1</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">while</span> (c&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;c&lt;=<span class="string">&#x27;9&#x27;</span>) &#123;x=x*<span class="number">10</span>+c-<span class="string">&#x27;0&#x27;</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,k,mod;</span><br><span class="line">bitset&lt;200000005&gt;vis;</span><br><span class="line"><span class="type">int</span> prime[maxn],cnt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">oula</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> i,j;vis[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">2</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!vis[i]) prime[++cnt]=i;</span><br><span class="line">		<span class="keyword">for</span> (j=<span class="number">1</span>;j&lt;=cnt&amp;&amp;i*prime[j]&lt;=n;j++)&#123;</span><br><span class="line">			vis[i*prime[j]]=<span class="number">1</span>;</span><br><span class="line">			<span class="keyword">if</span> (i%prime[j]==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">S</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1ll</span>*prime[x]*x%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">S2</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">S</span>(x)+<span class="built_in">S</span>(x/<span class="number">10</span>+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> t[maxn];</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> i,j;ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="number">0</span>));</span><br><span class="line">	<span class="built_in">read</span>(n);<span class="built_in">read</span>(k);<span class="built_in">read</span>(mod);</span><br><span class="line">	<span class="built_in">oula</span>(<span class="number">200000000</span>);</span><br><span class="line">	<span class="type">int</span> now=<span class="number">0</span>,sum=<span class="number">0</span>,now2=<span class="number">0</span>,sum2=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;k;i++) t[<span class="built_in">S2</span>(i)]++;</span><br><span class="line">	<span class="keyword">if</span> (k%<span class="number">2</span>==<span class="number">1</span>) &#123;</span><br><span class="line">		<span class="keyword">for</span> (i=k;i&lt;=n;i++) &#123;</span><br><span class="line">			t[<span class="built_in">S2</span>(i)]++;</span><br><span class="line">			<span class="keyword">if</span> (<span class="built_in">S2</span>(i)&lt;=now) sum++;</span><br><span class="line">			<span class="keyword">while</span> (sum&lt;(k+<span class="number">1</span>)/<span class="number">2</span>) now++,sum+=t[now];</span><br><span class="line">			<span class="keyword">while</span> (sum-t[now]&gt;=(k+<span class="number">1</span>)/<span class="number">2</span>) sum-=t[now],now--;</span><br><span class="line">			<span class="keyword">if</span> (k&amp;<span class="number">1</span>) ans+=now;</span><br><span class="line">			t[<span class="built_in">S2</span>(i-k+<span class="number">1</span>)]--;</span><br><span class="line">			<span class="keyword">if</span> (<span class="built_in">S2</span>(i-k+<span class="number">1</span>)&lt;=now) sum--; </span><br><span class="line">		&#125; </span><br><span class="line">		<span class="keyword">if</span> (k&amp;<span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">&quot;%lld.0&quot;</span>,ans);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">for</span> (i=k;i&lt;=n;i++) &#123;</span><br><span class="line">			t[<span class="built_in">S2</span>(i)]++;</span><br><span class="line">			<span class="keyword">if</span> (<span class="built_in">S2</span>(i)&lt;=now) sum++;</span><br><span class="line">			<span class="keyword">if</span> (<span class="built_in">S2</span>(i)&lt;=now2) sum2++;</span><br><span class="line">			<span class="keyword">while</span> (sum&lt;k/<span class="number">2</span>) now++,sum+=t[now];</span><br><span class="line">			<span class="keyword">while</span> (sum-t[now]&gt;=k/<span class="number">2</span>) sum-=t[now],now--;</span><br><span class="line">			<span class="keyword">while</span> (sum2&lt;k/<span class="number">2</span>+<span class="number">1</span>) now2++,sum2+=t[now2];</span><br><span class="line">			<span class="keyword">while</span> (sum2-t[now2]&gt;=k/<span class="number">2</span>+<span class="number">1</span>) sum2-=t[now2],now2--;</span><br><span class="line">			ans+=now+now2;</span><br><span class="line">			t[<span class="built_in">S2</span>(i-k+<span class="number">1</span>)]--;</span><br><span class="line">			<span class="keyword">if</span> (<span class="built_in">S2</span>(i-k+<span class="number">1</span>)&lt;=now) sum--; </span><br><span class="line">			<span class="keyword">if</span> (<span class="built_in">S2</span>(i-k+<span class="number">1</span>)&lt;=now2) sum2--; </span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%.1lf&quot;</span>,<span class="number">1.0</span>*ans/<span class="number">2</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>反思：<strong>2s 是可以筛 2e8 个数中的质数的。</strong>不确定的情况下打代码验证。</p>
<h3 id="T2"><a href="#T2" class="headerlink" title="T2"></a>T2</h3><p>同 P6294 [eJOI2017]游戏</p>
<h4 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution"></a>Solution</h4><p>暴力的复杂度显然是 $O(nk\log n)$ 的。用堆模拟即可。</p>
<p>类似于 prufer 序列的求解。不需要考虑人类智慧数据结构。</p>
<p>把 $a_1$ 到 $a_{p_i}$ 放入一个桶中。指针 id 指向最大的权值。若新加入的数 $x$ 大于当前指针，则直接选新加入的数；否则 $x$ 对应的桶更新，指针更新到当前第二小的权值。</p>
<p>注意到指针是只会越来越小，扫一遍的复杂度是 $O(n)$ 的。</p>
<p>$k$ 次询问，复杂度就是 $O(nk)$ 的。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 100005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> put() putchar(<span class="string">&#x27;\n&#x27;</span>)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(<span class="type">int</span> &amp;x)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> f=<span class="number">1</span>;x=<span class="number">0</span>;<span class="type">char</span> c=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span> (c&lt;<span class="string">&#x27;0&#x27;</span>||c&gt;<span class="string">&#x27;9&#x27;</span>) &#123;<span class="keyword">if</span> (c==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">-1</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">while</span> (c&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;c&lt;=<span class="string">&#x27;9&#x27;</span>) &#123;x=x*<span class="number">10</span>+c-<span class="string">&#x27;0&#x27;</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,k,a[maxn];</span><br><span class="line"><span class="keyword">namespace</span> BL&#123;</span><br><span class="line">	priority_queue&lt;<span class="type">int</span>&gt;q;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">solve</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">		<span class="type">int</span> i,m,x,ans1=<span class="number">0</span>,ans2=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) q.<span class="built_in">pop</span>();</span><br><span class="line">		<span class="built_in">read</span>(m);</span><br><span class="line">	    <span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=m;i++) q.<span class="built_in">push</span>(a[i]);</span><br><span class="line">	    <span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">	    	<span class="keyword">if</span> (i&amp;<span class="number">1</span>) ans1+=q.<span class="built_in">top</span>(),q.<span class="built_in">pop</span>();</span><br><span class="line">	    	<span class="keyword">else</span> ans2+=q.<span class="built_in">top</span>(),q.<span class="built_in">pop</span>();</span><br><span class="line">	        <span class="keyword">if</span> (i&lt;=n-m) q.<span class="built_in">push</span>(a[i+m]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans1-ans2);</span><br><span class="line">	&#125; </span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    	<span class="type">int</span> i;</span><br><span class="line">		<span class="keyword">while</span> (k--) <span class="built_in">solve</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;<span class="comment">//暴力</span></span><br><span class="line"><span class="keyword">namespace</span> STD&#123;</span><br><span class="line">	<span class="type">int</span> t[maxn];</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    	<span class="type">int</span> i,now,m;</span><br><span class="line">    	<span class="keyword">while</span> (k--) &#123;</span><br><span class="line">    		now=<span class="number">0</span>;ll ans=<span class="number">0</span>;</span><br><span class="line">    		<span class="built_in">read</span>(m);</span><br><span class="line">    		<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=m;i++) t[a[i]]++,now=<span class="built_in">max</span>(now,a[i]);</span><br><span class="line">			ans+=now;t[now]--;</span><br><span class="line">			<span class="keyword">for</span> (i=<span class="number">2</span>;i&lt;=n;i++) &#123;</span><br><span class="line">				<span class="keyword">if</span> (i&lt;=n-m+<span class="number">1</span>) &#123;</span><br><span class="line">					<span class="keyword">if</span> (a[i+m<span class="number">-1</span>]&gt;=now) &#123;ans+=(i%<span class="number">2</span>==<span class="number">0</span>?<span class="number">-1</span>:<span class="number">1</span>)*a[i+m<span class="number">-1</span>];<span class="keyword">continue</span>;&#125;</span><br><span class="line">				    t[a[i+m<span class="number">-1</span>]]++;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">while</span> (t[now]==<span class="number">0</span>) now--;</span><br><span class="line">				ans+=(i%<span class="number">2</span>==<span class="number">0</span>?<span class="number">-1</span>:<span class="number">1</span>)*now;t[now]--;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);  </span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="built_in">read</span>(n);<span class="built_in">read</span>(k);</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">read</span>(a[i]);</span><br><span class="line">	STD::<span class="built_in">main</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="T3"><a href="#T3" class="headerlink" title="T3"></a>T3</h3><p>同 P4657 [CEOI2017]Chase</p>
<h4 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution"></a>Solution</h4><p>设 $f[i][j]$ 表示 $i$ 到 $i$ 子树内的一点的最多撒 $j$ 的最大权值，$g[i][j]$ 表示 $i$ 子树内一点到 $i$ 最多撒 $j$ 的最大权值。</p>
<p>$in_i$ 表示 $i$ 周围的点（不包括 $i$ ） 的权值。</p>
<p>容易得到转移方程：</p>
<p>$f_{i,j}&#x3D;\max(f_{i,j},f_{i,j-1},f_{son,j},f_{son,j-1}+in_i-w_{son})$</p>
<p>$g_{i,j}&#x3D;\max(g_{i,j},g_{i,j-1},g_{son,j},g_{son_j}+in_i-w_{fa})$</p>
<p>更新答案：</p>
<p>$ans&#x3D;\max(ans,f_{i,j}+g_{son,v-j},f_{i,v},g_{i,v})$</p>
<p>注意到两条路径不能同时经过 $i$ 的同一个儿子，所以正反做一遍。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 100005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> put() putchar(<span class="string">&#x27;\n&#x27;</span>)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(<span class="type">int</span> &amp;x)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> f=<span class="number">1</span>;x=<span class="number">0</span>;<span class="type">char</span> c=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span> (c&lt;<span class="string">&#x27;0&#x27;</span>||c&gt;<span class="string">&#x27;9&#x27;</span>) &#123;<span class="keyword">if</span> (c==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">-1</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">while</span> (c&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;c&lt;=<span class="string">&#x27;9&#x27;</span>) &#123;x=x*<span class="number">10</span>+c-<span class="string">&#x27;0&#x27;</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> in[maxn],w[maxn],n,v,ans=<span class="number">0</span>;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; to[maxn];</span><br><span class="line"><span class="type">int</span> f[maxn][<span class="number">105</span>],g[maxn][<span class="number">105</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> pre)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> i,j,y;</span><br><span class="line">	f[x][<span class="number">0</span>]=g[x][<span class="number">0</span>]=<span class="number">0</span>;<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=v;i++) f[x][i]=in[x],g[x][i]=in[x]-w[pre];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> y:to[x]) </span><br><span class="line">	    <span class="keyword">if</span> (y^pre) &#123;</span><br><span class="line">	    	<span class="built_in">dfs</span>(y,x);</span><br><span class="line">			<span class="keyword">for</span> (j=<span class="number">0</span>;j&lt;=v;j++) ans=<span class="built_in">max</span>(ans,f[x][j]+g[y][v-j]);</span><br><span class="line">	    	<span class="keyword">for</span> (j=<span class="number">1</span>;j&lt;=v;j++) &#123;</span><br><span class="line">	    		f[x][j]=<span class="built_in">max</span>(<span class="built_in">max</span>(<span class="built_in">max</span>(f[x][j<span class="number">-1</span>],f[x][j]),f[y][j]),f[y][j<span class="number">-1</span>]+in[x]-w[y]);</span><br><span class="line">	    		g[x][j]=<span class="built_in">max</span>(<span class="built_in">max</span>(<span class="built_in">max</span>(g[x][j<span class="number">-1</span>],g[x][j]),g[y][j]),g[y][j<span class="number">-1</span>]+in[x]-w[pre]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	f[x][<span class="number">0</span>]=g[x][<span class="number">0</span>]=<span class="number">0</span>;<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=v;i++) f[x][i]=in[x],g[x][i]=in[x]-w[pre];</span><br><span class="line">	<span class="keyword">for</span> (i=to[x].<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">		y=to[x][i];</span><br><span class="line">		<span class="keyword">if</span> (y^pre) &#123;</span><br><span class="line">			<span class="keyword">for</span> (j=<span class="number">0</span>;j&lt;=v;j++) ans=<span class="built_in">max</span>(ans,f[x][j]+g[y][v-j]);</span><br><span class="line">	    	<span class="keyword">for</span> (j=<span class="number">1</span>;j&lt;=v;j++) &#123;</span><br><span class="line">	    		f[x][j]=<span class="built_in">max</span>(<span class="built_in">max</span>(<span class="built_in">max</span>(f[x][j<span class="number">-1</span>],f[x][j]),f[y][j]),f[y][j<span class="number">-1</span>]+in[x]-w[y]);</span><br><span class="line">	    		g[x][j]=<span class="built_in">max</span>(<span class="built_in">max</span>(<span class="built_in">max</span>(g[x][j<span class="number">-1</span>],g[x][j]),g[y][j]),g[y][j<span class="number">-1</span>]+in[x]-w[pre]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	ans=<span class="built_in">max</span>(ans,<span class="built_in">max</span>(f[x][v],g[x][v]));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;ex_chase2.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">	<span class="type">int</span> i,x,y;</span><br><span class="line">	<span class="built_in">read</span>(n);<span class="built_in">read</span>(v);</span><br><span class="line">	<span class="built_in">memset</span>(f,<span class="number">-0x3f</span>,<span class="built_in">sizeof</span>(f));</span><br><span class="line">	<span class="built_in">memset</span>(g,<span class="number">-0x3f</span>,<span class="built_in">sizeof</span>(g));</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">read</span>(w[i]);</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;n;i++) &#123;</span><br><span class="line">		<span class="built_in">read</span>(x);<span class="built_in">read</span>(y);</span><br><span class="line">		to[x].<span class="built_in">push_back</span>(y);</span><br><span class="line">		to[y].<span class="built_in">push_back</span>(x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> y:to[i]) in[i]+=w[y];	</span><br><span class="line">		f[i][<span class="number">1</span>]=g[i][<span class="number">1</span>]=in[i];f[i][<span class="number">0</span>]=g[i][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>NOIP模拟赛</tag>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title>NOIP2021</title>
    <url>/2021/12/30/NOIP2021/</url>
    <content><![CDATA[<p>具体怎么也忘了，分数也忘了，考得挺差的，T1都没切掉，好退役了。</p>
]]></content>
      <tags>
        <tag>游记</tag>
      </tags>
  </entry>
  <entry>
    <title>NOIP2022模拟赛 2</title>
    <url>/2022/06/29/NOIP2022%E6%A8%A1%E6%8B%9F%E8%B5%9B-2/</url>
    <content><![CDATA[<h3 id="T1"><a href="#T1" class="headerlink" title="T1"></a>T1</h3><p>令 $n&#x3D;\prod p_i^{q_i}$<br>$$<br>ans&#x3D;8(\prod p_i^{\left\lfloor\frac{q_i}{2}\right\rfloor} -1)<br>$$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> put() putchar(<span class="string">&#x27;\n&#x27;</span>)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(<span class="type">int</span> &amp;x)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> f=<span class="number">1</span>;x=<span class="number">0</span>;<span class="type">char</span> c=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span> (c&lt;<span class="string">&#x27;0&#x27;</span>||c&gt;<span class="string">&#x27;9&#x27;</span>) &#123;<span class="keyword">if</span> (c==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">-1</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">while</span> (c&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;c&lt;=<span class="string">&#x27;9&#x27;</span>) &#123;x=x*<span class="number">10</span>+c-<span class="string">&#x27;0&#x27;</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">div</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span>&#123; </span><br><span class="line">	<span class="type">int</span> i,n,x;</span><br><span class="line">	<span class="built_in">read</span>(n);</span><br><span class="line">	<span class="keyword">while</span> (n) &#123;</span><br><span class="line">		<span class="type">int</span> ans=<span class="number">0</span>,x=n,sum=<span class="number">1</span>,tmp=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span> (i=<span class="number">2</span>;i*i&lt;=n;i++) &#123;</span><br><span class="line">			<span class="type">int</span> tot=<span class="number">0</span>;</span><br><span class="line">			<span class="keyword">if</span> (x%i==<span class="number">0</span>) &#123;</span><br><span class="line">				<span class="keyword">while</span> (x%i==<span class="number">0</span>) &#123;</span><br><span class="line">					tot++;</span><br><span class="line">					<span class="keyword">if</span> (tot%<span class="number">2</span>==<span class="number">1</span>) sum*=i;</span><br><span class="line">					x/=i;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> (tot==<span class="number">1</span>) tmp*=i;</span><br><span class="line">			&#125; </span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (x) sum*=x,tmp*=x;</span><br><span class="line">	<span class="comment">//	printf(&quot;%lld\n&quot;,sum);</span></span><br><span class="line">		<span class="keyword">for</span> (i=sum;i&lt;n;i+=sum) &#123;</span><br><span class="line">			<span class="type">int</span> x=tmp*(i/sum)*(i/sum)+tmp*((n-i)/sum)*((n-i)/sum);</span><br><span class="line">			<span class="keyword">if</span> ((x+n)%<span class="number">2</span>==<span class="number">0</span>) ans++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans*<span class="number">8</span>);</span><br><span class="line">		<span class="built_in">read</span>(n);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="T2"><a href="#T2" class="headerlink" title="T2"></a>T2</h3><p>先将权值从大到小排序。</p>
<p>每次加入一条边，连接两棵树。</p>
<p>新树的直径的两个端点在原来两棵树的四个直径端点之中。更新即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 200005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> put() putchar(<span class="string">&#x27;\n&#x27;</span>)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(<span class="type">int</span> &amp;x)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> f=<span class="number">1</span>;x=<span class="number">0</span>;<span class="type">char</span> c=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span> (c&lt;<span class="string">&#x27;0&#x27;</span>||c&gt;<span class="string">&#x27;9&#x27;</span>) &#123;<span class="keyword">if</span> (c==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">-1</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">while</span> (c&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;c&lt;=<span class="string">&#x27;9&#x27;</span>) &#123;x=x*<span class="number">10</span>+c-<span class="string">&#x27;0&#x27;</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> h[maxn],head=<span class="number">1</span>,n,m,d[maxn];</span><br><span class="line"><span class="type">int</span> fa[maxn][<span class="number">21</span>],deep[maxn],dis[maxn],lg[maxn],id[maxn];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">yyy</span>&#123;</span><br><span class="line">	<span class="type">int</span> to,z,w;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">		to=y;z=h[x];h[x]=head;w=val;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;a[maxn*<span class="number">2</span>];</span><br><span class="line">__int128 ans,pus;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">ins</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> z)</span> </span>&#123;</span><br><span class="line">	a[++head].<span class="built_in">add</span>(x,y,z);</span><br><span class="line">	a[++head].<span class="built_in">add</span>(y,x,z);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> pre)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> i;deep[x]=deep[pre]+<span class="number">1</span>;fa[x][<span class="number">0</span>]=pre;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=lg[deep[x]];i++) fa[x][i]=fa[fa[x][i<span class="number">-1</span>]][i<span class="number">-1</span>];</span><br><span class="line">	<span class="keyword">for</span> (i=h[x];i;i=a[i].z) <span class="keyword">if</span> (a[i].to^pre) dis[a[i].to]=dis[x]+a[i].w,<span class="built_in">dfs</span>(a[i].to,x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">lca</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="keyword">if</span> (deep[x]&lt;deep[y]) <span class="built_in">swap</span>(x,y);</span><br><span class="line">	<span class="keyword">while</span> (deep[x]&gt;deep[y]) x=fa[x][lg[deep[x]-deep[y]]];</span><br><span class="line">	<span class="keyword">if</span> (x==y) <span class="keyword">return</span> x;</span><br><span class="line">	<span class="keyword">for</span> (i=lg[deep[x]];i&gt;=<span class="number">0</span>;i--) <span class="keyword">if</span> (fa[x][i]^fa[y][i]) x=fa[x][i],y=fa[y][i];</span><br><span class="line">	<span class="keyword">return</span> fa[x][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">D</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> dis[x]+dis[y]<span class="number">-2</span>*dis[<span class="built_in">lca</span>(x,y)];</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> f[maxn],u[maxn],v[maxn],w[maxn];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">getfa</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> x==f[x]?x:f[x]=<span class="built_in">getfa</span>(f[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> d[x]&gt;d[y];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//printf(&quot;%lld %lld  &quot;,x,y);</span></span><br><span class="line">	x=<span class="built_in">getfa</span>(x),y=<span class="built_in">getfa</span>(y);f[x]=y;</span><br><span class="line">	<span class="comment">//printf(&quot;%lld %lld\n&quot;,x,y);</span></span><br><span class="line">	<span class="type">int</span> tmp1=<span class="built_in">D</span>(u[x],u[y]),tmp2=<span class="built_in">D</span>(v[x],u[y]),tmp3=<span class="built_in">D</span>(u[x],v[y]),tmp4=<span class="built_in">D</span>(v[x],v[y]);</span><br><span class="line">	<span class="type">int</span> Max=<span class="built_in">max</span>(tmp1,<span class="built_in">max</span>(tmp2,<span class="built_in">max</span>(tmp3,<span class="built_in">max</span>(tmp4,<span class="built_in">max</span>(w[x],w[y])))));</span><br><span class="line">	<span class="type">int</span> ans1=<span class="number">0</span>,ans2=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (w[y]==Max) ans1=u[y],ans2=v[y];</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (w[x]==Max) ans1=u[x],ans2=v[x];</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (tmp1==Max) ans1=u[x],ans2=u[y];</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (tmp2==Max) ans1=v[x],ans2=u[y];</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (tmp3==Max) ans1=u[x],ans2=v[y];</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (tmp4==Max) ans1=v[x],ans2=v[y]; </span><br><span class="line">	u[y]=ans1,v[y]=ans2;w[y]=Max;</span><br><span class="line">	pus=k;pus=pus*Max;</span><br><span class="line">	ans=<span class="built_in">max</span>(ans,pus);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">write</span><span class="params">(__int128 x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (x&gt;=<span class="number">10</span>) <span class="built_in">write</span>(x/<span class="number">10</span>);</span><br><span class="line">	<span class="built_in">putchar</span>(x%<span class="number">10</span>+<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> i,x,y,z,j;</span><br><span class="line">	<span class="built_in">read</span>(n);</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">read</span>(d[i]),id[i]=i;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">2</span>;i&lt;=n;i++) lg[i]=lg[i/<span class="number">2</span>]+<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;n;i++) &#123;</span><br><span class="line">		<span class="built_in">read</span>(x);<span class="built_in">read</span>(y);<span class="built_in">read</span>(z);</span><br><span class="line">		<span class="built_in">ins</span>(x,y,z);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">sort</span>(id+<span class="number">1</span>,id+<span class="number">1</span>+n,cmp);</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) f[i]=u[i]=v[i]=i;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="type">int</span> x=id[i];</span><br><span class="line">		<span class="comment">//printf(&quot;case %lld\n&quot;,id[i]);</span></span><br><span class="line">		<span class="keyword">for</span> (j=h[x];j;j=a[j].z) &#123;</span><br><span class="line">		<span class="comment">//	printf(&quot;%lld %lld\n&quot;,a[j].to,d[a[j].to]);</span></span><br><span class="line">			<span class="keyword">if</span> (d[a[j].to]&gt;=d[x]) <span class="built_in">merge</span>(x,a[j].to,d[x]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">write</span>(ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="T3"><a href="#T3" class="headerlink" title="T3"></a>T3</h3><p>EJOI 2017 骆驼</p>
<p>不会</p>
]]></content>
      <tags>
        <tag>NOIP模拟赛</tag>
        <tag>构造</tag>
        <tag>树的直径</tag>
      </tags>
  </entry>
  <entry>
    <title>NOIP2022模拟赛 4</title>
    <url>/2022/06/30/NOIP2022%E6%A8%A1%E6%8B%9F%E8%B5%9B-4/</url>
    <content><![CDATA[<h3 id="T1"><a href="#T1" class="headerlink" title="T1"></a>T1</h3><p>每块连续的相同的字符压成形如 $(l,r,x)$ 的三元组，表示 $[l,r]$ 之中全是 $x$。</p>
<p>然后暴力修改就好，复杂度 $O(n+m)$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 5000005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> put() putchar(<span class="string">&#x27;\n&#x27;</span>)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(<span class="type">int</span> &amp;x)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> f=<span class="number">1</span>;x=<span class="number">0</span>;<span class="type">char</span> c=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span> (c&lt;<span class="string">&#x27;0&#x27;</span>||c&gt;<span class="string">&#x27;9&#x27;</span>) &#123;<span class="keyword">if</span> (c==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">-1</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">while</span> (c&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;c&lt;=<span class="string">&#x27;9&#x27;</span>) &#123;x=x*<span class="number">10</span>+c-<span class="string">&#x27;0&#x27;</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">yyy</span>&#123;</span><br><span class="line">	<span class="type">int</span> w,len;</span><br><span class="line">	<span class="built_in">yyy</span>(<span class="type">int</span> a=<span class="number">-1</span>,<span class="type">int</span> b=<span class="number">0</span>) &#123;</span><br><span class="line">		w=a;len=b;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;a[maxn];</span><br><span class="line"><span class="type">int</span> cnt;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> i,l,x,j;<span class="type">char</span> ch;</span><br><span class="line">	<span class="built_in">read</span>(n);<span class="built_in">read</span>(m);</span><br><span class="line">	cin&gt;&gt;ch;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		x=ch-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">		<span class="keyword">if</span> (x==a[cnt].w) a[cnt].len++;</span><br><span class="line">		<span class="keyword">else</span> a[++cnt].w=x,a[cnt].len=<span class="number">1</span>; </span><br><span class="line">		ch=<span class="built_in">getchar</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	cin&gt;&gt;ch;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=m;i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (ch==<span class="string">&#x27;+&#x27;</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (a[cnt].w==<span class="number">1</span>) &#123;</span><br><span class="line">				l=a[cnt].len;</span><br><span class="line">				<span class="keyword">if</span> (cnt&gt;<span class="number">1</span>) &#123;</span><br><span class="line">					<span class="keyword">if</span> (a[cnt<span class="number">-1</span>].len==<span class="number">1</span>) &#123;</span><br><span class="line">						a[cnt<span class="number">-2</span>].len+=<span class="number">1</span>;</span><br><span class="line">						a[cnt<span class="number">-1</span>].w=<span class="number">0</span>;a[cnt<span class="number">-1</span>].len=l;cnt--;</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">else</span> &#123;</span><br><span class="line">						a[cnt<span class="number">-1</span>].len--;</span><br><span class="line">						a[cnt].len=<span class="number">1</span>;</span><br><span class="line">						a[++cnt].w=<span class="number">0</span>,a[cnt].len=l;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> &#123;</span><br><span class="line">					a[cnt].w=<span class="number">1</span>;a[cnt].len=<span class="number">1</span>;</span><br><span class="line">					a[++cnt].w=<span class="number">0</span>;a[cnt].len=l;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				a[cnt].len--;</span><br><span class="line">				<span class="keyword">if</span> (!a[cnt].len) &#123;</span><br><span class="line">					cnt--;</span><br><span class="line">					<span class="keyword">if</span> (a[cnt].w==<span class="number">1</span>) a[cnt].len++;</span><br><span class="line">					<span class="keyword">else</span> a[++cnt].w=<span class="number">1</span>,a[cnt].len=<span class="number">1</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> a[++cnt].w=<span class="number">1</span>,a[cnt].len=<span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (ch==<span class="string">&#x27;-&#x27;</span>) &#123;</span><br><span class="line">			l=a[cnt].len;</span><br><span class="line">			<span class="keyword">if</span> (a[cnt].w==<span class="number">1</span>) &#123;</span><br><span class="line">				a[cnt].len--;</span><br><span class="line">				<span class="keyword">if</span> (!a[cnt].len) &#123;</span><br><span class="line">					cnt--;</span><br><span class="line">	                <span class="keyword">if</span> (a[cnt].w==<span class="number">0</span>) a[cnt].len++;</span><br><span class="line">					<span class="keyword">else</span> a[++cnt].w=<span class="number">0</span>,a[cnt].len=<span class="number">1</span>;  </span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> a[++cnt].w=<span class="number">0</span>,a[cnt].len=<span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">if</span> (a[cnt<span class="number">-1</span>].len==<span class="number">1</span>) &#123;</span><br><span class="line">					<span class="keyword">if</span> (cnt==<span class="number">2</span>) cnt=<span class="number">1</span>,a[cnt].w=<span class="number">1</span>,a[cnt].len=l;</span><br><span class="line">					<span class="keyword">else</span> a[cnt<span class="number">-2</span>].len++,a[cnt<span class="number">-1</span>].w=<span class="number">1</span>,a[cnt<span class="number">-1</span>].len=l,cnt--;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> &#123;</span><br><span class="line">					a[cnt<span class="number">-1</span>].len--;a[cnt].w=<span class="number">0</span>;a[cnt].len=<span class="number">1</span>;</span><br><span class="line">				    a[++cnt].w=<span class="number">1</span>;a[cnt].len=l;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (ch==<span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (a[cnt].w==<span class="number">0</span>) a[cnt].len++;</span><br><span class="line">			<span class="keyword">else</span> a[++cnt].w=<span class="number">0</span>,a[cnt].len=<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			a[cnt].len--;</span><br><span class="line">			<span class="keyword">if</span> (!a[cnt].len) cnt--;</span><br><span class="line">		&#125;</span><br><span class="line"> 	<span class="comment">//	for (j=1;j&lt;=cnt;j++) printf(&quot;%d %d\n&quot;,a[j].w,a[j].len);put();</span></span><br><span class="line">	    ch=<span class="built_in">getchar</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=cnt;i++) <span class="keyword">for</span> (j=<span class="number">1</span>;j&lt;=a[i].len;j++) <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,a[i].w);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="T2"><a href="#T2" class="headerlink" title="T2"></a>T2</h3><p>从大到小构造。</p>
<p>似乎用线段树可以用 $O(Tn\log n)$</p>
<p>借鉴了fls的代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 100005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> put() putchar(<span class="string">&#x27;\n&#x27;</span>)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(<span class="type">int</span> &amp;x)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> f=<span class="number">1</span>;x=<span class="number">0</span>;<span class="type">char</span> c=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span> (c&lt;<span class="string">&#x27;0&#x27;</span>||c&gt;<span class="string">&#x27;9&#x27;</span>) &#123;<span class="keyword">if</span> (c==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">-1</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">while</span> (c&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;c&lt;=<span class="string">&#x27;9&#x27;</span>) &#123;x=x*<span class="number">10</span>+c-<span class="string">&#x27;0&#x27;</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,m,tot[maxn];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">yyy</span>&#123;</span><br><span class="line">	<span class="type">int</span> l,r,x;</span><br><span class="line">	<span class="built_in">yyy</span>(<span class="type">int</span> a=<span class="number">0</span>,<span class="type">int</span> b=<span class="number">0</span>,<span class="type">int</span> c=<span class="number">0</span>)&#123;</span><br><span class="line">		l=a;r=b;x=c;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;a[maxn];</span><br><span class="line">vector&lt;yyy&gt;h[maxn];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">solve</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> i,j,flag=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">read</span>(n);<span class="built_in">read</span>(m);</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) h[i].<span class="built_in">clear</span>(),tot[i]=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=m;i++) &#123;</span><br><span class="line">		<span class="built_in">read</span>(a[i].l);<span class="built_in">read</span>(a[i].r),<span class="built_in">read</span>(a[i].x);</span><br><span class="line">		<span class="keyword">if</span> (a[i].x&lt;<span class="number">0</span>||a[i].x&gt;n) flag=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span> (j=a[i].l;j&lt;=a[i].r;j++) tot[j]++;</span><br><span class="line">		h[a[i].x].<span class="built_in">push_back</span>(a[i]);</span><br><span class="line">	&#125;	</span><br><span class="line">	<span class="keyword">if</span> (flag) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;Impossible&quot;</span>),<span class="built_in">void</span>();</span><br><span class="line">	<span class="keyword">for</span> (i=n;i&gt;=<span class="number">1</span>;i--) &#123;</span><br><span class="line">		<span class="type">int</span> x=<span class="number">1</span>,y=n;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> tmp:h[i]) &#123;x=<span class="built_in">max</span>(x,tmp.l),y=<span class="built_in">min</span>(y,tmp.r);<span class="keyword">for</span> (j=tmp.l;j&lt;=tmp.r;j++) tot[j]--;&#125;</span><br><span class="line">		<span class="keyword">if</span> (x&gt;y) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;Impossible&quot;</span>),<span class="built_in">void</span>();</span><br><span class="line">		<span class="keyword">for</span> (j=x;j&lt;=y;j++) <span class="keyword">if</span> (!tot[j]) &#123;tot[j]=<span class="number">1e9</span>;<span class="keyword">break</span>;&#125; </span><br><span class="line">		<span class="keyword">if</span> (j==y+<span class="number">1</span>) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;Impossible&quot;</span>),<span class="built_in">void</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;Possible&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;1.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">	<span class="type">int</span> T;</span><br><span class="line">	<span class="built_in">read</span>(T);</span><br><span class="line">	<span class="keyword">while</span> (T--) <span class="built_in">solve</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>线段树：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 100005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> put() putchar(<span class="string">&#x27;\n&#x27;</span>)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(<span class="type">int</span> &amp;x)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> f=<span class="number">1</span>;x=<span class="number">0</span>;<span class="type">char</span> c=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span> (c&lt;<span class="string">&#x27;0&#x27;</span>||c&gt;<span class="string">&#x27;9&#x27;</span>) &#123;<span class="keyword">if</span> (c==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">-1</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">while</span> (c&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;c&lt;=<span class="string">&#x27;9&#x27;</span>) &#123;x=x*<span class="number">10</span>+c-<span class="string">&#x27;0&#x27;</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,m,tot[maxn];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">yyy</span>&#123;</span><br><span class="line">	<span class="type">int</span> l,r,x;</span><br><span class="line">	<span class="built_in">yyy</span>(<span class="type">int</span> a=<span class="number">0</span>,<span class="type">int</span> b=<span class="number">0</span>,<span class="type">int</span> c=<span class="number">0</span>)&#123;</span><br><span class="line">		l=a;r=b;x=c;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;a[maxn];</span><br><span class="line">vector&lt;yyy&gt;h[maxn];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">	<span class="type">int</span> Min,lazy,id;</span><br><span class="line">	<span class="built_in">node</span>(<span class="type">int</span> a=<span class="number">0</span>,<span class="type">int</span> b=<span class="number">0</span>,<span class="type">int</span> c=<span class="number">0</span>) &#123;</span><br><span class="line">		Min=a;id=b;lazy=c;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;f[maxn&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Pushup</span><span class="params">(<span class="type">int</span> rt)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (f[rt&lt;&lt;<span class="number">1</span>].Min&lt;f[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].Min) f[rt].Min=f[rt&lt;&lt;<span class="number">1</span>].Min,f[rt].id=f[rt&lt;&lt;<span class="number">1</span>].id;</span><br><span class="line">	<span class="keyword">else</span> f[rt].Min=f[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].Min,f[rt].id=f[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].id;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Pushdown</span><span class="params">(<span class="type">int</span> rt)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (f[rt].lazy) &#123;</span><br><span class="line">		f[rt&lt;&lt;<span class="number">1</span>].Min+=f[rt].lazy;f[rt&lt;&lt;<span class="number">1</span>].lazy+=f[rt].lazy;</span><br><span class="line">		f[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].Min+=f[rt].lazy;f[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].lazy+=f[rt].lazy;</span><br><span class="line">		f[rt].lazy=<span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Build</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> rt)</span> </span>&#123;</span><br><span class="line">	f[rt].lazy=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (l==r) <span class="keyword">return</span> f[rt].id=l,f[rt].Min=tot[l],<span class="built_in">void</span>();</span><br><span class="line">	<span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	<span class="built_in">Build</span>(l,mid,rt&lt;&lt;<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">Build</span> (mid+<span class="number">1</span>,r,rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">Pushup</span>(rt);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Update</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> rt,<span class="type">int</span> head,<span class="type">int</span> tail,<span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (head&lt;=l&amp;&amp;r&lt;=tail) <span class="keyword">return</span> f[rt].lazy+=k,f[rt].Min+=k,<span class="built_in">void</span>();</span><br><span class="line">	<span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	<span class="built_in">Pushdown</span>(rt);</span><br><span class="line">	<span class="keyword">if</span> (head&lt;=mid) <span class="built_in">Update</span>(l,mid,rt&lt;&lt;<span class="number">1</span>,head,tail,k);</span><br><span class="line">	<span class="keyword">if</span> (tail&gt;mid)  <span class="built_in">Update</span>(mid+<span class="number">1</span>,r,rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,head,tail,k);</span><br><span class="line">	<span class="built_in">Pushup</span>(rt);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> node <span class="title">Query</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> rt,<span class="type">int</span> head,<span class="type">int</span> tail)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (head&lt;=l&amp;&amp;r&lt;=tail) <span class="keyword">return</span> f[rt];</span><br><span class="line">	<span class="built_in">Pushdown</span>(rt);</span><br><span class="line">	<span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;node tmp1=<span class="built_in">node</span>(<span class="number">1e9</span>,<span class="number">0</span>,<span class="number">0</span>),tmp2=<span class="built_in">node</span>(<span class="number">1e9</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span> (head&lt;=mid) tmp1=<span class="built_in">Query</span>(l,mid,rt&lt;&lt;<span class="number">1</span>,head,tail);</span><br><span class="line">	<span class="keyword">if</span> (tail&gt;mid)  tmp2=<span class="built_in">Query</span>(mid+<span class="number">1</span>,r,rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,head,tail);</span><br><span class="line">	<span class="keyword">if</span> (tmp1.Min&lt;tmp2.Min) <span class="keyword">return</span> tmp1;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> tmp2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">solve</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> i,j,flag=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">read</span>(n);<span class="built_in">read</span>(m);</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) h[i].<span class="built_in">clear</span>(),tot[i]=<span class="number">0</span>;<span class="built_in">Build</span>(<span class="number">1</span>,n,<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=m;i++) &#123;</span><br><span class="line">		<span class="built_in">read</span>(a[i].l);<span class="built_in">read</span>(a[i].r),<span class="built_in">read</span>(a[i].x);</span><br><span class="line">		<span class="keyword">if</span> (a[i].x&lt;<span class="number">0</span>||a[i].x&gt;n) flag=<span class="number">1</span>;</span><br><span class="line">		<span class="built_in">Update</span>(<span class="number">1</span>,n,<span class="number">1</span>,a[i].l,a[i].r,<span class="number">1</span>);</span><br><span class="line">		h[a[i].x].<span class="built_in">push_back</span>(a[i]);</span><br><span class="line">	&#125;	</span><br><span class="line">	<span class="keyword">if</span> (flag) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;Impossible&quot;</span>),<span class="built_in">void</span>();</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> (i=n;i&gt;=<span class="number">1</span>;i--) &#123;</span><br><span class="line">		<span class="type">int</span> x=<span class="number">1</span>,y=n;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> tmp:h[i]) &#123;x=<span class="built_in">max</span>(x,tmp.l),y=<span class="built_in">min</span>(y,tmp.r);<span class="built_in">Update</span>(<span class="number">1</span>,n,<span class="number">1</span>,tmp.l,tmp.r,<span class="number">-1</span>);&#125;</span><br><span class="line">		<span class="keyword">if</span> (x&gt;y) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;Impossible&quot;</span>),<span class="built_in">void</span>();</span><br><span class="line">		node tmp=<span class="built_in">Query</span>(<span class="number">1</span>,n,<span class="number">1</span>,x,y);</span><br><span class="line">		<span class="keyword">if</span> (tmp.Min&gt;<span class="number">0</span>) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;Impossible&quot;</span>),<span class="built_in">void</span>();</span><br><span class="line">		<span class="built_in">Update</span>(<span class="number">1</span>,n,<span class="number">1</span>,tmp.id,tmp.id,<span class="number">1e9</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;Possible&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;1.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">	<span class="type">int</span> T;</span><br><span class="line">	<span class="built_in">read</span>(T);</span><br><span class="line">	<span class="keyword">while</span> (T--) <span class="built_in">solve</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="T3"><a href="#T3" class="headerlink" title="T3"></a>T3</h3><p>不会。</p>
]]></content>
      <tags>
        <tag>NOIP模拟赛</tag>
        <tag>线段树</tag>
        <tag>构造</tag>
      </tags>
  </entry>
  <entry>
    <title>NOIP2022模拟赛 6</title>
    <url>/2022/06/29/NOIP2022%E6%A8%A1%E6%8B%9F%E8%B5%9B-6/</url>
    <content><![CDATA[<h2 id="T1"><a href="#T1" class="headerlink" title="T1"></a>T1</h2><p>设有的字母种类为 $n$ ，先降序排序。</p>
<p>若 $n&#x3D;1$ ，则输出 $cnt_1(cnt_1-1)&#x2F;2$</p>
<p>若 $n&#x3D;2$ ，构造 122211111，1 为更少的那个字母，输出 $cnt_2-1$</p>
<p>若 $n&gt;2$ ，构造 12223333242343221111，1 为最少的那个字母，输出 $cnt_n-1$</p>
<p>code:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> put() putchar(<span class="string">&#x27;\n&#x27;</span>)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(<span class="type">int</span> &amp;x)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> f=<span class="number">1</span>;x=<span class="number">0</span>;<span class="type">char</span> c=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span> (c&lt;<span class="string">&#x27;0&#x27;</span>||c&gt;<span class="string">&#x27;9&#x27;</span>) &#123;<span class="keyword">if</span> (c==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">-1</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">while</span> (c&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;c&lt;=<span class="string">&#x27;9&#x27;</span>) &#123;x=x*<span class="number">10</span>+c-<span class="string">&#x27;0&#x27;</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> T,cnt[<span class="number">105</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span> </span>&#123;<span class="keyword">return</span> x&gt;y;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">solve</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> i,tot=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=<span class="number">26</span>;i++) <span class="built_in">read</span>(cnt[i]),tot+=cnt[i]!=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">sort</span>(cnt+<span class="number">1</span>,cnt+<span class="number">27</span>,cmp);</span><br><span class="line">	<span class="keyword">if</span> (tot==<span class="number">1</span>) <span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,cnt[<span class="number">1</span>]*(cnt[<span class="number">1</span>]<span class="number">-1</span>)/<span class="number">2</span>),<span class="built_in">void</span>();</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (tot&gt;<span class="number">2</span>) <span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,cnt[tot]<span class="number">-1</span>),<span class="built_in">void</span>();</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,cnt[tot]<span class="number">-1</span>),<span class="built_in">void</span>();<span class="comment">//211111111122</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;1.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="built_in">read</span>(T);</span><br><span class="line">	<span class="keyword">while</span> (T--) <span class="built_in">solve</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="T2"><a href="#T2" class="headerlink" title="T2"></a>T2</h3><p>考虑 $dp$ 。</p>
<p>因为 $r_i,p_i$ 的值域只有 $10^5$ ，向上整除后只有 $101$ 个值.</p>
<p>分段后暴力即可。类似于尺取（？</p>
<p>细节有点多。</p>
<p>code：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 200005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> put() putchar(<span class="string">&#x27;\n&#x27;</span>)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(<span class="type">int</span> &amp;x)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> f=<span class="number">1</span>;x=<span class="number">0</span>;<span class="type">char</span> c=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span> (c&lt;<span class="string">&#x27;0&#x27;</span>||c&gt;<span class="string">&#x27;9&#x27;</span>) &#123;<span class="keyword">if</span> (c==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">-1</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">while</span> (c&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;c&lt;=<span class="string">&#x27;9&#x27;</span>) &#123;x=x*<span class="number">10</span>+c-<span class="string">&#x27;0&#x27;</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> head=<span class="number">1</span>,h[maxn],f[maxn][<span class="number">2</span>],w[maxn][<span class="number">2</span>];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">yyy</span>&#123;</span><br><span class="line">	<span class="type">int</span> to,z;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">		to=y;z=h[x];h[x]=head;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;a[maxn*<span class="number">2</span>];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">fff</span>&#123;</span><br><span class="line">	<span class="type">int</span> w,id,flag;</span><br><span class="line">	<span class="built_in">fff</span>(<span class="type">int</span> a=<span class="number">0</span>,<span class="type">int</span> b=<span class="number">0</span>,<span class="type">int</span> c=<span class="number">0</span>) &#123;id=a;w=b;flag=c;&#125; </span><br><span class="line">&#125;rt[maxn];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">cmp</span><span class="params">(fff x,fff y)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> x.w&lt;y.w;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> t[maxn][<span class="number">2</span>],len[maxn],p[maxn];</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf=<span class="number">1e15</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> i,j,k,size=<span class="number">0</span>,cnt=<span class="number">0</span>,sum=<span class="number">0</span>,ans1=-inf,ans0=-inf;</span><br><span class="line">	<span class="keyword">for</span> (i=h[x];i;i=a[i].z) <span class="built_in">dfs</span>(a[i].to);</span><br><span class="line">	rt[++cnt]=<span class="built_in">fff</span>(x,w[x][<span class="number">0</span>],<span class="number">0</span>);rt[++cnt]=<span class="built_in">fff</span>(x,w[x][<span class="number">1</span>],<span class="number">1</span>);</span><br><span class="line">	f[x][<span class="number">0</span>]=w[x][<span class="number">0</span>];f[x][<span class="number">1</span>]=w[x][<span class="number">1</span>];</span><br><span class="line">	size=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (i=h[x];i;i=a[i].z) &#123;</span><br><span class="line">		rt[++cnt]=<span class="built_in">fff</span>(a[i].to,w[a[i].to][<span class="number">0</span>],<span class="number">0</span>);</span><br><span class="line">		rt[++cnt]=<span class="built_in">fff</span>(a[i].to,w[a[i].to][<span class="number">1</span>],<span class="number">1</span>);</span><br><span class="line">	    size++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">sort</span>(rt+<span class="number">1</span>,rt+<span class="number">1</span>+cnt,cmp);</span><br><span class="line">	<span class="type">int</span> r=<span class="number">0</span>,tot=<span class="number">0</span>;</span><br><span class="line"><span class="comment">//	printf(&quot;case %lld\n&quot;,x);printf(&quot;cnt = %lld\n&quot;,cnt);for (i=1;i&lt;=cnt;i++) printf(&quot;%lld %lld %lld\n&quot;,rt[i].id,rt[i].w ,rt[i].flag);put();</span></span><br><span class="line">	<span class="keyword">for</span> (k=<span class="number">0</span>;k&lt;=rt[cnt].w/<span class="number">1000</span>+<span class="number">1</span>;k++) &#123;</span><br><span class="line">		sum=<span class="number">0</span>;tot=<span class="number">0</span>;r=<span class="number">0</span>;</span><br><span class="line">		t[x][<span class="number">0</span>]=t[x][<span class="number">1</span>]=-inf;len[x]=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (j=<span class="number">1</span>;j&lt;=cnt;j++) len[rt[j].id]=<span class="number">0</span>,t[rt[j].id][<span class="number">0</span>]=t[rt[j].id][<span class="number">1</span>]=-inf;</span><br><span class="line">		<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=cnt;i++) &#123;</span><br><span class="line">			<span class="keyword">while</span> (r&lt;cnt&amp;&amp;(rt[r+<span class="number">1</span>].w-rt[i].w+<span class="number">999</span>)/<span class="number">1000</span>&lt;=k)&#123;</span><br><span class="line">				++r;</span><br><span class="line">				<span class="keyword">if</span> (len[rt[r].id]++==<span class="number">0</span>) tot++;</span><br><span class="line">				t[rt[r].id][rt[r].flag]=f[rt[r].id][rt[r].flag];</span><br><span class="line">				<span class="keyword">if</span> (rt[r].id!=x) &#123;</span><br><span class="line">					<span class="keyword">if</span> (len[rt[r].id]==<span class="number">1</span>) sum+=f[rt[r].id][rt[r].flag];</span><br><span class="line">					<span class="keyword">else</span> sum-=f[rt[r].id][rt[r].flag^<span class="number">1</span>],sum+=<span class="built_in">max</span>(f[rt[r].id][rt[r].flag],f[rt[r].id][rt[r].flag^<span class="number">1</span>]);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		    <span class="keyword">if</span> (tot==size) &#123;</span><br><span class="line">		    	<span class="keyword">if</span> (t[x][<span class="number">0</span>]&gt;-inf) ans0=<span class="built_in">max</span>(ans0,sum-k*<span class="number">666</span>*x+w[x][<span class="number">0</span>]);</span><br><span class="line">				<span class="keyword">if</span> (t[x][<span class="number">1</span>]&gt;-inf) ans1=<span class="built_in">max</span>(ans1,sum-k*<span class="number">666</span>*x+w[x][<span class="number">1</span>]);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (--len[rt[i].id]==<span class="number">1</span>) &#123;</span><br><span class="line">				<span class="keyword">if</span> (rt[i].id^x) &#123;</span><br><span class="line">					sum-=<span class="built_in">max</span>(f[rt[i].id][rt[i].flag],f[rt[i].id][rt[i].flag^<span class="number">1</span>]);</span><br><span class="line">					sum+=f[rt[i].id][rt[i].flag^<span class="number">1</span>];</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">if</span> (rt[i].id^x) sum-=f[rt[i].id][rt[i].flag];</span><br><span class="line">				tot--;</span><br><span class="line">			&#125;</span><br><span class="line">			t[rt[i].id][rt[i].flag]=-inf;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	f[x][<span class="number">0</span>]=ans0,f[x][<span class="number">1</span>]=ans1;</span><br><span class="line"><span class="comment">//	printf(&quot;f0=%lld f1=%lld\n&quot;,f[x][0],f[x][1]);</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> i,x,y;</span><br><span class="line">	<span class="built_in">read</span>(n);</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) f[i][<span class="number">0</span>]=f[i][<span class="number">1</span>]=-inf;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="built_in">read</span>(w[i][<span class="number">0</span>]),<span class="built_in">read</span>(w[i][<span class="number">1</span>]);</span><br><span class="line">		<span class="keyword">if</span> (w[i][<span class="number">0</span>]&lt;w[i][<span class="number">1</span>]) <span class="built_in">swap</span>(w[i][<span class="number">0</span>],w[i][<span class="number">1</span>]);  </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;n;i++) &#123;</span><br><span class="line">		<span class="built_in">read</span>(x);<span class="built_in">read</span>(y);a[++head].<span class="built_in">add</span>(x,y);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,<span class="built_in">max</span>(f[<span class="number">1</span>][<span class="number">0</span>],f[<span class="number">1</span>][<span class="number">1</span>]));</span><br><span class="line"> 	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="T3"><a href="#T3" class="headerlink" title="T3"></a>T3</h2><p>暴力 $O(mn^2)$</p>
<p>考虑优化这个暴力，马拉车跑出每个点为中心点向外扩展最远的距离 $d_i$。</p>
<ul>
<li><p>对于回文长度是奇数的</p>
<p>对于位置 $i$ ，最长回文串的为 $[i-d_i,i+d_i]$，令 $x&#x3D;\min(d_i,i-l,r-l)$。</p>
<p>答案是 $\sum\limits_{j&#x3D;0}^{x} sum_{i+j}-sum_{i-j-1}$</p>
<p>令 $ss$ 为 $sum$ 的前缀和，则答案等价于 $ss_{i+j}-2ss_{i-1}+ss_{i-j-2}$</p>
<p>根据回文的对称性，答案又等价于 $a_i(j+1)+2(ss_{i+j}-ss_i-j*sum_i)$</p>
<p>则等价于在区间 $[i,i+j]$ 中每个点加上 $a_i$，在区间 $[i,i+j]$ 中的点 $k$ 加上 $2sum_k-2sum_i$。</p>
<p>而 $x$ 的条件可以将询问离线，按右端点排序升序。将右半部分的点进行操作。</p>
<p>左半部分同理。 </p>
</li>
<li><p>偶数同理。</p>
</li>
</ul>
<p>code:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 200005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> put() putchar(<span class="string">&#x27;\n&#x27;</span>)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(<span class="type">int</span> &amp;x)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> f=<span class="number">1</span>;x=<span class="number">0</span>;<span class="type">char</span> c=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span> (c&lt;<span class="string">&#x27;0&#x27;</span>||c&gt;<span class="string">&#x27;9&#x27;</span>) &#123;<span class="keyword">if</span> (c==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">-1</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">while</span> (c&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;c&lt;=<span class="string">&#x27;9&#x27;</span>) &#123;x=x*<span class="number">10</span>+c-<span class="string">&#x27;0&#x27;</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,m,a[maxn],sum[maxn],b[maxn],d[maxn],ss[maxn];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Manacher</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	b[<span class="number">0</span>]=<span class="number">0</span>;b[<span class="number">2</span>*n]=<span class="number">0</span>;b[<span class="number">2</span>*n+<span class="number">1</span>]=<span class="number">1e9</span>;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) b[i*<span class="number">2</span><span class="number">-1</span>]=a[i];</span><br><span class="line">	<span class="type">int</span> N=n*<span class="number">2</span><span class="number">-1</span>,mid,mx;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>,mid=<span class="number">0</span>,mx=<span class="number">0</span>;i&lt;=N;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span> (i&lt;=mx) d[i]=<span class="built_in">min</span>(d[(mid&lt;&lt;<span class="number">1</span>)-i],mx-i+<span class="number">1</span>);</span><br><span class="line">		<span class="keyword">while</span> (b[i-d[i]]==b[i+d[i]]) d[i]++;</span><br><span class="line">		<span class="keyword">if</span> (mx&lt;i+d[i]) mx=i+d[i]<span class="number">-1</span>,mid=i;  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=N;i++) d[i]--;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">yyy</span>&#123;</span><br><span class="line">    <span class="type">int</span> lazy1,lazy2,sum;</span><br><span class="line">&#125;f[maxn&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Pushup</span><span class="params">(<span class="type">int</span> rt)</span></span>&#123;</span><br><span class="line">	f[rt].sum=f[rt&lt;&lt;<span class="number">1</span>].sum+f[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Pushdown</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> rt)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span> (f[rt].lazy1) &#123;</span><br><span class="line">		f[rt&lt;&lt;<span class="number">1</span>].sum+=f[rt].lazy1*(ss[mid]-ss[l<span class="number">-1</span>]);</span><br><span class="line">		f[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].sum+=f[rt].lazy1*(ss[r]-ss[mid]);</span><br><span class="line">		f[rt&lt;&lt;<span class="number">1</span>].lazy1+=f[rt].lazy1;</span><br><span class="line">		f[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].lazy1+=f[rt].lazy1;</span><br><span class="line">		f[rt].lazy1=<span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (f[rt].lazy2) &#123;</span><br><span class="line">		f[rt&lt;&lt;<span class="number">1</span>].sum+=f[rt].lazy2*(mid-l+<span class="number">1</span>);</span><br><span class="line">		f[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].sum+=f[rt].lazy2*(r-mid);</span><br><span class="line">		f[rt&lt;&lt;<span class="number">1</span>].lazy2+=f[rt].lazy2;</span><br><span class="line">		f[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].lazy2+=f[rt].lazy2;</span><br><span class="line">		f[rt].lazy2=<span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Update1</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> rt,<span class="type">int</span> head,<span class="type">int</span> tail,<span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (head&lt;=l&amp;&amp;r&lt;=tail) <span class="keyword">return</span> f[rt].lazy1+=k,f[rt].sum+=k*(ss[r]-ss[l<span class="number">-1</span>]),<span class="built_in">void</span>();</span><br><span class="line"><span class="comment">//	if (rt==1) printf(&quot;111 %lld %lld %lld %lld %lld %lld\n&quot;,l,r,rt,head,tail,k);</span></span><br><span class="line">	<span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	<span class="built_in">Pushdown</span>(l,r,rt);</span><br><span class="line">	<span class="keyword">if</span> (head&lt;=mid) <span class="built_in">Update1</span>(l,mid,rt&lt;&lt;<span class="number">1</span>,head,tail,k);</span><br><span class="line">	<span class="keyword">if</span> (tail&gt;mid)  <span class="built_in">Update1</span>(mid+<span class="number">1</span>,r,rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,head,tail,k);</span><br><span class="line">	<span class="built_in">Pushup</span>(rt);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Update2</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> rt,<span class="type">int</span> head,<span class="type">int</span> tail,<span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (head&lt;=l&amp;&amp;r&lt;=tail) <span class="keyword">return</span> f[rt].lazy2+=k,f[rt].sum+=k*(r-l+<span class="number">1</span>),<span class="built_in">void</span>();</span><br><span class="line"><span class="comment">//	if (rt==1) printf(&quot;222 %lld %lld %lld %lld %lld %lld\n&quot;,l,r,rt,head,tail,k);</span></span><br><span class="line">	<span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	<span class="built_in">Pushdown</span>(l,r,rt);</span><br><span class="line">	<span class="keyword">if</span> (head&lt;=mid) <span class="built_in">Update2</span>(l,mid,rt&lt;&lt;<span class="number">1</span>,head,tail,k);</span><br><span class="line">	<span class="keyword">if</span> (tail&gt;mid)  <span class="built_in">Update2</span>(mid+<span class="number">1</span>,r,rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,head,tail,k);</span><br><span class="line">	<span class="built_in">Pushup</span>(rt);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">Query</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> rt,<span class="type">int</span> head,<span class="type">int</span> tail)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (head&lt;=l&amp;&amp;r&lt;=tail) <span class="keyword">return</span> f[rt].sum;</span><br><span class="line">	<span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>,tmp1=<span class="number">0</span>,tmp2=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">Pushdown</span>(l,r,rt);</span><br><span class="line">	<span class="keyword">if</span> (head&lt;=mid) tmp1=<span class="built_in">Query</span>(l,mid,rt&lt;&lt;<span class="number">1</span>,head,tail);</span><br><span class="line">	<span class="keyword">if</span> (tail&gt;mid)  tmp2=<span class="built_in">Query</span>(mid+<span class="number">1</span>,r,rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,head,tail);</span><br><span class="line">	<span class="keyword">return</span> tmp1+tmp2;</span><br><span class="line">&#125;<span class="comment">/*</span></span><br><span class="line"><span class="comment">namespace BL2&#123;</span></span><br><span class="line"><span class="comment">	inline int calc(int i,int j) &#123;</span></span><br><span class="line"><span class="comment">	//	printf(&quot;1 %lld %lld\n&quot;,i,j);</span></span><br><span class="line"><span class="comment">		return a[i]*(j+1)+2*(ss[i+j]-ss[i]-j*sum[i]);//ss[i+j]-ss[i-1]-ss[i-1]+ss[max(0ll,i-j-2)];</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">	inline int calc2(int i,int j) &#123; </span></span><br><span class="line"><span class="comment">	//	printf(&quot;2 %lld %lld\n&quot;,i,j);</span></span><br><span class="line"><span class="comment">	//	if (j&lt;0) return 0;</span></span><br><span class="line"><span class="comment">	//	return ss[i+j+1]-ss[i]-(ss[i-1]-ss[max(0ll,i-j-2)]);</span></span><br><span class="line"><span class="comment">		return 2*(ss[i+j+1]-ss[i]-sum[i]*(j+1));</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">	inline void main(void) &#123;</span></span><br><span class="line"><span class="comment">		int i,l,r,j,k;</span></span><br><span class="line"><span class="comment">		while (m--) &#123;</span></span><br><span class="line"><span class="comment">			int ans=0;</span></span><br><span class="line"><span class="comment">			read(l);read(r);</span></span><br><span class="line"><span class="comment">			for (i=l;i&lt;=r;i++) ans+=calc(i,min(i-l,min(r-i,d[2*i-1]/2)));</span></span><br><span class="line"><span class="comment">			for (i=l;i&lt;r;i++) ans+=calc2(i,min(i-l,min(r-i-1,d[2*i]/2-1)));</span></span><br><span class="line"><span class="comment">			printf(&quot;%lld\n&quot;,ans);</span></span><br><span class="line"><span class="comment">		&#125;</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"><span class="type">int</span> Ans[maxn];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">qqq</span>&#123;</span><br><span class="line">	<span class="type">int</span> l,r,id,flag;</span><br><span class="line">	<span class="built_in">qqq</span>(<span class="type">int</span> a=<span class="number">0</span>,<span class="type">int</span> b=<span class="number">0</span>,<span class="type">int</span> c=<span class="number">0</span>,<span class="type">int</span> d=<span class="number">0</span>) &#123;</span><br><span class="line">		id=a;l=b;r=c;flag=d;</span><br><span class="line">	&#125; </span><br><span class="line">&#125;qw[maxn];</span><br><span class="line">vector&lt;qqq&gt;q[maxn];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">solve</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> i,j,l,r;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=m;i++) &#123;</span><br><span class="line">		<span class="built_in">read</span>(l),<span class="built_in">read</span>(r);qw[i].l=l;qw[i].r=r;qw[i].id=i;</span><br><span class="line">		q[r].<span class="built_in">push_back</span>(<span class="built_in">qqq</span>(i,l,r,<span class="number">1</span>)),q[(l+r)/<span class="number">2</span>].<span class="built_in">push_back</span>(<span class="built_in">qqq</span>(i,l,r,<span class="number">-1</span>));</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">//	for (i=1;i&lt;=2*n-1;i++) printf(&quot;%lld &quot;,d[i]);put();</span></span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		j=d[<span class="number">2</span>*i<span class="number">-1</span>]/<span class="number">2</span>;</span><br><span class="line">		<span class="keyword">if</span> (i+j&gt;=i+<span class="number">1</span>&amp;&amp;i&lt;n) <span class="built_in">Update1</span>(<span class="number">1</span>,n,<span class="number">1</span>,i+<span class="number">1</span>,i+j,<span class="number">2</span>);</span><br><span class="line">		<span class="keyword">if</span> (i+j&gt;=i+<span class="number">1</span>&amp;&amp;i&lt;n) <span class="built_in">Update2</span>(<span class="number">1</span>,n,<span class="number">1</span>,i+<span class="number">1</span>,i+j,<span class="number">-2</span>*sum[i]);</span><br><span class="line">		<span class="built_in">Update2</span>(<span class="number">1</span>,n,<span class="number">1</span>,i,i+j,a[i]);</span><br><span class="line">		j=d[<span class="number">2</span>*i]/<span class="number">2</span><span class="number">-1</span>;</span><br><span class="line">		<span class="keyword">if</span> (i&lt;n&amp;&amp;j&gt;=<span class="number">0</span>) <span class="built_in">Update1</span>(<span class="number">1</span>,n,<span class="number">1</span>,i+<span class="number">1</span>,i+j+<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">		<span class="keyword">if</span> (i&lt;n&amp;&amp;j&gt;=<span class="number">0</span>) <span class="built_in">Update2</span>(<span class="number">1</span>,n,<span class="number">1</span>,i+<span class="number">1</span>,i+j+<span class="number">1</span>,<span class="number">-2</span>*sum[i]);</span><br><span class="line">	<span class="comment">//	printf(&quot;%lld\n&quot;,f[1].sum);</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> tmp:q[i]) Ans[tmp.id]+=<span class="built_in">Query</span>(<span class="number">1</span>,n,<span class="number">1</span>,tmp.l,tmp.r)*tmp.flag;<span class="comment">//,printf(&quot;%lld %lld %lld %lld\n&quot;,tmp.id,tmp.l,tmp.r,tmp.flag);</span></span><br><span class="line">	&#125;<span class="comment">//for (i=1;i&lt;=m;i++) printf(&quot;%lld\n&quot;,Ans[i]);</span></span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) q[i].<span class="built_in">clear</span>();</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n*<span class="number">4</span>;i++) f[i].sum=f[i].lazy1=f[i].lazy2=<span class="number">0</span>; </span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=m;i++) &#123;</span><br><span class="line">		l=qw[i].l;r=qw[i].r;</span><br><span class="line">		q[(l+r)/<span class="number">2</span>].<span class="built_in">push_back</span>(<span class="built_in">qqq</span>(i,l,r,<span class="number">1</span>)),q[l<span class="number">-1</span>].<span class="built_in">push_back</span>(<span class="built_in">qqq</span>(i,l,r,<span class="number">-1</span>));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (i=n;i&gt;=<span class="number">1</span>;i--) ss[i]=ss[i<span class="number">-1</span>];</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		j=d[<span class="number">2</span>*i<span class="number">-1</span>]/<span class="number">2</span>;</span><br><span class="line">		<span class="keyword">if</span> (i-j&lt;=i<span class="number">-1</span>&amp;&amp;i&gt;<span class="number">1</span>) <span class="built_in">Update1</span>(<span class="number">1</span>,n,<span class="number">1</span>,i-j,i<span class="number">-1</span>,<span class="number">-2</span>);</span><br><span class="line">		<span class="keyword">if</span> (i-j&lt;=i<span class="number">-1</span>&amp;&amp;i&gt;<span class="number">1</span>) <span class="built_in">Update2</span>(<span class="number">1</span>,n,<span class="number">1</span>,i-j,i<span class="number">-1</span>,<span class="number">2</span>*sum[i<span class="number">-1</span>]);</span><br><span class="line">		<span class="built_in">Update2</span>(<span class="number">1</span>,n,<span class="number">1</span>,i-j,i,a[i]);</span><br><span class="line">		j=d[<span class="number">2</span>*i]/<span class="number">2</span><span class="number">-1</span>;</span><br><span class="line">		<span class="keyword">if</span> (i&gt;<span class="number">0</span>&amp;&amp;i-j&lt;=i) <span class="built_in">Update1</span>(<span class="number">1</span>,n,<span class="number">1</span>,i-j,i,<span class="number">-2</span>);</span><br><span class="line">		<span class="keyword">if</span> (i&gt;<span class="number">0</span>&amp;&amp;i-j&lt;=i) <span class="built_in">Update2</span>(<span class="number">1</span>,n,<span class="number">1</span>,i-j,i,<span class="number">2</span>*sum[i]);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> tmp:q[i]) Ans[tmp.id]+=<span class="built_in">Query</span>(<span class="number">1</span>,n,<span class="number">1</span>,tmp.l,tmp.r)*tmp.flag;</span><br><span class="line">	<span class="comment">//	printf(&quot;%lld\n&quot;,f[1].sum);</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=m;i++) <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,Ans[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;1.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">	<span class="built_in">read</span>(n);<span class="built_in">read</span>(m);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">read</span>(a[i]),sum[i]=sum[i<span class="number">-1</span>]+a[i],ss[i]=ss[i<span class="number">-1</span>]+sum[i];</span><br><span class="line">    <span class="built_in">Manacher</span>();</span><br><span class="line"><span class="comment">//	if (n&lt;=300&amp;&amp;m&lt;=300) </span></span><br><span class="line"><span class="comment">//	BL::main();</span></span><br><span class="line"><span class="comment">//	BL2::main();</span></span><br><span class="line">    <span class="built_in">solve</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>NOIP模拟赛</tag>
        <tag>dp</tag>
        <tag>线段树</tag>
        <tag>manacher</tag>
      </tags>
  </entry>
  <entry>
    <title>NOIP2022模拟赛 8</title>
    <url>/2022/06/30/NOIP2022%E6%A8%A1%E6%8B%9F%E8%B5%9B-8/</url>
    <content><![CDATA[<h3 id="T1"><a href="#T1" class="headerlink" title="T1"></a>T1</h3><p>因为 $f(a)&#x3D;f(b)&#x3D;f(c)$ ，所以 $a,b,c$ 三个数模三同余。</p>
<p>所以 $n$ 一定是三的倍数才有解。</p>
<p>对于三的倍数，直接除以三。</p>
<p>否则输出无解。</p>
<p>code:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 20005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> put() putchar(<span class="string">&#x27;\n&#x27;</span>)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(<span class="type">int</span> &amp;x)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> f=<span class="number">1</span>;x=<span class="number">0</span>;<span class="type">char</span> c=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span> (c&lt;<span class="string">&#x27;0&#x27;</span>||c&gt;<span class="string">&#x27;9&#x27;</span>) &#123;<span class="keyword">if</span> (c==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">-1</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">while</span> (c&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;c&lt;=<span class="string">&#x27;9&#x27;</span>) &#123;x=x*<span class="number">10</span>+c-<span class="string">&#x27;0&#x27;</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> a[maxn],n;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">READ</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">	<span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span> (ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>) ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>) a[++n]=ch-<span class="string">&#x27;0&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> ans[maxn];</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line"><span class="comment">//	freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);</span></span><br><span class="line">	<span class="built_in">READ</span>();</span><br><span class="line">	<span class="type">int</span> i,j,tot=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) tot+=a[i];</span><br><span class="line">	<span class="keyword">if</span> (n==<span class="number">1</span>&amp;&amp;a[<span class="number">1</span>]==<span class="number">0</span>) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;0 0 0&quot;</span>),<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (tot%<span class="number">3</span>) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>),<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		ans[i]+=a[i]/<span class="number">3</span>;</span><br><span class="line">		a[i+<span class="number">1</span>]+=a[i]%<span class="number">3</span>*<span class="number">10</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	tot=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span> (ans[<span class="number">1</span>]==<span class="number">0</span>) tot=<span class="number">2</span>;</span><br><span class="line">	<span class="keyword">for</span> (j=<span class="number">1</span>;j&lt;=<span class="number">3</span>;j++,<span class="built_in">putchar</span>(<span class="string">&#x27; &#x27;</span>)) <span class="keyword">for</span> (i=tot;i&lt;=n;i++) <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,ans[i]);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>注意特判 $0$</strong></p>
<h3 id="T2"><a href="#T2" class="headerlink" title="T2"></a>T2</h3><p>同 bzoj1939。</p>
<p>考虑区间 dp。令 $f[i][j][c]$ 表示在区间 $[l,r]$ 中，左边加入 $c$ 个同 $a_l$ 颜色一样的球<strong>后</strong>，<strong>还需要</strong>多少代价。$f[i][j][k-1]$ 代表了加入 $\ge k-1$ 个球，因为加入更多的球没有意义了。</p>
<p>把 $i$ 用 $k-1$ 个球消掉，就是：<br>$$<br>f[i][j][k-1]&#x3D;f[i+1][j][0]<br>$$<br>根据定义，显然有：<br>$$<br>f[i][j][c]&#x3D;f[i][j][c+1]+1\<br>f[i][j][c]&#x3D;\min(f[i][j][c],f[i][j][c-1])<br>$$<br>考虑两个区间合起来的情况。令 $i&lt;l\le j$  且满足 $a_i&#x3D;a_l$。</p>
<p>那么 $f[i][j][c]$ 的代价相当于 $f[i+1][l-1][0]+f[l][j][c+1]$，$i$ 相当于在 $l$ 左边加了个球。</p>
<p>那么转移：<br>$$<br>f[i][j][c]&#x3D;\min(f[i+1][l-1][0]+f[l][j][c+1])<br>$$<br>代码就很好写了：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#define maxn</span><br><span class="line">#define ll long long</span><br><span class="line">#define put() putchar(&#x27;\n&#x27;)</span><br><span class="line">using namespace std;</span><br><span class="line">inline void read(int &amp;x)&#123;</span><br><span class="line">	int f=1;x=0;char c=getchar();</span><br><span class="line">	while (c&lt;&#x27;0&#x27;||c&gt;&#x27;9&#x27;) &#123;if (c==&#x27;-&#x27;) f=-1;c=getchar();&#125;</span><br><span class="line">	while (c&gt;=&#x27;0&#x27;&amp;&amp;c&lt;=&#x27;9&#x27;) &#123;x=x*10+c-&#x27;0&#x27;;c=getchar();&#125;</span><br><span class="line">	x*=f;</span><br><span class="line">&#125;</span><br><span class="line">int f[105][105][5];</span><br><span class="line">int a[105],n,k;</span><br><span class="line">signed main(void)&#123;</span><br><span class="line">	freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);</span><br><span class="line">	int i,j,l,c;</span><br><span class="line">	memset(f,0x3f,sizeof(f));</span><br><span class="line">	read(n);read(k);</span><br><span class="line">	for (i=1;i&lt;=n;i++) &#123;</span><br><span class="line">		read(a[i]);</span><br><span class="line">		f[i][i][k-1]=0;</span><br><span class="line">		for (j=k-2;j&gt;=0;j--) f[i][i][j]=f[i][i][j+1]+1;</span><br><span class="line">	&#125;</span><br><span class="line">	for (i=n;i&gt;=1;i--) </span><br><span class="line">	    for (j=i;j&lt;=n;j++) &#123;</span><br><span class="line">	        f[i][j][k-1]=min(f[i][j][k-1],f[i+1][j][0]);</span><br><span class="line">	        for (c=k-2;c&gt;=0;c--) &#123;</span><br><span class="line">	        	f[i][j][c]=min(f[i][j][c],f[i][j][c+1]+1);</span><br><span class="line">	        	for (l=i+1;l&lt;=j;l++) </span><br><span class="line">	        		if (a[l]==a[i]) &#123;</span><br><span class="line">	        			if (l==i+1) f[i][j][c]=min(f[i][j][c],f[l][j][c+1]);</span><br><span class="line"> 	        			else f[i][j][c]=min(f[i][j][c],f[i+1][l-1][0]+f[l][j][c+1]);</span><br><span class="line">					&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			for (c=1;c&lt;k;c++) f[i][j][c]=min(f[i][j][c],f[i][j][c-1]);</span><br><span class="line">		&#125;</span><br><span class="line">/*	for (i=1;i&lt;=n;i++)</span><br><span class="line">	    for (j=i;j&lt;=n;j++)&#123;</span><br><span class="line">	    	printf(&quot;[ %d , %d ] : &quot;,i,j);</span><br><span class="line">	    	for (c=0;c&lt;k;c++) printf(&quot;%d &quot;,f[i][j][c]);put();</span><br><span class="line">		&#125;*/</span><br><span class="line">	printf(&quot;%d\n&quot;,f[1][n][0]);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="T3"><a href="#T3" class="headerlink" title="T3"></a>T3</h3><p>EJOI2017</p>
<p>贪心，能选就选。正确性反证易得。判断相等用 hash。最好用双模。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 1000005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> put() putchar(<span class="string">&#x27;\n&#x27;</span>)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(<span class="type">int</span> &amp;x)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> f=<span class="number">1</span>;x=<span class="number">0</span>;<span class="type">char</span> c=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span> (c&lt;<span class="string">&#x27;0&#x27;</span>||c&gt;<span class="string">&#x27;9&#x27;</span>) &#123;<span class="keyword">if</span> (c==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">-1</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">while</span> (c&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;c&lt;=<span class="string">&#x27;9&#x27;</span>) &#123;x=x*<span class="number">10</span>+c-<span class="string">&#x27;0&#x27;</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">998244353</span>,p=<span class="number">29</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">power</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> ans=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (y) &#123;</span><br><span class="line">		<span class="keyword">if</span> (y&amp;<span class="number">1</span>) ans=ans*x%mod;</span><br><span class="line">		x=x*x%mod;y&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> BL&#123;</span><br><span class="line">	string s;</span><br><span class="line">	<span class="type">int</span> has[maxn],isuf[maxn],suf[maxn],w[<span class="number">27</span>];</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">Ha</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> (has[r]-has[l<span class="number">-1</span>]+mod)*isuf[l]%mod;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">		<span class="type">int</span> i,j;</span><br><span class="line">		cin&gt;&gt;s;<span class="type">int</span> n=s.<span class="built_in">size</span>();s=<span class="string">&#x27;_&#x27;</span>+s;</span><br><span class="line">		suf[<span class="number">0</span>]=isuf[<span class="number">0</span>]=<span class="number">1</span>;suf[<span class="number">1</span>]=p;isuf[<span class="number">1</span>]=<span class="built_in">power</span>(p,mod<span class="number">-2</span>);</span><br><span class="line">		<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=<span class="number">26</span>;i++) w[i]=i;</span><br><span class="line">		<span class="built_in">random_shuffle</span>(w+<span class="number">1</span>,w+<span class="number">1</span>+<span class="number">26</span>);<span class="comment">//防hack</span></span><br><span class="line">		<span class="keyword">for</span> (i=<span class="number">2</span>;i&lt;=n;i++) suf[i]=suf[i<span class="number">-1</span>]*p%mod,isuf[i]=isuf[i<span class="number">-1</span>]*isuf[<span class="number">1</span>]%mod;</span><br><span class="line">		<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) has[i]=(has[i<span class="number">-1</span>]+(w[s[i]-<span class="string">&#x27;a&#x27;</span>+<span class="number">1</span>])*suf[i])%mod;</span><br><span class="line">		<span class="type">int</span> m=n/<span class="number">2</span>;</span><br><span class="line">		<span class="type">int</span> las=<span class="number">1</span>,tot=<span class="number">0</span>;</span><br><span class="line">	    <span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=m;i++) <span class="keyword">if</span> (<span class="built_in">Ha</span>(las,i)==<span class="built_in">Ha</span>(n-i+<span class="number">1</span>,n-las+<span class="number">1</span>)) tot+=<span class="number">2</span>,las=i+<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span> (las!=(n+<span class="number">1</span>)/<span class="number">2</span>+<span class="number">1</span>) tot++;  </span><br><span class="line">	    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,tot);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;1.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">	<span class="type">int</span> T,n;</span><br><span class="line">	<span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="number">0</span>));</span><br><span class="line">	<span class="built_in">read</span>(T);</span><br><span class="line">	<span class="keyword">while</span> (T--) BL::<span class="built_in">main</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>NOIP模拟赛</tag>
        <tag>dp</tag>
        <tag>bzoj</tag>
      </tags>
  </entry>
  <entry>
    <title>NOIP2022模拟赛 9</title>
    <url>/2022/06/30/NOIP2022%E6%A8%A1%E6%8B%9F%E8%B5%9B-9/</url>
    <content><![CDATA[<p>这场好水，但是T3CE了（乐</p>
<h3 id="T1"><a href="#T1" class="headerlink" title="T1"></a>T1</h3><p>从大到小枚举因数，类似于埃式筛。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 1000005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> put() putchar(<span class="string">&#x27;\n&#x27;</span>)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(<span class="type">int</span> &amp;x)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> f=<span class="number">1</span>;x=<span class="number">0</span>;<span class="type">char</span> c=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span> (c&lt;<span class="string">&#x27;0&#x27;</span>||c&gt;<span class="string">&#x27;9&#x27;</span>) &#123;<span class="keyword">if</span> (c==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">-1</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">while</span> (c&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;c&lt;=<span class="string">&#x27;9&#x27;</span>) &#123;x=x*<span class="number">10</span>+c-<span class="string">&#x27;0&#x27;</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> fa[maxn];</span><br><span class="line">ll ans;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span> </span>&#123;<span class="keyword">return</span> y==<span class="number">0</span>?x:<span class="built_in">gcd</span>(y,x%y);&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">getfa</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;<span class="keyword">return</span> x==fa[x]?x:fa[x]=<span class="built_in">getfa</span>(fa[x]);&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> fx,fy;</span><br><span class="line">    fx=<span class="built_in">getfa</span>(x);fy=<span class="built_in">getfa</span>(y);</span><br><span class="line">    <span class="keyword">if</span> (fx^fy) fa[fx]=fy,ans+=<span class="built_in">gcd</span>(x,y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line"><span class="comment">//	freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);</span></span><br><span class="line">	<span class="type">int</span> i,j;</span><br><span class="line">	<span class="built_in">read</span>(n);</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) fa[i]=i;</span><br><span class="line">	<span class="keyword">for</span> (i=n;i&gt;=<span class="number">1</span>;i--) </span><br><span class="line">		<span class="keyword">for</span> (j=i*<span class="number">2</span>;j&lt;=n;j+=i)</span><br><span class="line">		    <span class="built_in">merge</span>(i,j);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,ans);</span><br><span class="line"> 	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="T2"><a href="#T2" class="headerlink" title="T2"></a>T2</h3><p>记录下每个连通块是不是已经是基环树。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 200005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> put() putchar(<span class="string">&#x27;\n&#x27;</span>)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(<span class="type">int</span> &amp;x)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> f=<span class="number">1</span>;x=<span class="number">0</span>;<span class="type">char</span> c=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span> (c&lt;<span class="string">&#x27;0&#x27;</span>||c&gt;<span class="string">&#x27;9&#x27;</span>) &#123;<span class="keyword">if</span> (c==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">-1</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">while</span> (c&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;c&lt;=<span class="string">&#x27;9&#x27;</span>) &#123;x=x*<span class="number">10</span>+c-<span class="string">&#x27;0&#x27;</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> head=<span class="number">1</span>,h[maxn];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">yyy</span>&#123;</span><br><span class="line">	<span class="type">int</span> to,z,w;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> val)</span></span>&#123;</span><br><span class="line">		to=y;z=h[x];h[x]=head;w=val;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;a[maxn*<span class="number">2</span>];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">	<span class="type">int</span> x,y,z;</span><br><span class="line">&#125;g[maxn];</span><br><span class="line"><span class="type">int</span> cnt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">cmp</span><span class="params">(node x,node y)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> x.z&gt;y.z;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> fa[maxn],vis[maxn];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">getfa</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;<span class="keyword">return</span> x==fa[x]?x:fa[x]=<span class="built_in">getfa</span>(fa[x]);&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line"><span class="comment">//	freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);</span></span><br><span class="line">	<span class="type">int</span> i,j,x,y,z,ans=<span class="number">0</span>,las,fx,fy;</span><br><span class="line">	<span class="built_in">read</span>(n);<span class="built_in">read</span>(m);</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=m;i++) &#123;</span><br><span class="line">		<span class="built_in">read</span>(x);<span class="built_in">read</span>(y);<span class="built_in">read</span>(z);hjk  </span><br><span class="line">		a[++head].<span class="built_in">add</span>(x,y,z);</span><br><span class="line">		a[++head].<span class="built_in">add</span>(y,x,z); </span><br><span class="line">		g[i].x=x;g[i].y=y;g[i].z=z;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">sort</span>(g+<span class="number">1</span>,g+<span class="number">1</span>+m,cmp);</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) fa[i]=i;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=m;i++) &#123;</span><br><span class="line">		fx=<span class="built_in">getfa</span>(g[i].x);fy=<span class="built_in">getfa</span>(g[i].y);</span><br><span class="line">		<span class="keyword">if</span> (fx==fy&amp;&amp;vis[fx]==<span class="number">0</span>) vis[fx]=<span class="number">1</span>,ans+=g[i].z;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (fx!=fy&amp;&amp;(vis[fx]==<span class="number">0</span>||vis[fy]==<span class="number">0</span>)) vis[fy]|=vis[fx],fa[fx]=fy,ans+=g[i].z;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="T3"><a href="#T3" class="headerlink" title="T3"></a>T3</h3><p>排序后两个指针。或者扔到 <code>multiset</code> 里好像也可以。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 500005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> put() putchar(<span class="string">&#x27;\n&#x27;</span>)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(<span class="type">int</span> &amp;x)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> f=<span class="number">1</span>;x=<span class="number">0</span>;<span class="type">char</span> c=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span> (c&lt;<span class="string">&#x27;0&#x27;</span>||c&gt;<span class="string">&#x27;9&#x27;</span>) &#123;<span class="keyword">if</span> (c==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">-1</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">while</span> (c&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;c&lt;=<span class="string">&#x27;9&#x27;</span>) &#123;x=x*<span class="number">10</span>+c-<span class="string">&#x27;0&#x27;</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> a[maxn];</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line"><span class="comment">//	freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);</span></span><br><span class="line">	<span class="type">int</span> i,ans=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">read</span>(n);<span class="built_in">read</span>(m);</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">read</span>(a[i]);</span><br><span class="line">	<span class="built_in">sort</span>(a+<span class="number">1</span>,a+<span class="number">1</span>+n);</span><br><span class="line">	<span class="type">int</span> l=<span class="number">1</span>,r=n;</span><br><span class="line">	<span class="keyword">for</span> (l=<span class="number">1</span>;l&lt;=n;l++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (l&gt;=r) <span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">if</span> (a[l]+a[r]&gt;=m) r--,ans++;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">continue</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>NOIP模拟赛</tag>
      </tags>
  </entry>
  <entry>
    <title>NOIP2022模拟赛2 1</title>
    <url>/2022/07/06/NOIP2022%E6%A8%A1%E6%8B%9F%E8%B5%9B2-1/</url>
    <content><![CDATA[<h3 id="T1"><a href="#T1" class="headerlink" title="T1"></a>T1</h3><p>前缀和，开 long long。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 100005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> put() putchar(<span class="string">&#x27;\n&#x27;</span>)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(<span class="type">int</span> &amp;x)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> f=<span class="number">1</span>;x=<span class="number">0</span>;<span class="type">char</span> c=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span> (c&lt;<span class="string">&#x27;0&#x27;</span>||c&gt;<span class="string">&#x27;9&#x27;</span>) &#123;<span class="keyword">if</span> (c==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">-1</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">while</span> (c&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;c&lt;=<span class="string">&#x27;9&#x27;</span>) &#123;x=x*<span class="number">10</span>+c-<span class="string">&#x27;0&#x27;</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> sum[maxn],n;</span><br><span class="line"><span class="type">int</span> a[maxn];</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;seq.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;seq.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout);</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	sum[<span class="number">1</span>]=a[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">	<span class="built_in">read</span>(n);</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">2</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		a[i]=sum[i<span class="number">-1</span>]%i;</span><br><span class="line">		sum[i]=a[i]*i+sum[i<span class="number">-1</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,a[n]);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="T2"><a href="#T2" class="headerlink" title="T2"></a>T2</h3><p>单调栈预处理出右边第一个比 $i$ 小的位置 $p_i$</p>
<p>线段树做法 $O(n\log n)$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 300005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> put() putchar(<span class="string">&#x27;\n&#x27;</span>)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(<span class="type">int</span> &amp;x)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> f=<span class="number">1</span>;x=<span class="number">0</span>;<span class="type">char</span> c=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span> (c&lt;<span class="string">&#x27;0&#x27;</span>||c&gt;<span class="string">&#x27;9&#x27;</span>) &#123;<span class="keyword">if</span> (c==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">-1</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">while</span> (c&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;c&lt;=<span class="string">&#x27;9&#x27;</span>) &#123;x=x*<span class="number">10</span>+c-<span class="string">&#x27;0&#x27;</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,a[maxn];</span><br><span class="line"><span class="type">int</span> qmin[maxn],qmax[maxn];</span><br><span class="line"><span class="type">int</span> stac[maxn],tot;</span><br><span class="line"><span class="type">int</span> f[maxn&lt;&lt;<span class="number">2</span>],dp[maxn];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Update</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> rt,<span class="type">int</span> head,<span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (l==r) <span class="keyword">return</span> f[rt]=k,<span class="built_in">void</span>();</span><br><span class="line">	<span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span> (head&lt;=mid) <span class="built_in">Update</span>(l,mid,rt&lt;&lt;<span class="number">1</span>,head,k);</span><br><span class="line">	<span class="keyword">if</span> (head&gt;mid) <span class="built_in">Update</span>(mid+<span class="number">1</span>,r,rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,head,k);</span><br><span class="line">	f[rt]=<span class="built_in">min</span>(f[rt&lt;&lt;<span class="number">1</span>],f[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">Query</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> rt,<span class="type">int</span> head,<span class="type">int</span> tail)</span> </span>&#123;</span><br><span class="line"><span class="comment">//	printf(&quot;%d %d %d : %d\n&quot;,l,r,rt,f[rt]);</span></span><br><span class="line">	<span class="keyword">if</span> (head&lt;=l&amp;&amp;r&lt;=tail) <span class="keyword">return</span> f[rt];</span><br><span class="line">	<span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>,tmp1=<span class="number">1e9</span>,tmp2=<span class="number">1e9</span>;</span><br><span class="line">	<span class="keyword">if</span> (head&lt;=mid) tmp1=<span class="built_in">Query</span>(l,mid,rt&lt;&lt;<span class="number">1</span>,head,tail);</span><br><span class="line">	<span class="keyword">if</span> (tail&gt;mid)  tmp2=<span class="built_in">Query</span>(mid+<span class="number">1</span>,r,rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,head,tail);</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">min</span>(tmp1,tmp2);</span><br><span class="line">&#125;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;h[maxn];</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;split.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);<span class="built_in">freopen</span>(<span class="string">&quot;split.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout);</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="built_in">read</span>(n);</span><br><span class="line">	<span class="built_in">memset</span>(f,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(f));</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">read</span>(a[i]);</span><br><span class="line">	a[<span class="number">0</span>]=<span class="number">1e9</span>;a[n+<span class="number">1</span>]=<span class="number">-1e9</span>;</span><br><span class="line">	stac[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (tot=<span class="number">0</span>,i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="keyword">while</span> (tot&amp;&amp;a[stac[tot]]&lt;=a[i]) tot--;</span><br><span class="line">		qmax[i]=stac[tot];</span><br><span class="line">		stac[++tot]=i;</span><br><span class="line">	&#125;</span><br><span class="line">	stac[<span class="number">0</span>]=n+<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (tot=<span class="number">0</span>,i=n;i&gt;=<span class="number">1</span>;i--) &#123;</span><br><span class="line">		<span class="keyword">while</span> (tot&amp;&amp;a[stac[tot]]&gt;=a[i]) tot--;</span><br><span class="line">		qmin[i]=stac[tot];</span><br><span class="line">		stac[++tot]=i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) h[qmin[i]].<span class="built_in">push_back</span>(i);</span><br><span class="line"><span class="comment">//	for (i=1;i&lt;=n;i++) printf(&quot;%d %d\n&quot;,qmax[i],qmin[i]);</span></span><br><span class="line">	dp[<span class="number">1</span>]=<span class="number">1</span>;<span class="built_in">Update</span>(<span class="number">1</span>,n,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">2</span>;i&lt;=n;i++) &#123;</span><br><span class="line"><span class="comment">//		printf(&quot;case %d\n&quot;,i); </span></span><br><span class="line">		<span class="built_in">Update</span>(<span class="number">1</span>,n,<span class="number">1</span>,i,dp[i<span class="number">-1</span>]);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> j:h[i]) <span class="built_in">Update</span>(<span class="number">1</span>,n,<span class="number">1</span>,j,<span class="number">1e9</span>);<span class="comment">//,printf(&quot;%d &quot;,j);put();</span></span><br><span class="line">		dp[i]=<span class="built_in">Query</span>(<span class="number">1</span>,n,<span class="number">1</span>,qmax[i]+<span class="number">1</span>,i)+<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,dp[n]);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>线性做法：</p>
<p>待补</p>
<h3 id="T3"><a href="#T3" class="headerlink" title="T3"></a>T3</h3><p>原题 CF335F</p>
<p>一个物品分为三种状态，全款付，买一送一那个买的，还有白嫖的。</p>
<p>有一种很naive的做法就是能白嫖就白嫖，但是这样显然是错的。</p>
<p>最小化权值就是最大化白嫖的费用。</p>
<p>考虑反悔贪心。建小根堆。存储白嫖的费用。建小根堆的原因是弹出最小的保留最大，从而最大化权值。</p>
<p>先将从大到小排序。当前要决策的是 $c$ 。</p>
<p>一种情况是与全款付的一起，变为白嫖的。</p>
<p>另一种情况，是将堆顶弹出，弹出的设为 $k$。</p>
<ul>
<li><p>如果 $c&gt;k$ ，直接换</p>
</li>
<li><p>否则有两种情况</p>
</li>
<li><ol>
<li>$2*c&gt;k$ 那么买 $k$ ，然后一个替上原来的位置，一个当买 $k$ 送的。放入 $2c-k$</li>
<li>再把 $k$ 放进去</li>
</ol>
<p>如果两个同时选，就是两个 $c$ 被另外的给送的。</p>
</li>
</ul>
<p>细节有点多。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 500005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> put() putchar(<span class="string">&#x27;\n&#x27;</span>)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(<span class="type">int</span> &amp;x)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> f=<span class="number">1</span>;x=<span class="number">0</span>;<span class="type">char</span> c=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span> (c&lt;<span class="string">&#x27;0&#x27;</span>||c&gt;<span class="string">&#x27;9&#x27;</span>) &#123;<span class="keyword">if</span> (c==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">-1</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">while</span> (c&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;c&lt;=<span class="string">&#x27;9&#x27;</span>) &#123;x=x*<span class="number">10</span>+c-<span class="string">&#x27;0&#x27;</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> a[maxn],ans,n,b[maxn],c[maxn],tot;</span><br><span class="line"><span class="type">int</span> rt[maxn],num;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span> </span>&#123;<span class="keyword">return</span> x&gt;y;&#125;</span><br><span class="line">priority_queue&lt;<span class="type">int</span>,vector&lt;<span class="type">int</span>&gt;,greater&lt;<span class="type">int</span>&gt; &gt;q;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> i,sum=<span class="number">0</span>,j;</span><br><span class="line">	<span class="built_in">read</span>(n);</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">read</span>(a[i]),ans+=a[i];</span><br><span class="line">	<span class="built_in">sort</span>(a+<span class="number">1</span>,a+<span class="number">1</span>+n);</span><br><span class="line">	<span class="built_in">reverse</span>(a+<span class="number">1</span>,a+<span class="number">1</span>+n);</span><br><span class="line">	b[tot=<span class="number">1</span>]=a[<span class="number">1</span>],c[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">2</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (a[i]!=a[i<span class="number">-1</span>]) b[++tot]=a[i],c[tot]++;</span><br><span class="line">		<span class="keyword">else</span> c[tot]++;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">//	for (i=1;i&lt;=tot;i++) printf(&quot;%lld %lld %lld\n&quot;,i,b[i],c[i]);</span></span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=tot;i++) &#123;</span><br><span class="line">		num=<span class="number">0</span>;</span><br><span class="line">		<span class="type">int</span> tmp=<span class="built_in">min</span>(sum-(<span class="type">int</span>)q.<span class="built_in">size</span>()*<span class="number">2</span>,c[i]),rest=<span class="built_in">min</span>(sum-tmp,c[i]-tmp);</span><br><span class="line">		<span class="keyword">for</span> (j=<span class="number">1</span>;j&lt;=tmp;j++) rt[++num]=b[i];</span><br><span class="line">		<span class="keyword">for</span> (j=<span class="number">1</span>;j&lt;=rest;j+=<span class="number">2</span>) &#123;</span><br><span class="line">			<span class="type">int</span> x=q.<span class="built_in">top</span>();q.<span class="built_in">pop</span>();</span><br><span class="line">			<span class="keyword">if</span> (b[i]&gt;x) &#123;</span><br><span class="line">				rt[++num]=b[i];</span><br><span class="line">				<span class="keyword">if</span> (j&lt;rest) rt[++num]=b[i];</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				rt[++num]=x;</span><br><span class="line">				<span class="keyword">if</span> (j&lt;rest&amp;&amp;b[i]*<span class="number">2</span>&gt;=x) rt[++num]=b[i]*<span class="number">2</span>-x;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (j=<span class="number">1</span>;j&lt;=num;j++) q.<span class="built_in">push</span>(rt[j]);</span><br><span class="line">		sum+=c[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) ans-=q.<span class="built_in">top</span>(),q.<span class="built_in">pop</span>();</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,ans); </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="T4"><a href="#T4" class="headerlink" title="T4"></a>T4</h3><p>Peaks</p>
<p>数据错了，我内存也开小了，乐。</p>
<p>Kruskal重构树+可持久化线段树。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 200005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> put() putchar(<span class="string">&#x27;\n&#x27;</span>)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(<span class="type">int</span> &amp;x)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> f=<span class="number">1</span>;x=<span class="number">0</span>;<span class="type">char</span> c=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span> (c&lt;<span class="string">&#x27;0&#x27;</span>||c&gt;<span class="string">&#x27;9&#x27;</span>) &#123;<span class="keyword">if</span> (c==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">-1</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">while</span> (c&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;c&lt;=<span class="string">&#x27;9&#x27;</span>) &#123;x=x*<span class="number">10</span>+c-<span class="string">&#x27;0&#x27;</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,m,q;</span><br><span class="line"><span class="type">int</span> h[maxn];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">yyy</span>&#123;<span class="type">int</span> x,y,z;&#125;e[<span class="number">1000005</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">cmp</span><span class="params">(yyy x,yyy y)</span></span>&#123;<span class="keyword">return</span> x.z&lt;y.z;&#125;</span><br><span class="line"><span class="type">int</span> father[maxn],w[maxn],fa[maxn][<span class="number">21</span>],deep[maxn],lg[maxn];</span><br><span class="line"><span class="type">int</span> to[maxn][<span class="number">2</span>],root[maxn],times,ql[maxn],qr[maxn],id[maxn];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">getfa</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;<span class="keyword">return</span> x==father[x]?x:father[x]=<span class="built_in">getfa</span>(father[x]);&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> pre)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!x) <span class="keyword">return</span> ;</span><br><span class="line">	ql[x]=++times;id[times]=x;</span><br><span class="line">	<span class="type">int</span> i;deep[x]=deep[pre]+<span class="number">1</span>;fa[x][<span class="number">0</span>]=pre;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=lg[deep[x]];i++) fa[x][i]=fa[fa[x][i<span class="number">-1</span>]][i<span class="number">-1</span>];</span><br><span class="line">	<span class="built_in">dfs</span>(to[x][<span class="number">0</span>],x);<span class="built_in">dfs</span>(to[x][<span class="number">1</span>],x);</span><br><span class="line">	qr[x]=times;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> base=<span class="number">1e9</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;<span class="type">int</span> ls,rs,size;&#125;f[maxn*<span class="number">50</span>];</span><br><span class="line"><span class="type">int</span> fnum;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">Update</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> pre,<span class="type">int</span> head,<span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> rt;</span><br><span class="line">	f[rt=++fnum]=f[pre];f[rt].size++;</span><br><span class="line">	<span class="keyword">if</span> (l==r) <span class="keyword">return</span> rt;</span><br><span class="line">	<span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span> (head&lt;=mid) f[rt].ls=<span class="built_in">Update</span>(l,mid,f[rt].ls,head,k);</span><br><span class="line">	<span class="keyword">else</span> f[rt].rs=<span class="built_in">Update</span>(mid+<span class="number">1</span>,r,f[rt].rs,head,k);</span><br><span class="line">	<span class="keyword">return</span> rt; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">Query</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> rt1,<span class="type">int</span> rt2,<span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (l==r) <span class="keyword">return</span> l;</span><br><span class="line">	<span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>,s=f[f[rt2].rs].size-f[f[rt1].rs].size;</span><br><span class="line">	<span class="keyword">if</span> (k&lt;=s) <span class="keyword">return</span> <span class="built_in">Query</span>(mid+<span class="number">1</span>,r,f[rt1].rs,f[rt2].rs,k);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">Query</span>(l,mid,f[rt1].ls,f[rt2].ls,k-s); </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> i;<span class="type">int</span> cnt=n;</span><br><span class="line">	<span class="built_in">sort</span>(e+<span class="number">1</span>,e+<span class="number">1</span>+m,cmp);</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n*<span class="number">2</span>;i++) father[i]=i;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">2</span>;i&lt;=n*<span class="number">2</span>;i++) lg[i]=lg[i/<span class="number">2</span>]+<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=m;i++) &#123;</span><br><span class="line">		<span class="type">int</span> fx=<span class="built_in">getfa</span>(e[i].x),fy=<span class="built_in">getfa</span>(e[i].y);</span><br><span class="line">		<span class="keyword">if</span> (fx^fy) &#123;</span><br><span class="line">			w[++cnt]=e[i].z;</span><br><span class="line">			to[cnt][<span class="number">0</span>]=fx;to[cnt][<span class="number">1</span>]=fy;</span><br><span class="line">			father[fx]=father[fy]=cnt;</span><br><span class="line">			<span class="comment">//printf(&quot;%d %d %d  %d\n&quot;,fx,fy,cnt,e[i].z);</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">//	printf(&quot;%d\n&quot;,cnt);</span></span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=cnt;i++) <span class="keyword">if</span> (father[i]==i )<span class="built_in">dfs</span>(i,<span class="number">0</span>);</span><br><span class="line">	root[<span class="number">0</span>]=fnum=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=cnt;i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (id[i]&lt;=n) root[i]=<span class="built_in">Update</span>(<span class="number">1</span>,base,root[i<span class="number">-1</span>],h[id[i]],<span class="number">1</span>);</span><br><span class="line">		<span class="keyword">else</span> root[i]=root[i<span class="number">-1</span>];</span><br><span class="line">	<span class="comment">//	printf(&quot;%d %d %d [%d,%d]\n&quot;,f[root[i]].size,id[i],h[id[i]],ql[id[i]],qr[id[i]]);</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;mountain.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;mountain2.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout);</span><br><span class="line">	<span class="type">int</span> las=<span class="number">0</span>,i,j,x,y,z;</span><br><span class="line">	<span class="built_in">read</span>(n);<span class="built_in">read</span>(m);<span class="built_in">read</span>(q);</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">read</span>(h[i]);</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=m;i++) <span class="built_in">read</span>(e[i].x),<span class="built_in">read</span>(e[i].y),<span class="built_in">read</span>(e[i].z);</span><br><span class="line">	<span class="built_in">init</span>();</span><br><span class="line"><span class="comment">//	printf(&quot;%d %d %d\n&quot;,w[14],fa[1][1],fa[1][2]);</span></span><br><span class="line">	<span class="keyword">while</span> (q--) &#123;</span><br><span class="line">		<span class="built_in">read</span>(x);<span class="built_in">read</span>(y);<span class="built_in">read</span>(z);</span><br><span class="line">		<span class="keyword">if</span> (las&gt;<span class="number">0</span>) x^=las,y^=las,z^=las;</span><br><span class="line">	<span class="comment">//	printf(&quot;111 %d %d %d &quot;,x,y,z);</span></span><br><span class="line">		<span class="keyword">for</span> (i=<span class="number">20</span>;i&gt;=<span class="number">0</span>;i--) <span class="keyword">if</span> (fa[x][i]&amp;&amp;w[fa[x][i]]&lt;=y) x=fa[x][i];</span><br><span class="line">	<span class="comment">//	printf(&quot;%d %d\n&quot;,x,f[root[qr[x]]].size-f[root[ql[x]-1]].size);</span></span><br><span class="line">		<span class="keyword">if</span> (f[root[qr[x]]].size-f[root[ql[x]<span class="number">-1</span>]].size&lt;z) las=<span class="number">-1</span>;</span><br><span class="line">		<span class="keyword">else</span> las=<span class="built_in">Query</span>(<span class="number">1</span>,base,root[ql[x]<span class="number">-1</span>],root[qr[x]],z);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,las); </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>NOIP模拟赛</tag>
        <tag>bzoj</tag>
        <tag>反悔贪心</tag>
        <tag>Kruskal重构树</tag>
      </tags>
  </entry>
  <entry>
    <title>NOIP2022模拟赛2 3</title>
    <url>/2022/07/06/NOIP2022%E6%A8%A1%E6%8B%9F%E8%B5%9B2-3/</url>
    <content><![CDATA[<p>T2 CE了&#x2F;dk</p>
<h2 id="T1"><a href="#T1" class="headerlink" title="T1"></a>T1</h2><p>如果最大的那根没有超过全部的一半，那么一定有方法使全部烧完。</p>
<p>否则输出总长度减去最大。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 100005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> put() putchar(<span class="string">&#x27;\n&#x27;</span>)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(<span class="type">int</span> &amp;x)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> f=<span class="number">1</span>;x=<span class="number">0</span>;<span class="type">char</span> c=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span> (c&lt;<span class="string">&#x27;0&#x27;</span>||c&gt;<span class="string">&#x27;9&#x27;</span>) &#123;<span class="keyword">if</span> (c==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">-1</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">while</span> (c&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;c&lt;=<span class="string">&#x27;9&#x27;</span>) &#123;x=x*<span class="number">10</span>+c-<span class="string">&#x27;0&#x27;</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,a[maxn];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">solve</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> i,sum=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">read</span>(n);</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">read</span>(a[i]),sum+=a[i];</span><br><span class="line">	<span class="built_in">sort</span>(a+<span class="number">1</span>,a+<span class="number">1</span>+n);</span><br><span class="line">	<span class="keyword">if</span> (sum-a[n]&lt;a[n]) <span class="built_in">printf</span>(<span class="string">&quot;%lld.0\n&quot;</span>,sum-a[n]);</span><br><span class="line">	<span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%.1lf\n&quot;</span>,<span class="number">1.0</span>*sum/<span class="number">2</span>); </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;dan.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;dan.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout);</span><br><span class="line">	<span class="type">int</span> T;</span><br><span class="line">	<span class="built_in">read</span>(T);</span><br><span class="line">	<span class="keyword">while</span> (T--) <span class="built_in">solve</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="T2"><a href="#T2" class="headerlink" title="T2"></a>T2</h2><p>单调队列优化dp</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 10005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> put() putchar(<span class="string">&#x27;\n&#x27;</span>)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(<span class="type">int</span> &amp;x)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> f=<span class="number">1</span>;x=<span class="number">0</span>;<span class="type">char</span> c=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span> (c&lt;<span class="string">&#x27;0&#x27;</span>||c&gt;<span class="string">&#x27;9&#x27;</span>) &#123;<span class="keyword">if</span> (c==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">-1</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">while</span> (c&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;c&lt;=<span class="string">&#x27;9&#x27;</span>) &#123;x=x*<span class="number">10</span>+c-<span class="string">&#x27;0&#x27;</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,m,f[<span class="number">2</span>][maxn];<span class="comment">//等下压缩</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">yyy</span>&#123;</span><br><span class="line">	<span class="type">int</span> x,y,w;</span><br><span class="line">	<span class="built_in">yyy</span>(<span class="type">int</span> a=<span class="number">0</span>,<span class="type">int</span> b=<span class="number">0</span>,<span class="type">int</span> c=<span class="number">0</span>) &#123;x=a;y=b;w=c;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">cmp</span><span class="params">(yyy x,yyy y)</span> </span>&#123;<span class="keyword">return</span> x.y&lt;y.y;&#125;</span><br><span class="line">vector&lt;yyy&gt;h[maxn];</span><br><span class="line"><span class="type">int</span> delta,num,ans;</span><br><span class="line"><span class="type">int</span> q[maxn],head,tail,g[maxn];</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line"><span class="comment">//	freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);</span></span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;kill.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;kill.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout);</span><br><span class="line">	<span class="type">int</span> i,j,x,y,z;</span><br><span class="line">	<span class="built_in">read</span>(n);<span class="built_in">read</span>(m);<span class="built_in">read</span>(delta);<span class="built_in">read</span>(num);<span class="comment">//delta=min(delta,n);</span></span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=num;i++) &#123;</span><br><span class="line">		<span class="built_in">read</span>(x);<span class="built_in">read</span>(y);<span class="built_in">read</span>(z);</span><br><span class="line">		x++;y++;</span><br><span class="line">		h[y].<span class="built_in">push_back</span>(<span class="built_in">yyy</span>(x,y,z));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=m;i++) &#123;</span><br><span class="line">		<span class="type">int</span> tmp=i&amp;<span class="number">1</span>;</span><br><span class="line">		<span class="built_in">memset</span>(f[tmp],<span class="number">-0x3f</span>,<span class="built_in">sizeof</span>(f[tmp]));</span><br><span class="line">		<span class="built_in">memset</span>(g,<span class="number">0</span>,<span class="built_in">sizeof</span>(g));</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> tmp:h[i]) g[tmp.x]=tmp.w;</span><br><span class="line">		head=<span class="number">1</span>;tail=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (j=<span class="number">1</span>;j&lt;=delta;j++) &#123;</span><br><span class="line">			<span class="keyword">while</span> (head&lt;=tail&amp;&amp;f[tmp^<span class="number">1</span>][q[tail]]&lt;=f[tmp^<span class="number">1</span>][j]) tail--;</span><br><span class="line">			q[++tail]=j;</span><br><span class="line">		&#125; </span><br><span class="line">	<span class="comment">//	printf(&quot;case %d \n&quot;,i);for (j=1;j&lt;=m;j++) printf(&quot;%d &quot;,g[j]);put();</span></span><br><span class="line">		<span class="keyword">for</span> (j=<span class="number">1</span>;j&lt;=n;j++) &#123;</span><br><span class="line">			<span class="keyword">while</span> (head&lt;=tail&amp;&amp;q[head]+delta&lt;j) head++;</span><br><span class="line">			<span class="keyword">if</span> (j+delta&lt;=n) &#123;</span><br><span class="line">				<span class="keyword">while</span> (head&lt;=tail&amp;&amp;f[tmp^<span class="number">1</span>][q[tail]]&lt;=f[tmp^<span class="number">1</span>][j+delta]) tail--;</span><br><span class="line">				q[++tail]=j+delta;</span><br><span class="line">			&#125;</span><br><span class="line">			f[tmp][j]=f[tmp^<span class="number">1</span>][q[head]]+g[j];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (j=<span class="number">1</span>;j&lt;=n;j++) ans=<span class="built_in">max</span>(ans,f[m&amp;<span class="number">1</span>][j]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="T3"><a href="#T3" class="headerlink" title="T3"></a>T3</h2><p>dsu on tree</p>
<p>我用的是并查集，复杂度 $O(n\log^2n)$</p>
<p>但是可以用双向链表，复杂度 $O(n\log n)$</p>
<p>ZJ老师似乎有线性的做法</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 200005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> put() putchar(<span class="string">&#x27;\n&#x27;</span>)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(<span class="type">int</span> &amp;x)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> f=<span class="number">1</span>;x=<span class="number">0</span>;<span class="type">char</span> c=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span> (c&lt;<span class="string">&#x27;0&#x27;</span>||c&gt;<span class="string">&#x27;9&#x27;</span>) &#123;<span class="keyword">if</span> (c==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">-1</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">while</span> (c&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;c&lt;=<span class="string">&#x27;9&#x27;</span>) &#123;x=x*<span class="number">10</span>+c-<span class="string">&#x27;0&#x27;</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;to[maxn];</span><br><span class="line"><span class="type">int</span> size[maxn],w[maxn],num[maxn],son[maxn];</span><br><span class="line"><span class="type">int</span> l[maxn],r[maxn],p[maxn],_p[maxn],times,id[maxn];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">	size[x]=<span class="number">1</span>;l[x]=++times;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> y:to[x]) &#123;</span><br><span class="line">		<span class="built_in">dfs</span>(y);</span><br><span class="line">		size[x]+=size[y];</span><br><span class="line">		<span class="keyword">if</span> (size[son[x]]&lt;size[y]) son[x]=y;</span><br><span class="line">	&#125;</span><br><span class="line">	r[x]=times;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> fa[maxn],fasize[maxn],sum,ans,vis[maxn],TOT;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">getfa</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;<span class="keyword">return</span> x==fa[x]?x:fa[x]=<span class="built_in">getfa</span>(fa[x]);&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!vis[x]||!vis[y]) <span class="keyword">return</span> ;</span><br><span class="line">	<span class="type">int</span> fx=<span class="built_in">getfa</span>(x),fy=<span class="built_in">getfa</span>(y);</span><br><span class="line">	<span class="keyword">if</span> (fx^fy) &#123;</span><br><span class="line">		fa[fx]=fy;</span><br><span class="line">		sum+=-fasize[fx]*(fasize[fx]+<span class="number">1</span>)/<span class="number">2</span>-fasize[fy]*(fasize[fy]+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">		fasize[fy]+=fasize[fx];</span><br><span class="line">		sum+=(fasize[fy]+<span class="number">1</span>)*fasize[fy]/<span class="number">2</span>;</span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">clear</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> i,tmp;sum=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (i=l[x];i&lt;=r[x];i++) tmp=p[id[i]],fa[tmp]=tmp,fasize[tmp]=<span class="number">1</span>,vis[tmp]=<span class="number">0</span>;</span><br><span class="line"><span class="comment">//	TOT+=r[x]-l[x]+1;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">calc</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> L,<span class="type">int</span> R)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> tmp;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i=l[x];i&lt;=r[x];i++) &#123;</span><br><span class="line">		tmp=p[id[i]];vis[tmp]=<span class="number">1</span>;sum++;</span><br><span class="line">		<span class="keyword">if</span> (L&lt;=l[p[id[i]<span class="number">-1</span>]]&amp;&amp;l[p[id[i]<span class="number">-1</span>]]&lt;=R) <span class="built_in">merge</span>(tmp,p[id[i]<span class="number">-1</span>]);</span><br><span class="line">		<span class="keyword">if</span> (L&lt;=l[p[id[i]+<span class="number">1</span>]]&amp;&amp;l[p[id[i]+<span class="number">1</span>]]&lt;=R) <span class="built_in">merge</span>(tmp,p[id[i]+<span class="number">1</span>]);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">//	TOT+=r[x]-l[x]+1;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!son[x]) <span class="keyword">return</span> sum=num[x]=vis[x]=<span class="number">1</span>,<span class="built_in">void</span>();</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> y:to[x]) <span class="keyword">if</span> (y!=son[x]) <span class="built_in">solve</span>(y),<span class="built_in">clear</span>(y);</span><br><span class="line">	<span class="built_in">solve</span>(son[x]);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> y:to[x]) <span class="keyword">if</span> (y!=son[x]) <span class="built_in">calc</span>(y,l[x],r[x]);</span><br><span class="line">	vis[x]=<span class="number">1</span>;sum++;</span><br><span class="line">	<span class="keyword">if</span> (l[x]&lt;=l[p[_p[x]<span class="number">-1</span>]]&amp;&amp;l[p[_p[x]<span class="number">-1</span>]]&lt;=r[x]) <span class="built_in">merge</span>(x,p[_p[x]<span class="number">-1</span>]);</span><br><span class="line">	<span class="keyword">if</span> (l[x]&lt;=l[p[_p[x]+<span class="number">1</span>]]&amp;&amp;l[p[_p[x]+<span class="number">1</span>]]&lt;=r[x]) <span class="built_in">merge</span>(x,p[_p[x]+<span class="number">1</span>]);</span><br><span class="line">	num[x]=sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">getans</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!son[x]) <span class="keyword">return</span> ans+=w[x],<span class="built_in">void</span>();</span><br><span class="line">	<span class="type">int</span> tot=num[x];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> y:to[x]) <span class="built_in">getans</span>(y),tot-=num[y];ans+=w[x]*tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;lca.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;lca.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout);</span><br><span class="line">	<span class="type">int</span> i,x;</span><br><span class="line">	<span class="built_in">read</span>(n);</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">2</span>;i&lt;=n;i++) <span class="built_in">read</span>(x),to[x].<span class="built_in">push_back</span>(i);</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">read</span>(p[i]),_p[p[i]]=i;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">read</span>(w[i]);</span><br><span class="line">	<span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) id[l[i]]=_p[i];</span><br><span class="line"><span class="comment">//	for (i=1;i&lt;=n;i++) printf(&quot;%lld &quot;,son[i]);put();</span></span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) fasize[i]=<span class="number">1</span>,fa[i]=i;</span><br><span class="line">	<span class="built_in">solve</span>(<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">getans</span>(<span class="number">1</span>);</span><br><span class="line"><span class="comment">//	printf(&quot;TOT=%lld\n&quot;,TOT);</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="T4"><a href="#T4" class="headerlink" title="T4"></a>T4</h2><p>GSS5</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 100005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> put() putchar(<span class="string">&#x27;\n&#x27;</span>)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(<span class="type">int</span> &amp;x)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> f=<span class="number">1</span>;x=<span class="number">0</span>;<span class="type">char</span> c=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span> (c&lt;<span class="string">&#x27;0&#x27;</span>||c&gt;<span class="string">&#x27;9&#x27;</span>) &#123;<span class="keyword">if</span> (c==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">-1</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">while</span> (c&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;c&lt;=<span class="string">&#x27;9&#x27;</span>) &#123;x=x*<span class="number">10</span>+c-<span class="string">&#x27;0&#x27;</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf=<span class="number">1e10</span>;</span><br><span class="line"><span class="type">int</span> n,a[maxn],sum[maxn];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">yyy</span>&#123;</span><br><span class="line">	<span class="type">int</span> lazy,Max,Min,ans;</span><br><span class="line">	<span class="built_in">yyy</span>(<span class="type">int</span> a=-inf,<span class="type">int</span> b=inf,<span class="type">int</span> c=<span class="number">0</span>) &#123;Max=a,Min=b;ans=c;&#125;</span><br><span class="line">&#125;f[maxn&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Pushup</span><span class="params">(<span class="type">int</span> rt)</span> </span>&#123;</span><br><span class="line">	f[rt].Max=<span class="built_in">max</span>(f[rt&lt;&lt;<span class="number">1</span>].Max,f[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].Max);</span><br><span class="line">	f[rt].Min=<span class="built_in">min</span>(f[rt&lt;&lt;<span class="number">1</span>].Min,f[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].Min);</span><br><span class="line">	f[rt].ans=<span class="built_in">max</span>(f[rt&lt;&lt;<span class="number">1</span>].ans,<span class="built_in">max</span>(f[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].ans,f[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].Max-f[rt&lt;&lt;<span class="number">1</span>].Min));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Pushdown</span><span class="params">(<span class="type">int</span> rt)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (f[rt].lazy) &#123;</span><br><span class="line">		<span class="type">int</span> k=f[rt].lazy;</span><br><span class="line">		f[rt&lt;&lt;<span class="number">1</span>].Max+=k;f[rt&lt;&lt;<span class="number">1</span>].Min+=k;f[rt&lt;&lt;<span class="number">1</span>].lazy+=k;</span><br><span class="line">		f[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].Max+=k,f[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].Min+=k,f[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].lazy+=k;</span><br><span class="line">		f[rt].lazy=<span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Build</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> rt)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (l==r) &#123;f[rt].ans=<span class="number">0</span>;f[rt].Max=f[rt].Min=sum[l];<span class="keyword">return</span> ;&#125;</span><br><span class="line">	<span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;<span class="built_in">Build</span>(l,mid,rt&lt;&lt;<span class="number">1</span>);<span class="built_in">Build</span>(mid+<span class="number">1</span>,r,rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);<span class="built_in">Pushup</span>(rt);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Update</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> rt,<span class="type">int</span> head,<span class="type">int</span> tail,<span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (head&lt;=l&amp;&amp;r&lt;=tail) <span class="keyword">return</span> f[rt].lazy+=k,f[rt].Min+=k,f[rt].Max+=k,<span class="built_in">void</span>();</span><br><span class="line">	<span class="built_in">Pushdown</span>(rt);</span><br><span class="line">	<span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span> (head&lt;=mid) <span class="built_in">Update</span>(l,mid,rt&lt;&lt;<span class="number">1</span>,head,tail,k);</span><br><span class="line">	<span class="keyword">if</span> (tail&gt;mid)  <span class="built_in">Update</span>(mid+<span class="number">1</span>,r,rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,head,tail,k);</span><br><span class="line">	<span class="built_in">Pushup</span>(rt);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">Query1</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> rt,<span class="type">int</span> head,<span class="type">int</span> tail)</span></span>&#123;<span class="comment">//max</span></span><br><span class="line">	<span class="keyword">if</span> (head&lt;=l&amp;&amp;r&lt;=tail) <span class="keyword">return</span> f[rt].Max;</span><br><span class="line">	<span class="built_in">Pushdown</span>(rt);</span><br><span class="line">	<span class="type">int</span> tmp1=-inf,tmp2=-inf,mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span> (head&lt;=mid) tmp1=<span class="built_in">Query1</span>(l,mid,rt&lt;&lt;<span class="number">1</span>,head,tail);</span><br><span class="line">	<span class="keyword">if</span> (tail&gt;mid)  tmp2=<span class="built_in">Query1</span>(mid+<span class="number">1</span>,r,rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,head,tail);</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">max</span>(tmp1,tmp2);</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">Query2</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> rt,<span class="type">int</span> head,<span class="type">int</span> tail)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (head&lt;=l&amp;&amp;r&lt;=tail) <span class="keyword">return</span> f[rt].Min;</span><br><span class="line">	<span class="built_in">Pushdown</span>(rt);</span><br><span class="line">	<span class="type">int</span> tmp1=inf,tmp2=inf,mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span> (head&lt;=mid) tmp1=<span class="built_in">Query2</span>(l,mid,rt&lt;&lt;<span class="number">1</span>,head,tail);</span><br><span class="line">	<span class="keyword">if</span> (tail&gt;mid)  tmp2=<span class="built_in">Query2</span>(mid+<span class="number">1</span>,r,rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,head,tail);</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">min</span>(tmp1,tmp2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> yyy <span class="title">Query3</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> rt,<span class="type">int</span> head,<span class="type">int</span> tail)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (head&lt;=l&amp;&amp;r&lt;=tail) <span class="keyword">return</span> f[rt];</span><br><span class="line">	<span class="built_in">Pushdown</span>(rt);</span><br><span class="line">	<span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span> (head&lt;=mid&amp;&amp;tail&gt;mid) &#123;</span><br><span class="line">		yyy tmp1=<span class="built_in">Query3</span>(l,mid,rt&lt;&lt;<span class="number">1</span>,head,tail),tmp2=<span class="built_in">Query3</span>(mid+<span class="number">1</span>,r,rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,head,tail);</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">yyy</span>(<span class="built_in">max</span>(tmp1.Max,tmp2.Max),<span class="built_in">min</span>(tmp1.Min,tmp2.Min),<span class="built_in">max</span>(tmp1.ans,<span class="built_in">max</span>(tmp2.ans,tmp2.Max-tmp1.Min)));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (head&lt;=mid) <span class="keyword">return</span> <span class="built_in">Query3</span>(l,mid,rt&lt;&lt;<span class="number">1</span>,head,tail);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (tail&gt;mid) <span class="keyword">return</span> <span class="built_in">Query3</span>(mid+<span class="number">1</span>,r,rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,head,tail);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;sum.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;sum.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout);</span><br><span class="line">	<span class="type">int</span> n,T,i,x,y,l1,l2,r1,r2;<span class="type">char</span> ch;</span><br><span class="line">	<span class="built_in">read</span>(n);<span class="built_in">read</span>(T);</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">read</span>(a[i]),sum[i]+=sum[i<span class="number">-1</span>]+a[i];</span><br><span class="line">	<span class="built_in">Build</span>(<span class="number">0</span>,n,<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">while</span> (T--) &#123;</span><br><span class="line">		ch=<span class="built_in">getchar</span>();<span class="keyword">while</span> (ch!=<span class="string">&#x27;C&#x27;</span>&amp;&amp;ch!=<span class="string">&#x27;Q&#x27;</span>) ch=<span class="built_in">getchar</span>();</span><br><span class="line">		<span class="keyword">if</span> (ch==<span class="string">&#x27;C&#x27;</span>) <span class="built_in">read</span>(x),<span class="built_in">read</span>(y),<span class="built_in">Update</span>(<span class="number">0</span>,n,<span class="number">1</span>,x,n,y-a[x]),a[x]=y;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="built_in">read</span>(l1);<span class="built_in">read</span>(r1);<span class="built_in">read</span>(l2);<span class="built_in">read</span>(r2);</span><br><span class="line">			<span class="keyword">if</span> (l1&gt;r1) <span class="built_in">swap</span>(l1,r1);</span><br><span class="line">			<span class="keyword">if</span> (l2&gt;r2) <span class="built_in">swap</span>(l2,r2);</span><br><span class="line">			<span class="keyword">if</span> (l1&gt;l2) <span class="built_in">swap</span>(l1,l2),<span class="built_in">swap</span>(r1,r2);</span><br><span class="line">	<span class="comment">//		r1=min(r1,r2);</span></span><br><span class="line">			<span class="keyword">if</span> (r1&lt;=l2) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">Query1</span>(<span class="number">0</span>,n,<span class="number">1</span>,l2,r2)-<span class="built_in">Query2</span>(<span class="number">0</span>,n,<span class="number">1</span>,l1<span class="number">-1</span>,r1<span class="number">-1</span>));</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">				<span class="keyword">if</span> (r2&lt;r1) &#123;</span><br><span class="line">					ans=<span class="built_in">max</span>(<span class="built_in">Query1</span>(<span class="number">0</span>,n,<span class="number">1</span>,l2,r2)-<span class="built_in">Query2</span>(<span class="number">0</span>,n,<span class="number">1</span>,l1<span class="number">-1</span>,l2<span class="number">-1</span>),ans);</span><br><span class="line">					ans=<span class="built_in">max</span>(<span class="built_in">Query3</span>(<span class="number">0</span>,n,<span class="number">1</span>,l2<span class="number">-1</span>,r2).ans,ans);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> &#123;</span><br><span class="line">					ans=<span class="built_in">max</span>(<span class="built_in">Query1</span>(<span class="number">0</span>,n,<span class="number">1</span>,l2,r2)-<span class="built_in">Query2</span>(<span class="number">0</span>,n,<span class="number">1</span>,l1<span class="number">-1</span>,l2<span class="number">-1</span>),ans);</span><br><span class="line">					ans=<span class="built_in">max</span>(<span class="built_in">Query1</span>(<span class="number">0</span>,n,<span class="number">1</span>,r1,r2)-<span class="built_in">Query2</span>(<span class="number">0</span>,n,<span class="number">1</span>,l1<span class="number">-1</span>,r1<span class="number">-1</span>),ans);</span><br><span class="line">					ans=<span class="built_in">max</span>(<span class="built_in">Query3</span>(<span class="number">0</span>,n,<span class="number">1</span>,l2<span class="number">-1</span>,r1).ans,ans);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>NOIP模拟赛</tag>
        <tag>线段树</tag>
        <tag>树上启发式合并</tag>
      </tags>
  </entry>
  <entry>
    <title>NOIP2022模拟赛by Cqy1</title>
    <url>/2022/08/26/NOIP2022%E6%A8%A1%E6%8B%9F%E8%B5%9Bby-cqy1/</url>
    <content><![CDATA[<h3 id="T1"><a href="#T1" class="headerlink" title="T1"></a>T1</h3><p>询问一个字符串任意子串出现最多次数。</p>
<h4 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h4><p>诈骗，输出出现字母出现最多的。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> put() putchar(<span class="string">&#x27;\n&#x27;</span>)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(<span class="type">int</span> &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> f=<span class="number">1</span>;x=<span class="number">0</span>;<span class="type">char</span> c=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (c&lt;<span class="string">&#x27;0&#x27;</span>||c&gt;<span class="string">&#x27;9&#x27;</span>) &#123;<span class="keyword">if</span> (c==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">-1</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span> (c&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;c&lt;=<span class="string">&#x27;9&#x27;</span>) &#123;x=x*<span class="number">10</span>+c-<span class="string">&#x27;0&#x27;</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    x*=f;</span><br><span class="line">&#125;</span><br><span class="line">string s;</span><br><span class="line"><span class="type">int</span> t[<span class="number">305</span>];</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="comment">//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);</span></span><br><span class="line">	<span class="type">int</span> i,Max=<span class="number">0</span>;</span><br><span class="line">	cin&gt;&gt;s;<span class="type">int</span> n=s.<span class="built_in">size</span>();</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;n;i++) t[s[i]]++,Max=<span class="built_in">max</span>(Max,t[s[i]]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,Max);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="T2"><a href="#T2" class="headerlink" title="T2"></a>T2</h3><p>字典树。</p>
<p>找到链最长并且字典序最大的串在树上打上标记最后输出。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 50005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> put() putchar(<span class="string">&#x27;\n&#x27;</span>)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(<span class="type">int</span> &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> f=<span class="number">1</span>;x=<span class="number">0</span>;<span class="type">char</span> c=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (c&lt;<span class="string">&#x27;0&#x27;</span>||c&gt;<span class="string">&#x27;9&#x27;</span>) &#123;<span class="keyword">if</span> (c==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">-1</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span> (c&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;c&lt;=<span class="string">&#x27;9&#x27;</span>) &#123;x=x*<span class="number">10</span>+c-<span class="string">&#x27;0&#x27;</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> cnt=<span class="number">1</span>,n,root=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">yyy</span>&#123;</span><br><span class="line">	<span class="type">int</span> nex[<span class="number">26</span>],flag,v;</span><br><span class="line">&#125;a[maxn*<span class="number">20</span>];</span><br><span class="line"><span class="type">int</span> maxlen;string Maxs;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">insert</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> i,now=root,len=s.<span class="built_in">size</span>();</span><br><span class="line">	<span class="keyword">if</span> (maxlen&lt;len||(maxlen==len&amp;&amp;s&gt;Maxs)) maxlen=len,Maxs=s;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;len;i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!a[now].nex[s[i]-<span class="string">&#x27;a&#x27;</span>]) a[now].nex[s[i]-<span class="string">&#x27;a&#x27;</span>]=++cnt;</span><br><span class="line">		now=a[now].nex[s[i]-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	a[now].flag++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">update</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> i,now=root,len=s.<span class="built_in">size</span>();</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;len;i++) &#123;</span><br><span class="line">		now=a[now].nex[s[i]-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">		a[now].v++;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">char</span> ans[<span class="number">2000005</span>];<span class="type">int</span> tot;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> now)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (a[now].flag) ans[++tot]=<span class="string">&#x27;P&#x27;</span>;</span><br><span class="line">	<span class="type">int</span> tmp=<span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">25</span>;i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (a[now].nex[i]) &#123;</span><br><span class="line">			<span class="keyword">if</span> (a[a[now].nex[i]].v==<span class="number">1</span>) <span class="built_in">assert</span>(tmp==<span class="number">-1</span>),tmp=i;</span><br><span class="line">			<span class="keyword">else</span> ans[++tot]=(<span class="string">&#x27;a&#x27;</span>+i),<span class="built_in">solve</span>(a[now].nex[i]),ans[++tot]=<span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (tmp!=<span class="number">-1</span>) ans[++tot]=(<span class="string">&#x27;a&#x27;</span>+tmp),<span class="built_in">solve</span>(a[now].nex[tmp]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span>&#123;	<span class="type">int</span> i;</span><br><span class="line">	string s;</span><br><span class="line">	<span class="built_in">read</span>(n);</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		cin&gt;&gt;s,<span class="built_in">insert</span>(s);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">update</span>(Maxs);</span><br><span class="line">	<span class="built_in">solve</span>(root);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,tot);<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=tot;i++) <span class="built_in">putchar</span>(ans[i]),<span class="built_in">put</span>(); </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="T3"><a href="#T3" class="headerlink" title="T3"></a>T3</h3><p>CF1286E 线段树，KMP，待补</p>
<h3 id="T4"><a href="#T4" class="headerlink" title="T4"></a>T4</h3><p>SAM，补nm</p>
<p>2022.07.24</p>
]]></content>
      <tags>
        <tag>NOIP模拟赛</tag>
        <tag>线段树</tag>
        <tag>KMP</tag>
        <tag>border</tag>
      </tags>
  </entry>
  <entry>
    <title>NOIP2022模拟赛by Jtz1</title>
    <url>/2022/08/26/NOIP2022%E6%A8%A1%E6%8B%9F%E8%B5%9Bby-jtz1/</url>
    <content><![CDATA[<h3 id="T1"><a href="#T1" class="headerlink" title="T1"></a>T1</h3><p>CF1311D</p>
<p>枚举 $a$，$b$ 是 $a$ 的倍数，$c$ 是 $b$ 的倍数，复杂度 $O(n\ln ^2n)$</p>
<p>事实上，$c$ 可以通过 $b$ $O(1)$ 算出来。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> put() putchar(<span class="string">&#x27;\n&#x27;</span>)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(<span class="type">int</span> &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> f=<span class="number">1</span>;x=<span class="number">0</span>;<span class="type">char</span> c=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (c&lt;<span class="string">&#x27;0&#x27;</span>||c&gt;<span class="string">&#x27;9&#x27;</span>) &#123;<span class="keyword">if</span> (c==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">-1</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span> (c&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;c&lt;=<span class="string">&#x27;9&#x27;</span>) &#123;x=x*<span class="number">10</span>+c-<span class="string">&#x27;0&#x27;</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> A,B,C,ans=<span class="number">1e9</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> base=<span class="number">2e5</span>;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="comment">//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);</span></span><br><span class="line">	<span class="type">int</span> i,j;</span><br><span class="line">	<span class="built_in">read</span>(A);<span class="built_in">read</span>(B);<span class="built_in">read</span>(C);</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=base;i++)&#123;</span><br><span class="line">		<span class="type">int</span> sum=<span class="built_in">abs</span>(B-i);</span><br><span class="line">		<span class="type">int</span> sum1=<span class="number">1e9</span>,sum2=<span class="number">1e9</span>;</span><br><span class="line">		<span class="keyword">for</span> (j=<span class="number">1</span>;j*j&lt;=i;j++)</span><br><span class="line">			<span class="keyword">if</span> (i%j==<span class="number">0</span>) sum1=<span class="built_in">min</span>(sum1,<span class="built_in">min</span>(<span class="built_in">abs</span>(A-j),<span class="built_in">abs</span>(A-i/j)));</span><br><span class="line">		<span class="keyword">for</span> (j=i;j&lt;=base;j+=i) </span><br><span class="line">			sum2=<span class="built_in">min</span>(sum2,<span class="built_in">abs</span>(C-j));</span><br><span class="line">		ans=<span class="built_in">min</span>(ans,sum+sum1+sum2);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="T2"><a href="#T2" class="headerlink" title="T2"></a>T2</h3><p>CCC2011S5</p>
<p>线性dp，大力分类讨论</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 1000005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> put() putchar(<span class="string">&#x27;\n&#x27;</span>)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(<span class="type">int</span> &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> f=<span class="number">1</span>;x=<span class="number">0</span>;<span class="type">char</span> c=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (c&lt;<span class="string">&#x27;0&#x27;</span>||c&gt;<span class="string">&#x27;9&#x27;</span>) &#123;<span class="keyword">if</span> (c==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">-1</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span> (c&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;c&lt;=<span class="string">&#x27;9&#x27;</span>) &#123;x=x*<span class="number">10</span>+c-<span class="string">&#x27;0&#x27;</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,a[maxn],len[maxn],cnt;</span><br><span class="line"><span class="type">int</span> f[maxn],sum[maxn];</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> i,j,k,x;</span><br><span class="line">	<span class="built_in">memset</span>(f,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(f));</span><br><span class="line">	<span class="built_in">read</span>(n);</span><br><span class="line">	a[<span class="number">0</span>]=<span class="number">-1</span>;len[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="built_in">read</span>(x);</span><br><span class="line">		<span class="keyword">if</span> (x!=a[cnt]) a[++cnt]=x,len[cnt]=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">else</span> len[cnt]++;</span><br><span class="line">	&#125;</span><br><span class="line">	a[<span class="number">0</span>]=<span class="number">0</span>,len[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">	f[<span class="number">0</span>]=<span class="number">0</span>;<span class="keyword">if</span> (a[<span class="number">1</span>]==<span class="number">1</span>) f[<span class="number">1</span>]=<span class="number">4</span>-len[<span class="number">1</span>];</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=cnt;i++) sum[i]=sum[i<span class="number">-1</span>]+len[i];</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=cnt;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span> (a[i]==<span class="number">0</span>) &#123;f[i]=f[i<span class="number">-1</span>];<span class="keyword">continue</span>;&#125; </span><br><span class="line">		f[i]=f[i<span class="number">-2</span>]+<span class="number">4</span>-len[i];</span><br><span class="line">		<span class="keyword">if</span> (i&gt;=<span class="number">3</span>&amp;&amp;len[i]+len[i<span class="number">-1</span>]+len[i<span class="number">-2</span>]&gt;=<span class="number">4</span>&amp;&amp;len[i<span class="number">-1</span>]&lt;=<span class="number">7</span>-len[i]-len[i<span class="number">-2</span>]) f[i]=<span class="built_in">min</span>(f[i],f[i<span class="number">-3</span>]+len[i<span class="number">-1</span>]);</span><br><span class="line">		<span class="keyword">if</span> (i&gt;=<span class="number">3</span>&amp;&amp;sum[i]-sum[i<span class="number">-3</span>]==<span class="number">3</span>) f[i]=<span class="built_in">min</span>(f[i],f[i<span class="number">-3</span>]+<span class="number">2</span>);</span><br><span class="line">		<span class="keyword">if</span> (i&gt;=<span class="number">5</span>&amp;&amp;sum[i]-sum[i<span class="number">-3</span>]==<span class="number">3</span>&amp;&amp;len[i<span class="number">-4</span>]+len[i<span class="number">-3</span>]<span class="number">-1</span>&lt;=<span class="number">4</span>) f[i]=<span class="built_in">min</span>(f[i],f[i<span class="number">-5</span>]+len[i<span class="number">-1</span>]+len[i<span class="number">-3</span>]);</span><br><span class="line">		<span class="keyword">if</span> (i&gt;=<span class="number">5</span>&amp;&amp;sum[i<span class="number">-2</span>]-sum[i<span class="number">-5</span>]==<span class="number">3</span>&amp;&amp;len[i]+len[i<span class="number">-1</span>]<span class="number">-1</span>&lt;=<span class="number">4</span>) f[i]=<span class="built_in">min</span>(f[i],f[i<span class="number">-5</span>]+len[i<span class="number">-1</span>]+len[i<span class="number">-3</span>]);</span><br><span class="line">		<span class="keyword">if</span> (i&gt;=<span class="number">7</span>&amp;&amp;sum[i]-sum[i<span class="number">-7</span>]==<span class="number">7</span>) f[i]=<span class="built_in">min</span>(f[i],f[i<span class="number">-7</span>]+<span class="number">3</span>);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">//	for (i=1;i&lt;=cnt;i++) printf(&quot;%d &quot;,f[i]);put();</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,f[cnt]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="T3"><a href="#T3" class="headerlink" title="T3"></a>T3</h3><p>CF1407E</p>
<p>因为颜色只和 $(u,v)$ 中的 $u$ 有关。考虑倒着搜。</p>
<p>根据 bfs 的最优性，如果这条边被搜到而且还没有赋权值，那么赋为与 $c[u]$ 相反的颜色，停止当前搜索。否则继续搜。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 200005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> put() putchar(<span class="string">&#x27;\n&#x27;</span>)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(<span class="type">int</span> &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> f=<span class="number">1</span>;x=<span class="number">0</span>;<span class="type">char</span> c=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (c&lt;<span class="string">&#x27;0&#x27;</span>||c&gt;<span class="string">&#x27;9&#x27;</span>) &#123;<span class="keyword">if</span> (c==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">-1</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span> (c&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;c&lt;=<span class="string">&#x27;9&#x27;</span>) &#123;x=x*<span class="number">10</span>+c-<span class="string">&#x27;0&#x27;</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> ans,c[maxn],n,m;</span><br><span class="line"><span class="type">int</span> h[maxn],head=<span class="number">1</span>;</span><br><span class="line">queue&lt;<span class="type">int</span>&gt;q;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">yyy</span>&#123;</span><br><span class="line">	<span class="type">int</span> to,z,w;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">		to=y;z=h[x];h[x]=head;w=val;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;a[<span class="number">500005</span>];</span><br><span class="line"><span class="type">int</span> dis[maxn];</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="comment">//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);</span></span><br><span class="line">	<span class="type">int</span> i,x,y,z;</span><br><span class="line">	<span class="built_in">read</span>(n);<span class="built_in">read</span>(m);</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=m;i++) &#123;</span><br><span class="line">		<span class="built_in">read</span>(x),<span class="built_in">read</span>(y),<span class="built_in">read</span>(z);</span><br><span class="line">		a[++head].<span class="built_in">add</span>(y,x,z);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">memset</span>(dis,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(dis));</span><br><span class="line">	<span class="built_in">memset</span>(c,<span class="number">-1</span>,<span class="built_in">sizeof</span>(c));</span><br><span class="line">	q.<span class="built_in">push</span>(n);dis[n]=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">		x=q.<span class="built_in">front</span>();q.<span class="built_in">pop</span>();</span><br><span class="line">		<span class="keyword">for</span> (i=h[x];i;i=a[i].z)</span><br><span class="line">			<span class="keyword">if</span> (c[a[i].to]==<span class="number">-1</span>) c[a[i].to]=<span class="number">1</span>-a[i].w;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (c[a[i].to]==a[i].w&amp;&amp;dis[a[i].to]&gt;dis[x]+<span class="number">1</span>) q.<span class="built_in">push</span>(a[i].to),dis[a[i].to]=dis[x]+<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,dis[<span class="number">1</span>]&gt;n?<span class="number">-1</span>:dis[<span class="number">1</span>]);</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,c[i]==<span class="number">-1</span>?<span class="number">0</span>:c[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="T4"><a href="#T4" class="headerlink" title="T4"></a>T4</h3><p>屑 ds</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 200005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> put() putchar(<span class="string">&#x27;\n&#x27;</span>)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(<span class="type">int</span> &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> f=<span class="number">1</span>;x=<span class="number">0</span>;<span class="type">char</span> c=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (c&lt;<span class="string">&#x27;0&#x27;</span>||c&gt;<span class="string">&#x27;9&#x27;</span>) &#123;<span class="keyword">if</span> (c==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">-1</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span> (c&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;c&lt;=<span class="string">&#x27;9&#x27;</span>) &#123;x=x*<span class="number">10</span>+c-<span class="string">&#x27;0&#x27;</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> cnt,root;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">yyy</span>&#123;</span><br><span class="line">	<span class="type">int</span> lazy,ls,rs,size;</span><br><span class="line">&#125;a[maxn*<span class="number">20</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Pushup</span><span class="params">(<span class="type">int</span> k)</span> </span>&#123;a[k].size=a[a[k].ls].size+a[a[k].rs].size;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Pushdown</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (a[k].lazy==<span class="number">1</span>) &#123;</span><br><span class="line">		<span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span> (!a[k].ls) a[k].ls=++cnt;<span class="keyword">if</span> (!a[k].rs) a[k].rs=++cnt;</span><br><span class="line">		a[a[k].ls].lazy=a[a[k].rs].lazy=<span class="number">1</span>;</span><br><span class="line">		a[a[k].ls].size=mid-l+<span class="number">1</span>,a[a[k].rs].size=r-mid;</span><br><span class="line">		a[k].lazy=<span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (a[k].lazy==<span class="number">-1</span>) &#123;</span><br><span class="line">		<span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span> (!a[k].ls) a[k].ls=++cnt;<span class="keyword">if</span> (!a[k].rs) a[k].rs=++cnt;</span><br><span class="line">		a[a[k].ls].lazy=a[a[k].rs].lazy=<span class="number">-1</span>;</span><br><span class="line">		a[a[k].ls].size=<span class="number">0</span>,a[a[k].rs].size=<span class="number">0</span>;</span><br><span class="line">		a[k].lazy=<span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> &amp;k,<span class="type">int</span> head,<span class="type">int</span> tail)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!k) k=++cnt;</span><br><span class="line">	<span class="keyword">if</span> (head&lt;=l&amp;&amp;r&lt;=tail) <span class="keyword">return</span> a[k].size=r-l+<span class="number">1</span>,a[k].lazy=<span class="number">1</span>,<span class="built_in">void</span>();</span><br><span class="line">	<span class="built_in">Pushdown</span>(l,r,k);</span><br><span class="line">	<span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span> (head&lt;=mid) <span class="built_in">insert</span>(l,mid,a[k].ls,head,tail);</span><br><span class="line">	<span class="keyword">if</span> (tail&gt;mid)  <span class="built_in">insert</span>(mid+<span class="number">1</span>,r,a[k].rs,head,tail);</span><br><span class="line">	<span class="built_in">Pushup</span>(k);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">del</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> &amp;k,<span class="type">int</span> head,<span class="type">int</span> tail)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!k) k=++cnt;</span><br><span class="line">	<span class="keyword">if</span> (head&lt;=l&amp;&amp;r&lt;=tail) <span class="keyword">return</span> a[k].size=<span class="number">0</span>,a[k].lazy=<span class="number">-1</span>,<span class="built_in">void</span>();</span><br><span class="line">	<span class="built_in">Pushdown</span>(l,r,k);</span><br><span class="line">	<span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span> (head&lt;=mid) <span class="built_in">del</span>(l,mid,a[k].ls,head,tail);</span><br><span class="line">	<span class="keyword">if</span> (tail&gt;mid)  <span class="built_in">del</span>(mid+<span class="number">1</span>,r,a[k].rs,head,tail);</span><br><span class="line">	<span class="built_in">Pushup</span>(k);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">rk</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> &amp;k,<span class="type">int</span> head)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!k) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (l==r) <span class="keyword">return</span> a[k].size;</span><br><span class="line">	<span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;<span class="built_in">Pushdown</span>(l,r,k);</span><br><span class="line">	<span class="keyword">if</span> (head&lt;=mid) <span class="keyword">return</span> <span class="built_in">rk</span>(l,mid,a[k].ls,head);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> a[a[k].ls].size+<span class="built_in">rk</span>(mid+<span class="number">1</span>,r,a[k].rs,head);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> deep,<span class="type">int</span> &amp;k,<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!k) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (l==r) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;<span class="built_in">Pushdown</span>(l,r,k);</span><br><span class="line"><span class="comment">//	printf(&quot;query %d %d  %d %d %d ls=%d rs=%d\n&quot;,x,(x&gt;&gt;deep)&amp;1,l,r,a[k].ls,a[a[k].ls].size,a[a[k].rs].size);</span></span><br><span class="line">	<span class="keyword">if</span> ((x&gt;&gt;deep)&amp;<span class="number">1</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (a[a[k].ls].size) <span class="keyword">return</span> <span class="built_in">query</span>(l,mid,deep<span class="number">-1</span>,a[k].ls,x)+(<span class="number">1</span>&lt;&lt;deep);</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">query</span>(mid+<span class="number">1</span>,r,deep<span class="number">-1</span>,a[k].rs,x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (a[a[k].rs].size) <span class="keyword">return</span> <span class="built_in">query</span>(mid+<span class="number">1</span>,r,deep<span class="number">-1</span>,a[k].rs,x)+(<span class="number">1</span>&lt;&lt;deep);</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">query</span>(l,mid,deep<span class="number">-1</span>,a[k].ls,x);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxdeep=<span class="number">29</span>,MASK=(<span class="number">1</span>&lt;&lt;<span class="number">30</span>)<span class="number">-1</span>;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> T,op,x,l,r;</span><br><span class="line">	<span class="built_in">read</span>(T);</span><br><span class="line">	<span class="keyword">while</span> (T--) &#123;</span><br><span class="line">		<span class="built_in">read</span>(op);</span><br><span class="line">		<span class="keyword">if</span> (op==<span class="number">1</span>) <span class="built_in">read</span>(l),<span class="built_in">read</span>(r),<span class="built_in">insert</span>(<span class="number">0</span>,MASK,root,l,r);</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (op==<span class="number">2</span>) <span class="built_in">read</span>(l),<span class="built_in">read</span>(r),<span class="built_in">del</span>(<span class="number">0</span>,MASK,root,l,r);</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (op==<span class="number">3</span>) <span class="built_in">read</span>(x),<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">rk</span>(<span class="number">0</span>,MASK,root,x)-<span class="built_in">rk</span>(<span class="number">0</span>,MASK,root,x<span class="number">-1</span>));</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (op==<span class="number">4</span>) <span class="built_in">read</span>(x),<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,(x==<span class="number">0</span>?<span class="number">1</span>:<span class="built_in">rk</span>(<span class="number">0</span>,MASK,root,x<span class="number">-1</span>)+<span class="number">1</span>));</span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">read</span>(x),<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">query</span>(<span class="number">0</span>,MASK,maxdeep,root,x));</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>NOIP模拟赛</tag>
      </tags>
  </entry>
  <entry>
    <title>NOIP2022模拟赛by Yjc1</title>
    <url>/2022/09/01/NOIP2022%E6%A8%A1%E6%8B%9F%E8%B5%9Bby-yjc1/</url>
    <content><![CDATA[<h3 id="T1"><a href="#T1" class="headerlink" title="T1"></a>T1</h3><p>CF1311F </p>
<p>分类讨论二位偏序</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 200005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> put() putchar(<span class="string">&#x27;\n&#x27;</span>)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(<span class="type">int</span> &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> f=<span class="number">1</span>;x=<span class="number">0</span>;<span class="type">char</span> c=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (c&lt;<span class="string">&#x27;0&#x27;</span>||c&gt;<span class="string">&#x27;9&#x27;</span>) &#123;<span class="keyword">if</span> (c==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">-1</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span> (c&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;c&lt;=<span class="string">&#x27;9&#x27;</span>) &#123;x=x*<span class="number">10</span>+c-<span class="string">&#x27;0&#x27;</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,g[maxn],tot,ans;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">yyy</span>&#123;</span><br><span class="line">	<span class="type">int</span> x,v;</span><br><span class="line">&#125;a[maxn];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">cmp</span><span class="params">(yyy x,yyy y)</span> </span>&#123;<span class="keyword">return</span> x.x==y.x?x.v&lt;=y.v:x.x&lt;y.x;&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">BIT</span>&#123;</span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> lowbit(x)  ((x)&amp;(-x))</span></span><br><span class="line">	<span class="type">int</span> f[maxn];</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span> </span>&#123;<span class="keyword">for</span> (;x&lt;=n;x+=<span class="built_in">lowbit</span>(x)) f[x]+=y;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;<span class="type">int</span> sum=<span class="number">0</span>;<span class="keyword">for</span> (;x;x-=<span class="built_in">lowbit</span>(x)) sum+=f[x];<span class="keyword">return</span> sum;&#125;</span><br><span class="line">&#125;t1,t2;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="comment">//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);</span></span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="built_in">read</span>(n);</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">read</span>(a[i].x);</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">read</span>(a[i].v),g[++tot]=a[i].v;</span><br><span class="line">	<span class="built_in">sort</span>(g+<span class="number">1</span>,g+<span class="number">1</span>+tot);</span><br><span class="line">	tot=<span class="built_in">unique</span>(g+<span class="number">1</span>,g+<span class="number">1</span>+tot)-g<span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) a[i].v=<span class="built_in">lower_bound</span>(g+<span class="number">1</span>,g+<span class="number">1</span>+tot,a[i].v)-g;</span><br><span class="line">	<span class="built_in">sort</span>(a+<span class="number">1</span>,a+<span class="number">1</span>+n,cmp);</span><br><span class="line"><span class="comment">//	for (i=1;i&lt;=n;i++) printf(&quot;%lld %lld\n&quot;,a[i].x,a[i].v);</span></span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		ans+=a[i].x*t1.<span class="built_in">query</span>(a[i].v)+t2.<span class="built_in">query</span>(a[i].v);</span><br><span class="line">		t1.<span class="built_in">add</span>(a[i].v,<span class="number">1</span>),t2.<span class="built_in">add</span>(a[i].v,-a[i].x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="T2"><a href="#T2" class="headerlink" title="T2"></a>T2</h3><p>bzoj1489</p>
<p>两个条件，两个最长上升子序列，长度都为 $n&#x2F;2$，对于序列前 $i$ 个的两个子序列，一个以 $a_i$ 结尾，根据贪心另一个越小越好。</p>
<p>令 $f[i][j]$ 表示序列前 $i$ 个组成的两条子序列，一个是以 $a_i$ 结尾的长度为 $j$ 的子序列，另一个以 $f[i][j]$ 结尾。</p>
<p>考虑转移:</p>
<ul>
<li>$a_i$ 加到 $a_{i-1}$ 的后面，满足条件 $a_i&gt;a_{i-1}$ ，$f[i][j]&#x3D;\min(f[i][j],f[i-1][j-1])$。</li>
<li>$a_i$ 加到另一个子序列的后面，满足条件 $a_i&gt;f[i][i-j]$ ,$f[i][j]&#x3D;\min(f[i][j],a_{i-1})$</li>
</ul>
<p>判断 $f_{n,n&#x2F;2}$ 是否有值即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 2005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> put() putchar(<span class="string">&#x27;\n&#x27;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Tp template<span class="string">&lt;typename Ty&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Ts template<span class="string">&lt;typename Ty,typename... Ar&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(<span class="type">int</span> &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> f=<span class="number">1</span>;x=<span class="number">0</span>;<span class="type">char</span> c=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (c&lt;<span class="string">&#x27;0&#x27;</span>||c&gt;<span class="string">&#x27;9&#x27;</span>) &#123;<span class="keyword">if</span> (c==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">-1</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span> (c&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;c&lt;=<span class="string">&#x27;9&#x27;</span>) &#123;x=x*<span class="number">10</span>+c-<span class="string">&#x27;0&#x27;</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> Debug&#123;</span><br><span class="line">	Tp <span class="type">void</span> _debug(<span class="type">char</span>* f,Ty t)&#123;cerr&lt;&lt;f&lt;&lt;<span class="string">&#x27;=&#x27;</span>&lt;&lt;t&lt;&lt;endl;&#125;</span><br><span class="line">	Ts <span class="type">void</span> _debug(<span class="type">char</span>* f,Ty x,Ar... y)&#123;<span class="keyword">while</span>(*f!=<span class="string">&#x27;,&#x27;</span>) cerr&lt;&lt;*f++;cerr&lt;&lt;<span class="string">&#x27;=&#x27;</span>&lt;&lt;x&lt;&lt;<span class="string">&quot;,&quot;</span>;_debug(f+<span class="number">1</span>,y...);&#125;</span><br><span class="line">	Tp ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; os,vector&lt;Ty&gt;&amp; V)&#123;os&lt;&lt;<span class="string">&quot;[&quot;</span>;<span class="keyword">for</span>(<span class="keyword">auto</span>&amp; vv:V) os&lt;&lt;vv&lt;&lt;<span class="string">&quot;,&quot;</span>;os&lt;&lt;<span class="string">&quot;]&quot;</span>;<span class="keyword">return</span> os;&#125;</span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> gdb(...) _debug(#__VA_ARGS__,__VA_ARGS__)</span></span><br><span class="line">&#125;<span class="keyword">using</span> <span class="keyword">namespace</span> Debug;</span><br><span class="line"><span class="type">int</span> n,a[maxn],f[maxn][maxn];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">solve</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> i,j;</span><br><span class="line">	<span class="built_in">read</span>(n);</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">read</span>(a[i]);</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;=n;i++) <span class="keyword">for</span> (j=<span class="number">0</span>;j&lt;=n/<span class="number">2</span>;j++) f[i][j]=<span class="number">1e9</span>;</span><br><span class="line">	f[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">-1e9</span>;a[<span class="number">0</span>]=<span class="number">-1e9</span>;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (j=<span class="number">1</span>;j&lt;=<span class="built_in">min</span>(n/<span class="number">2</span>,i);j++)&#123;</span><br><span class="line">			<span class="keyword">if</span> (a[i]&gt;a[i<span class="number">-1</span>]) f[i][j]=<span class="built_in">min</span>(f[i][j],f[i<span class="number">-1</span>][j<span class="number">-1</span>]);</span><br><span class="line">			<span class="keyword">if</span> (a[i]&gt;f[i<span class="number">-1</span>][i-j]) f[i][j]=<span class="built_in">min</span>(f[i][j],a[i<span class="number">-1</span>]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (f[n][n/<span class="number">2</span>]&lt;<span class="number">1e8</span>) <span class="built_in">puts</span>(<span class="string">&quot;Suck!&quot;</span>);</span><br><span class="line">	<span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;YYyyds!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> T;</span><br><span class="line">	<span class="built_in">read</span>(T);</span><br><span class="line">	<span class="keyword">while</span> (T--) <span class="built_in">solve</span>(); </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="T3"><a href="#T3" class="headerlink" title="T3"></a>T3</h3><p>bzoj2221 cf765F</p>
<p>考虑 $i&lt;j,a_i&lt;a_j$ 且有贡献的点。</p>
<p>首先在找到在 $i$ 右边且第一个在区间 $[a_i+1,\infty)$ 的点，记为 $a_x$。</p>
<p>然后在 $x$ 右边第一个在区间 $[a_i+1,(a_x+a_i)&#x2F;2)$ 的点。显然这与在 $i$ 右边是等价的。所以可以用扫描线解决。</p>
<p>一直找找找，每次值域至少缩小一半，对 $a_i$ 有贡献的个数就是 $\log$ 的。</p>
<p>$i&lt;j,a_i&gt;a_j$ 同理。</p>
<p>查询的时候询问离线，树状数组维护即可。</p>
<p>复杂度 $O(n\log^2n)$，不需要用到随机的性质。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 100005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> put() putchar(<span class="string">&#x27;\n&#x27;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Tp template<span class="string">&lt;typename Ty&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Ts template<span class="string">&lt;typename Ty,typename... Ar&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(<span class="type">int</span> &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> f=<span class="number">1</span>;x=<span class="number">0</span>;<span class="type">char</span> c=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (c&lt;<span class="string">&#x27;0&#x27;</span>||c&gt;<span class="string">&#x27;9&#x27;</span>) &#123;<span class="keyword">if</span> (c==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">-1</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span> (c&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;c&lt;=<span class="string">&#x27;9&#x27;</span>) &#123;x=x*<span class="number">10</span>+c-<span class="string">&#x27;0&#x27;</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> Debug&#123;</span><br><span class="line">	Tp <span class="type">void</span> _debug(<span class="type">char</span>* f,Ty t)&#123;cerr&lt;&lt;f&lt;&lt;<span class="string">&#x27;=&#x27;</span>&lt;&lt;t&lt;&lt;endl;&#125;</span><br><span class="line">	Ts <span class="type">void</span> _debug(<span class="type">char</span>* f,Ty x,Ar... y)&#123;<span class="keyword">while</span>(*f!=<span class="string">&#x27;,&#x27;</span>) cerr&lt;&lt;*f++;cerr&lt;&lt;<span class="string">&#x27;=&#x27;</span>&lt;&lt;x&lt;&lt;<span class="string">&quot;,&quot;</span>;_debug(f+<span class="number">1</span>,y...);&#125;</span><br><span class="line">	Tp ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; os,vector&lt;Ty&gt;&amp; V)&#123;os&lt;&lt;<span class="string">&quot;[&quot;</span>;<span class="keyword">for</span>(<span class="keyword">auto</span>&amp; vv:V) os&lt;&lt;vv&lt;&lt;<span class="string">&quot;,&quot;</span>;os&lt;&lt;<span class="string">&quot;]&quot;</span>;<span class="keyword">return</span> os;&#125;</span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> gdb(...) _debug(#__VA_ARGS__,__VA_ARGS__)</span></span><br><span class="line">&#125;<span class="keyword">using</span> <span class="keyword">namespace</span> Debug;</span><br><span class="line"><span class="type">int</span> n,q,a[maxn],root;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf=<span class="number">2e9</span>,base=<span class="number">1e9</span>;</span><br><span class="line"><span class="keyword">namespace</span> Segment&#123;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">yyy</span>&#123;</span><br><span class="line">		<span class="type">int</span> ls,rs,Min;</span><br><span class="line">		<span class="built_in">yyy</span>(<span class="type">int</span> a=inf) &#123;Min=a;&#125;</span><br><span class="line">	&#125;f[maxn*<span class="number">50</span>];</span><br><span class="line">	<span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">clear</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=cnt;i++) f[i].ls=f[i].rs=<span class="number">0</span>,f[i].Min=inf;</span><br><span class="line">		cnt=<span class="number">0</span>;root=<span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Update</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> &amp;rt,<span class="type">int</span> head,<span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (!rt) rt=++cnt;f[rt].Min=<span class="built_in">min</span>(f[rt].Min,k);</span><br><span class="line">		<span class="keyword">if</span> (l==r) <span class="keyword">return</span> <span class="built_in">void</span>();</span><br><span class="line">		<span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span> (head&lt;=mid) <span class="built_in">Update</span>(l,mid,f[rt].ls,head,k);</span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">Update</span>(mid+<span class="number">1</span>,r,f[rt].rs,head,k);</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">Query</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> &amp;rt,<span class="type">int</span> head,<span class="type">int</span> tail)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (!rt) <span class="keyword">return</span> inf;</span><br><span class="line">		<span class="keyword">if</span> (head&lt;=l&amp;&amp;r&lt;=tail) <span class="keyword">return</span> f[rt].Min;</span><br><span class="line">		<span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>,tmp1=inf,tmp2=inf;</span><br><span class="line">		<span class="keyword">if</span> (head&lt;=mid) tmp1=<span class="built_in">Query</span>(l,mid,f[rt].ls,head,tail);</span><br><span class="line">		<span class="keyword">if</span> (tail&gt;mid)  tmp2=<span class="built_in">Query</span>(mid+<span class="number">1</span>,r,f[rt].rs,head,tail);</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">min</span>(tmp1,tmp2);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">BIT</span>&#123;</span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> lowbit(x) ((x)&amp;(-x))</span></span><br><span class="line">	<span class="type">int</span> f[maxn];</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">clear</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;<span class="built_in">memset</span>(f,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(f));&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span> </span>&#123;<span class="keyword">for</span> (;x&lt;=n;x+=<span class="built_in">lowbit</span>(x)) f[x]=<span class="built_in">min</span>(f[x],y);&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;<span class="type">int</span> ans=inf;<span class="keyword">for</span> (;x;x-=<span class="built_in">lowbit</span>(x)) ans=<span class="built_in">min</span>(ans,f[x]);<span class="keyword">return</span> ans;&#125;</span><br><span class="line">&#125;t;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;to[maxn];</span><br><span class="line">vector&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; &gt;h[maxn];</span><br><span class="line"><span class="type">int</span> ans[maxn];</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> i,tmp,l,r;</span><br><span class="line">	<span class="built_in">read</span>(n);<span class="built_in">read</span>(q);</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">read</span>(a[i]);</span><br><span class="line">	<span class="keyword">for</span> (i=n;i&gt;=<span class="number">1</span>;i--) &#123;</span><br><span class="line">		<span class="type">int</span> now=inf;</span><br><span class="line">		<span class="keyword">while</span> (a[i]+<span class="number">1</span>&lt;=now) &#123;</span><br><span class="line">			tmp=Segment::<span class="built_in">Query</span>(<span class="number">0</span>,base,root,a[i]+<span class="number">1</span>,now);</span><br><span class="line">			<span class="keyword">if</span> (tmp&gt;=inf) <span class="keyword">break</span>;</span><br><span class="line">			to[tmp].<span class="built_in">push_back</span>(i);</span><br><span class="line">			now=(a[i]+a[tmp])/<span class="number">2</span><span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		Segment::<span class="built_in">Update</span>(<span class="number">0</span>,base,root,a[i],i);</span><br><span class="line">	&#125;</span><br><span class="line">	Segment::<span class="built_in">clear</span>();</span><br><span class="line">	<span class="keyword">for</span> (i=n;i&gt;=<span class="number">1</span>;i--) &#123;</span><br><span class="line">		<span class="type">int</span> now=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span> (now&lt;=a[i]<span class="number">-1</span>) &#123;</span><br><span class="line">			tmp=Segment::<span class="built_in">Query</span>(<span class="number">0</span>,base,root,now,a[i]<span class="number">-1</span>);</span><br><span class="line">			<span class="keyword">if</span> (tmp&gt;=inf) <span class="keyword">break</span>;</span><br><span class="line">			to[tmp].<span class="built_in">push_back</span>(i);</span><br><span class="line">			now=(a[i]+a[tmp])/<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		Segment::<span class="built_in">Update</span>(<span class="number">0</span>,base,root,a[i],i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=q;i++) &#123;</span><br><span class="line">		<span class="built_in">read</span>(l);<span class="built_in">read</span>(r);</span><br><span class="line">		h[r].<span class="built_in">push_back</span>(<span class="built_in">make_pair</span>(l,i));</span><br><span class="line">	&#125;</span><br><span class="line">	t.<span class="built_in">clear</span>();</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> y:to[i]) t.<span class="built_in">update</span>(n-y+<span class="number">1</span>,<span class="built_in">abs</span>(a[i]-a[y]));</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> tmp:h[i]) &#123;</span><br><span class="line">			ans[tmp.second]=t.<span class="built_in">query</span>(n-tmp.first+<span class="number">1</span>);</span><br><span class="line">		&#125; </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=q;i++) <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans[i]);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="T4"><a href="#T4" class="headerlink" title="T4"></a>T4</h3><p>bzoj4400 [TJOI2012]桥</p>
<p>跑个 $1$ 为起点的最短路径树，对于点 $i$ ，在树上到最短路上最近的点 $L_i$。跑个 $n$ 为节点的最短路径树，在树上的最近的点为 $R_i$。</p>
<p>如果这条边 $(x,y,z)$ 有贡献，那么当且仅当删除 $[L_i,R_i]$ 中的一条边，可能更新为 $dis1_x+z+disn_y$。所以用线段树维护一下最小值。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 200005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> put() putchar(<span class="string">&#x27;\n&#x27;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Tp template<span class="string">&lt;typename Ty&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Ts template<span class="string">&lt;typename Ty,typename... Ar&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(<span class="type">int</span> &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> f=<span class="number">1</span>;x=<span class="number">0</span>;<span class="type">char</span> c=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (c&lt;<span class="string">&#x27;0&#x27;</span>||c&gt;<span class="string">&#x27;9&#x27;</span>) &#123;<span class="keyword">if</span> (c==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">-1</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span> (c&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;c&lt;=<span class="string">&#x27;9&#x27;</span>) &#123;x=x*<span class="number">10</span>+c-<span class="string">&#x27;0&#x27;</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> Debug&#123;</span><br><span class="line">	Tp <span class="type">void</span> _debug(<span class="type">char</span>* f,Ty t)&#123;cerr&lt;&lt;f&lt;&lt;<span class="string">&#x27;=&#x27;</span>&lt;&lt;t&lt;&lt;endl;&#125;</span><br><span class="line">	Ts <span class="type">void</span> _debug(<span class="type">char</span>* f,Ty x,Ar... y)&#123;<span class="keyword">while</span>(*f!=<span class="string">&#x27;,&#x27;</span>) cerr&lt;&lt;*f++;cerr&lt;&lt;<span class="string">&#x27;=&#x27;</span>&lt;&lt;x&lt;&lt;<span class="string">&quot;,&quot;</span>;_debug(f+<span class="number">1</span>,y...);&#125;</span><br><span class="line">	Tp ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; os,vector&lt;Ty&gt;&amp; V)&#123;os&lt;&lt;<span class="string">&quot;[&quot;</span>;<span class="keyword">for</span>(<span class="keyword">auto</span>&amp; vv:V) os&lt;&lt;vv&lt;&lt;<span class="string">&quot;,&quot;</span>;os&lt;&lt;<span class="string">&quot;]&quot;</span>;<span class="keyword">return</span> os;&#125;</span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> gdb(...) _debug(#__VA_ARGS__,__VA_ARGS__)</span></span><br><span class="line">&#125;<span class="keyword">using</span> <span class="keyword">namespace</span> Debug;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf=<span class="number">1e10</span>;</span><br><span class="line"><span class="type">int</span> head=<span class="number">1</span>,h[maxn];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">	<span class="type">int</span> to,z,w,flag;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">		to=y;z=h[x];h[x]=head;w=val;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;a[maxn*<span class="number">4</span>];</span><br><span class="line"><span class="type">int</span> vis[maxn],diss[maxn],dist[maxn],flag[maxn],pre[maxn];</span><br><span class="line"><span class="type">int</span> stac[maxn],tot,L[maxn],R[maxn],id[maxn];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (flag[x]) <span class="keyword">return</span> L[x]=x;</span><br><span class="line">	<span class="keyword">if</span> (L[x]) <span class="keyword">return</span> L[x];</span><br><span class="line">	<span class="keyword">return</span> L[x]=<span class="built_in">dfs1</span>(a[pre[x]^<span class="number">1</span>].to);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (flag[x]) <span class="keyword">return</span> R[x]=x;</span><br><span class="line">	<span class="keyword">if</span> (R[x]) <span class="keyword">return</span> R[x];</span><br><span class="line">	<span class="keyword">return</span> R[x]=<span class="built_in">dfs2</span>(a[pre[x]^<span class="number">1</span>].to);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> f[maxn&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Update</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> rt,<span class="type">int</span> head,<span class="type">int</span> tail,<span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (head&lt;=l&amp;&amp;r&lt;=tail) <span class="keyword">return</span> f[rt]=<span class="built_in">min</span>(f[rt],k),<span class="built_in">void</span>();</span><br><span class="line">	<span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span> (head&lt;=mid) <span class="built_in">Update</span>(l,mid,rt&lt;&lt;<span class="number">1</span>,head,tail,k);</span><br><span class="line">	<span class="keyword">if</span> (tail&gt;mid)  <span class="built_in">Update</span>(mid+<span class="number">1</span>,r,rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,head,tail,k);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">Query</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> rt,<span class="type">int</span> head)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (l==r) <span class="keyword">return</span> f[rt];</span><br><span class="line">	<span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>,tmp=inf;</span><br><span class="line">	<span class="keyword">if</span> (head&lt;=mid) tmp=<span class="built_in">Query</span>(l,mid,rt&lt;&lt;<span class="number">1</span>,head);</span><br><span class="line">	<span class="keyword">else</span> tmp=<span class="built_in">Query</span>(mid+<span class="number">1</span>,r,rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,head);</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">min</span>(tmp,f[rt]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> ans=<span class="number">0</span>,anss=<span class="number">0</span>;</span><br><span class="line">priority_queue&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; &gt;q;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line"><span class="comment">//	freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);</span></span><br><span class="line">	<span class="type">int</span> i,x,y,z,tmp;</span><br><span class="line">	<span class="built_in">read</span>(n);<span class="built_in">read</span>(m);</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=m;i++) &#123;</span><br><span class="line">		<span class="built_in">read</span>(x);<span class="built_in">read</span>(y);<span class="built_in">read</span>(z);</span><br><span class="line">		a[++head].<span class="built_in">add</span>(x,y,z);</span><br><span class="line">		a[++head].<span class="built_in">add</span>(y,x,z);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">memset</span>(f,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(f));</span><br><span class="line">	<span class="built_in">memset</span>(diss,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(diss));</span><br><span class="line">	<span class="built_in">memset</span>(dist,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(dist));</span><br><span class="line">	diss[<span class="number">1</span>]=<span class="number">0</span>;q.<span class="built_in">push</span>(&#123;<span class="number">0</span>,<span class="number">1</span>&#125;);</span><br><span class="line">	<span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">		x=q.<span class="built_in">top</span>().second;q.<span class="built_in">pop</span>();</span><br><span class="line">		<span class="keyword">if</span>(vis[x])<span class="keyword">continue</span>;vis[x]=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span> (i=h[x];i;i=a[i].z)</span><br><span class="line">			<span class="keyword">if</span> (diss[a[i].to]&gt;diss[x]+a[i].w) &#123;</span><br><span class="line">				pre[a[i].to]=i;</span><br><span class="line">				diss[a[i].to]=diss[x]+a[i].w;</span><br><span class="line">				q.<span class="built_in">push</span>(&#123;-diss[a[i].to],a[i].to&#125;);</span><br><span class="line">			&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> now=n;flag[n]=<span class="number">1</span>,stac[tot=<span class="number">1</span>]=n;</span><br><span class="line">	<span class="keyword">while</span> (pre[now]) &#123;</span><br><span class="line">		i=pre[now];</span><br><span class="line">		flag[a[i^<span class="number">1</span>].to]=<span class="number">1</span>;a[i^<span class="number">1</span>].flag=a[i].flag=<span class="number">1</span>;</span><br><span class="line">		stac[++tot]=a[i^<span class="number">1</span>].to,now=a[i^<span class="number">1</span>].to;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">reverse</span>(stac+<span class="number">1</span>,stac+<span class="number">1</span>+tot);</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=tot;i++) id[stac[i]]=i;</span><br><span class="line"><span class="comment">//	for (cerr&lt;&lt;tot&lt;&lt;endl,i=1;i&lt;=tot;i++) gdb(stac[i]);</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) L[i]=<span class="built_in">dfs1</span>(i);</span><br><span class="line">	dist[n]=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">memset</span>(pre,<span class="number">0</span>,<span class="built_in">sizeof</span>(pre));</span><br><span class="line">	<span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="built_in">sizeof</span>(vis));</span><br><span class="line">	<span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) q.<span class="built_in">pop</span>();</span><br><span class="line">	q.<span class="built_in">push</span>(&#123;<span class="number">0</span>,n&#125;);</span><br><span class="line">	<span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">		x=q.<span class="built_in">top</span>().second;q.<span class="built_in">pop</span>();</span><br><span class="line">		<span class="keyword">if</span> (vis[x]) <span class="keyword">continue</span>;</span><br><span class="line">		vis[x]=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span> (i=h[x];i;i=a[i].z)</span><br><span class="line">			<span class="keyword">if</span> ((a[i].flag&amp;&amp;pre[a[i].to]!=i&amp;&amp;dist[a[i].to]&gt;=dist[x]+a[i].w)||dist[a[i].to]&gt;dist[x]+a[i].w) &#123;</span><br><span class="line">				pre[a[i].to]=i;</span><br><span class="line">				dist[a[i].to]=dist[x]+a[i].w;</span><br><span class="line"><span class="comment">//				if (a[i].to==2) gdb(x,a[i].flag,a[i].to,dist[a[i].to]);</span></span><br><span class="line">				q.<span class="built_in">push</span>(&#123;-dist[a[i].to],a[i].to&#125;); </span><br><span class="line">			&#125;	</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) R[i]=<span class="built_in">dfs2</span>(i);</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">2</span>;i&lt;=head;i++) &#123;</span><br><span class="line">		x=a[i^<span class="number">1</span>].to,y=a[i].to,z=a[i].w;</span><br><span class="line">		<span class="keyword">if</span> (a[i].flag) <span class="keyword">continue</span>;</span><br><span class="line"><span class="comment">//		gdb(x,y,z,diss[x]+z+dist[y],id[L[x]],id[R[y]]);</span></span><br><span class="line">		<span class="keyword">if</span> (id[L[x]]&lt;id[R[y]]) <span class="built_in">Update</span>(<span class="number">1</span>,tot<span class="number">-1</span>,<span class="number">1</span>,id[L[x]],id[R[y]]<span class="number">-1</span>,diss[x]+z+dist[y]);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;tot;i++) &#123;</span><br><span class="line">		tmp=<span class="built_in">Query</span>(<span class="number">1</span>,tot<span class="number">-1</span>,<span class="number">1</span>,i); </span><br><span class="line"><span class="comment">//		gdb(i,tmp);</span></span><br><span class="line">		<span class="keyword">if</span> (tmp&gt;<span class="number">1e15</span>) <span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">if</span> (ans&lt;tmp) ans=tmp,anss=<span class="number">1</span>;<span class="keyword">else</span> <span class="keyword">if</span> (ans==tmp) anss++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (ans==diss[n]) <span class="built_in">printf</span>(<span class="string">&quot;%lld %lld\n&quot;</span>,diss[n],m);<span class="keyword">else</span> </span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld %lld\n&quot;</span>,ans,anss);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>线段树</tag>
        <tag>bzoj</tag>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title>NOIP2022模拟赛by Zyq1</title>
    <url>/2022/08/26/NOIP2022%E6%A8%A1%E6%8B%9F%E8%B5%9Bby-zyq1/</url>
    <content><![CDATA[<p>自己的模拟赛&#x2F;se</p>
<h3 id="T1"><a href="#T1" class="headerlink" title="T1"></a>T1</h3><p>CF1310A</p>
<p>考虑一种贪心，对于所有相同当前大小相同的数，除了权值最大的那个以为其余加一。</p>
<p>维护一个大根堆，以及大根堆里所有数的权值之和。加入权值相同的以后，弹出最大的。</p>
<h3 id="T2"><a href="#T2" class="headerlink" title="T2"></a>T2</h3><p>CF226C</p>
<p>常见结论，$\gcd(F_{a1},F_{a2},F_{a3},…,F_{an})&#x3D;F_{\gcd(a1,a2,a3…,an)}$</p>
<p>转化为求 ${\dfrac{r}{x}}-\dfrac{l-1}{x}\ge k$ 的 $x$ 的最大值，用整除分块就好了。</p>
<p>答案就是 $F_x$。</p>
<h3 id="T3"><a href="#T3" class="headerlink" title="T3"></a>T3</h3><p><a href="https://dmoj.ca/problem/dmopc21c5p6">https://dmoj.ca/problem/dmopc21c5p6</a></p>
<p>考虑用二分图搓暴力，<a href="http://wgyhm.cf/2022/06/29/%E4%BA%8C%E5%88%86%E5%9B%BE%E6%9C%80%E5%B0%8F%E5%AD%97%E5%85%B8%E5%BA%8F/">最小字典序</a>.</p>
<p>素数的分布类似于随机，我们发现前面的大多数都是对于一个区间 $[l,r]$，如果 $l+r$ 为质数，将 $[l,r]$ 填为 $r,r-1,r-2,…,l$。最后的一部分数不符合规律，我们可以对后面的进行暴力，暴力的复杂度是 $O(n^3)$ 的，大概设成 $300$ 左右肯定可以了。</p>
<p>证明不太会。&#x2F;kk</p>
<h3 id="T4"><a href="#T4" class="headerlink" title="T4"></a>T4</h3><p><a href="https://dmoj.ca/problem/dmopc21c8p5">https://dmoj.ca/problem/dmopc21c8p5</a></p>
<p>先不管多组询问。考虑只有一次询问。</p>
<h4 id="Step-1"><a href="#Step-1" class="headerlink" title="Step 1"></a>Step 1</h4><p>根据 prufer 序列，令每个点的度数为 $d_i$ 。</p>
<p>则题目转化为 $\sum d_i&#x3D;2N-2$，求 $\sum w_{di}$ 的最小值。</p>
<p>不妨设 $a_i&#x3D;d_i-1,0\le a_i\le K-1,b_i&#x3D;w_{i+1}-w_1$</p>
<p>这样可以看做容量为 $N-2$，有 $K-1$ 个物品，每个物品的体积是 $a_i$，价值是 $w_{a_i+1}-w_1&#x3D;b_{ai}$。必须装满，求最小价值。或者可以不管直接 dp。</p>
<p>$f_i&#x3D;\min f_{i-j}+b_j$</p>
<p>答案为 $N\times w_1+f_{n-2}$</p>
<p>这样做复杂度是 $O(NK)$ 的。</p>
<h4 id="Step-2"><a href="#Step-2" class="headerlink" title="Step 2"></a>Step 2</h4><p>考虑优化 $f_i&#x3D;\min f_{i-j}+b_j$</p>
<p>令 $j$ 满足 $\forall k,1\le k\le K-1,\dfrac{b_j}{j}\le \dfrac{b_k}{k}$</p>
<p>很容易想到对于一个充分大的 $N$ ，总是从状态 $N-j$ 转移过来。</p>
<p>事实上 $n\ge K(K-1)$ 即可。</p>
<blockquote>
<p>证明：</p>
<p>反证法。</p>
<p>假设对于任意的 $N\ge K(K-1)$ 从不使用物品 $j$ 。因为所有物品的体积小于等于 $K-1$，所以至少有 $k\ge K&gt;j$ 个可重物品 $u_1,u_2,u_3,…,u_k$ 转移到 $f_n$ 。</p>
<p>设这 $k$ 个可重物品的集合为 $S$。因为 $k&gt;j$ ，所以一定存在 $S$ 的子集满足其和是 $j$ 的倍数。（根据抽屉原理，$k+1$ 个前缀和模 $j$ 必有相同的）。我们可以用多个 $j$ 来替换这个子集，考虑到 $j$ 的定义，答案一定不劣。命题不成立。</p>
</blockquote>
<p>将 $\forall 1\le i\le K(K-1)$ 的 $f_i$ 暴力转移。</p>
<p>复杂度 $O(K^3)$</p>
<h4 id="Step-3"><a href="#Step-3" class="headerlink" title="Step 3"></a>Step 3</h4><p>考虑扩展上一步的结论。对于 $i$ ，能否只从几个最小的 $\dfrac{b_j}{j}$ 的 $j$ 中转移过来。</p>
<p>可以证明，在保证正确性的情况下，对于状态 $i$ 每次从前 $m$ 小的 $j$ 中转移过来。其中 $m&#x3D;\left\lceil\dfrac{2K^2}{i}\right\rceil-1$。</p>
<blockquote>
<p>证明：</p>
<ul>
<li><p>让 $P&#x3D;{j_1,j_2,…,j_m}$ 为前 $m$ 小的 $\dfrac{b_j}{j}$，$u_1,u_2,…,u_k$ 为转移到 $dp_i$ 的可重物品集 $S$。我们的核心思想是找到一个 $S$ 的非空子集可以被 $P$ 的一个子集线性表示出来。</p>
</li>
<li><p>Erdos and Graham (1972) 提出了一个定理：存在任意一个正整数序列满足 $p_1&lt;p_2&lt;…&lt;p_n,\gcd(p_1,p_2,…,p_n)&#x3D;1$ ， 对于大于 $\dfrac{2p_{n-1}p_{n}}{n}-p_n$ 的正整数都可以用 $p$ 线性表示出来。</p>
</li>
<li><p>扩展这个定理，存在任意一个正整数序列满足 $p_1&lt;p_2&lt;…&lt;p_n,g&#x3D;\gcd(p_1,p_2,…,p_n)\not&#x3D;1$ ， 对于大于 $\dfrac{2p_{n-1}p_{n}}{ng}-p_n$ 的 $g$ 的倍数的正整数都可以用 $p$ 线性表示出来。</p>
</li>
<li><p>考虑应用这个定理，令 $g&#x3D;\gcd(j_1,j_2,…,j_m)$ ，有 $g\le \dfrac{K-2}{m-1}$</p>
</li>
<li><p>现在我们需要找到 $S$ 的一个子集使得其和是 $g$ 的倍数并且把它用 $P$ 线性表示出来。一个不满足和为 $g$ 的倍数的最大序列和为 $(K-1)(g-1)$，相当于前 $g-1$ 个数放 $K-1$，有 $g$ 个余数不同的前缀和，后面任意前缀和都能找到相同的，所以一个满足和是 $g$ 的倍数的最大子集的和至少是 $i-(K-1)(g-1)$。考虑证明 $i-(K-1)(g-1)&gt;\dfrac{2j_{m-1}j_{m}}{mg}-j_m$ 即可。</p>
<p>$g\le \dfrac{K-1}{m-1}&lt;\dfrac{K}{\frac{2K^2}{i}}&#x3D;\dfrac{i}{2K}&lt;\dfrac{i}{K-1}\Longrightarrow\dfrac{i}{g}&gt;K-1$</p>
<p>$\Longrightarrow\dfrac{i(g-1)}{g}\ge (K-1)(g-1)\Longrightarrow i-\dfrac{i}{g}\ge(K-1)(g-1)$</p>
<p>$\Longrightarrow i-(K-1)(g-1)\ge \dfrac{i}{g}\ge \dfrac{2K^2}{mg}&gt;\dfrac{2j_(m-1)j_m}{mg}-p_j$</p>
</li>
</ul>
</blockquote>
<p>结合 Step2 ，根据调和级数，复杂度 $O(K^2\log K+q)$</p>
<h4 id="Step-2-5"><a href="#Step-2-5" class="headerlink" title="Step 2.5"></a>Step 2.5</h4><p>好像有一种做法是每次 $i$ 从 $\left\lfloor\dfrac{i-K}{2}\right\rfloor,\left\lfloor\dfrac{i-K+1}{2}\right\rfloor,\left\lfloor\dfrac{i-K+2}{2}\right\rfloor,…,\left\lceil\dfrac{i+K}{2}\right\rceil$</p>
<p>转移，复杂度是 $O(K^2\log N)$ 或者 $O(K^2\log^2N)$ 的。</p>
<p><del>因为我不会证明，所以说我开了多组询问把它卡掉了</del></p>
<p>我做的对吗！</p>
<h4 id="造数据时的感想"><a href="#造数据时的感想" class="headerlink" title="造数据时的感想"></a>造数据时的感想</h4><p>事实上这个上界是跑不满的，所以可能什么乱搞也过了我也管不了。</p>
<p>我是有原则的，我不会打包。(flag)</p>
<p>2022.07.25</p>
]]></content>
      <tags>
        <tag>构造</tag>
        <tag>贪心</tag>
        <tag>prufer序列</tag>
      </tags>
  </entry>
  <entry>
    <title>P2109 [NOI2007] 生成树计数</title>
    <url>/2023/08/30/P2109-NOI2007-%E7%94%9F%E6%88%90%E6%A0%91%E8%AE%A1%E6%95%B0/</url>
    <content><![CDATA[<h1 id="NOI2007-生成树计数"><a href="#NOI2007-生成树计数" class="headerlink" title="[NOI2007] 生成树计数"></a>[NOI2007] 生成树计数</h1><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p><a href="https://www.luogu.com.cn/problem/P2109">https://www.luogu.com.cn/problem/P2109</a></p>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>看到 $n$ 的范围，可以直接往矩阵乘法上想。</p>
<p>由于这张图的特殊性质，假设当前计数到第 $i$ 个点，前 $k$ 个点的联通状态为 $S$ 的方案数。</p>
<p>考虑计算可行且本质不同的方案数的个数，注意到联通状态 <code>11121</code> 和 <code>44434</code> 的本质是相同的（其中，同一种数字表示在同一个连通块中）。dfs 出不同状态的个数，$k&#x3D;5$ 时状态为 $52$ 个。</p>
<p>转移可以暴力转移。</p>
<p>初始状态的的计数可以枚举 $k(k+1)&#x2F;2$ 条边选或者不选的情况，情况比较少，计数的复杂度是 $O(2^{k(k+1)&#x2F;2}k^2)$ ，反正随便跑。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">65521</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">power</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y=mod<span class="number">-2</span>)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (y&lt;=<span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="type">int</span> sum=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (y) &#123;</span><br><span class="line">		<span class="keyword">if</span> (y&amp;<span class="number">1</span>) sum=sum*x%mod;</span><br><span class="line">		x=x*x%mod;y&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> k,n,base;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Mat</span> &#123;</span><br><span class="line">	<span class="type">int</span> a[<span class="number">55</span>][<span class="number">55</span>];</span><br><span class="line">	<span class="built_in">Mat</span> (<span class="type">void</span>) &#123;<span class="built_in">memset</span>(a,<span class="number">0</span>,<span class="built_in">sizeof</span>(a));&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">clear</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">		<span class="built_in">memset</span>(a,<span class="number">0</span>,<span class="built_in">sizeof</span>(a));</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;=base;i++) a[i][i]=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">		<span class="type">int</span> i,j;</span><br><span class="line">		<span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;=base;i++,<span class="built_in">put</span>()) <span class="keyword">for</span> (j=<span class="number">0</span>;j&lt;=base;j++) <span class="built_in">printf</span>(<span class="string">&quot;%lld &quot;</span>,a[i][j]);</span><br><span class="line">		<span class="built_in">put</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	Mat <span class="keyword">operator</span> *(<span class="type">const</span> Mat &amp;x) <span class="type">const</span> &#123;</span><br><span class="line">		Mat ans;</span><br><span class="line">		<span class="type">int</span> i,j,k;</span><br><span class="line">		<span class="keyword">for</span> (k=<span class="number">0</span>;k&lt;=base;k++) &#123;</span><br><span class="line">			<span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;=base;i++) &#123;</span><br><span class="line">				<span class="type">int</span> r=a[i][k];</span><br><span class="line">				<span class="keyword">for</span> (j=<span class="number">0</span>;j&lt;=base;j++)</span><br><span class="line">					ans.a[i][j]=(ans.a[i][j]+r*x.a[k][j])%mod;<span class="comment">//,gdb(i,j,k,r,x.a[k][j],ans.a[i][j]);</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> ans;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;tmp,Ans;</span><br><span class="line"><span class="type">int</span> ans,g[<span class="number">65</span>],p[<span class="number">105</span>],v[<span class="number">105</span>],tot,s[<span class="number">105</span>],id[<span class="number">555555</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">calc</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> i,cnt=<span class="number">0</span>,sum=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=k;i++) v[i]=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=k;i++) <span class="keyword">if</span> (!v[p[i]]) v[p[i]]=++cnt,<span class="built_in">assert</span>(cnt&lt;=k&amp;&amp;p[i]&lt;=k);</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=k;i++) sum=sum*<span class="number">10</span>+v[p[i]];</span><br><span class="line">	<span class="keyword">if</span> (!id[sum]) ++tot,id[sum]=tot,s[tot]=sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> now)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (now&gt;k) <span class="keyword">return</span> <span class="built_in">calc</span>(),<span class="built_in">void</span>();</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=k;i++) p[now]=i,<span class="built_in">dfs</span>(now+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> fa[<span class="number">105</span>],h[<span class="number">105</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">getfa</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;<span class="keyword">return</span> x==fa[x]?x:fa[x]=<span class="built_in">getfa</span>(fa[x]);&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> e)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> i,j,nums=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=k;i++) fa[i]=i;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=k;i++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (j=i+<span class="number">1</span>;j&lt;=k;j++) &#123;</span><br><span class="line">			++nums;</span><br><span class="line">			<span class="keyword">if</span> ((e&gt;&gt;nums<span class="number">-1</span>)&amp;<span class="number">1</span>) &#123;</span><br><span class="line">				<span class="keyword">if</span> (<span class="built_in">getfa</span>(i)==<span class="built_in">getfa</span>(j)) <span class="keyword">return</span> ;</span><br><span class="line">				fa[<span class="built_in">getfa</span>(i)]=<span class="built_in">getfa</span>(j);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> sum=<span class="number">0</span>,cnt=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=k;i++) p[i]=<span class="built_in">getfa</span>(i);</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=k;i++) v[i]=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=k;i++) <span class="keyword">if</span> (!v[p[i]]) v[p[i]]=++cnt;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=k;i++) sum=sum*<span class="number">10</span>+v[p[i]];</span><br><span class="line">	h[id[sum]]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> S,<span class="type">int</span> e)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> i,j;</span><br><span class="line">	<span class="type">int</span> now=s[S];</span><br><span class="line">	<span class="keyword">for</span> (i=k;i&gt;=<span class="number">1</span>;i--) p[i]=now%<span class="number">10</span>,now/=<span class="number">10</span>;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=k+<span class="number">1</span>;i++) fa[i]=i;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=k;i++)</span><br><span class="line">		<span class="keyword">for</span> (j=i+<span class="number">1</span>;j&lt;=k;j++) </span><br><span class="line">			<span class="keyword">if</span> (p[i]==p[j]) </span><br><span class="line">				fa[i]=<span class="built_in">getfa</span>(j);</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=k;i++) <span class="keyword">if</span> ((e&gt;&gt;i<span class="number">-1</span>)&amp;<span class="number">1</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">getfa</span>(i)==<span class="built_in">getfa</span>(k+<span class="number">1</span>)) <span class="keyword">return</span> ;</span><br><span class="line">		fa[<span class="built_in">getfa</span>(i)]=<span class="built_in">getfa</span>(k+<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">getfa</span>(<span class="number">1</span>)==<span class="number">1</span>) <span class="keyword">return</span> ;</span><br><span class="line">	<span class="type">int</span> sum=<span class="number">0</span>,cnt=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">2</span>;i&lt;=k+<span class="number">1</span>;i++) p[i]=<span class="built_in">getfa</span>(i);</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=k+<span class="number">1</span>;i++) v[i]=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">2</span>;i&lt;=k+<span class="number">1</span>;i++) <span class="keyword">if</span> (!v[p[i]]) v[p[i]]=++cnt;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">2</span>;i&lt;=k+<span class="number">1</span>;i++) sum=sum*<span class="number">10</span>+v[p[i]];</span><br><span class="line">	++tmp.a[S][id[sum]];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> i,j,t;</span><br><span class="line">	<span class="built_in">read</span>(k);<span class="built_in">read</span>(n);</span><br><span class="line">	base=<span class="number">1</span>&lt;&lt;k;<span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;(<span class="number">1</span>&lt;&lt;(k*(k<span class="number">-1</span>)/<span class="number">2</span>));i++) <span class="built_in">solve</span>(i);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=tot;i++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (j=<span class="number">0</span>;j&lt;base;j++)</span><br><span class="line">			<span class="built_in">add</span>(i,j);</span><br><span class="line">	&#125;</span><br><span class="line">	base=tot+<span class="number">1</span>;</span><br><span class="line">	n-=k;Ans.<span class="built_in">clear</span>();</span><br><span class="line">	<span class="keyword">while</span> (n) &#123;</span><br><span class="line">		<span class="keyword">if</span> (n&amp;<span class="number">1</span>) Ans=Ans*tmp;</span><br><span class="line">		tmp=tmp*tmp;n&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=base;i++) ans=(ans+h[i]*Ans.a[i][<span class="number">1</span>])%mod;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//65410</span></span><br><span class="line"><span class="comment">//336</span></span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>dp</tag>
        <tag>计数</tag>
        <tag>矩阵</tag>
        <tag>NOI</tag>
      </tags>
  </entry>
  <entry>
    <title>P2221 [HAOI2012] 高速公路</title>
    <url>/2023/09/13/P2221-HAOI2012-%E9%AB%98%E9%80%9F%E5%85%AC%E8%B7%AF/</url>
    <content><![CDATA[<p>怎么这种吊题都要想很久。果然是要退役了&#x2F;kk</p>
<p>考虑算每条道路的贡献，先把边的数值放到前一个点上，然后默认 $r\gets r-1$ ，要求的就是：<br>$$<br>\sum_{i&#x3D;l}^r a_i(r-i+1)(i-l+1)<br>$$<br>整理后，有：<br>$$<br>(r-l+1-rl)\sum a_i+(r+l)\sum a_i\times i-\sum a_i\times i^2<br>$$<br>线段树跑一跑就好了：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 100005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> put() putchar(<span class="string">&#x27;\n&#x27;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Tp template<span class="string">&lt;typename Ty&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Ts template<span class="string">&lt;typename Ty,typename... Ar&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">(<span class="type">int</span> &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> f=<span class="number">1</span>;x=<span class="number">0</span>;<span class="type">char</span> c=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (c&lt;<span class="string">&#x27;0&#x27;</span>||c&gt;<span class="string">&#x27;9&#x27;</span>) &#123;<span class="keyword">if</span> (c==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">-1</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span> (c&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;c&lt;=<span class="string">&#x27;9&#x27;</span>) &#123;x=x*<span class="number">10</span>+c-<span class="string">&#x27;0&#x27;</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> Debug&#123;</span><br><span class="line">	Tp <span class="type">void</span> _debug(<span class="type">char</span>* f,Ty t)&#123;cerr&lt;&lt;f&lt;&lt;<span class="string">&#x27;=&#x27;</span>&lt;&lt;t&lt;&lt;endl;&#125;</span><br><span class="line">	Ts <span class="type">void</span> _debug(<span class="type">char</span>* f,Ty x,Ar... y)&#123;<span class="keyword">while</span>(*f!=<span class="string">&#x27;,&#x27;</span>) cerr&lt;&lt;*f++;cerr&lt;&lt;<span class="string">&#x27;=&#x27;</span>&lt;&lt;x&lt;&lt;<span class="string">&quot;,&quot;</span>;_debug(f+<span class="number">1</span>,y...);&#125;</span><br><span class="line">	Tp ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; os,vector&lt;Ty&gt;&amp; V)&#123;os&lt;&lt;<span class="string">&quot;[&quot;</span>;<span class="keyword">for</span>(<span class="keyword">auto</span>&amp; vv:V) os&lt;&lt;vv&lt;&lt;<span class="string">&quot;,&quot;</span>;os&lt;&lt;<span class="string">&quot;]&quot;</span>;<span class="keyword">return</span> os;&#125;</span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> gdb(...) _debug((char*)#__VA_ARGS__,__VA_ARGS__)</span></span><br><span class="line">&#125;<span class="keyword">using</span> <span class="keyword">namespace</span> Debug;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mk make_pair</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">power</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y=mod<span class="number">-2</span>)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> sum=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (y) &#123;</span><br><span class="line">		<span class="keyword">if</span> (y&amp;<span class="number">1</span>) sum=sum*x%mod;</span><br><span class="line">		x=x*x%mod;y&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> s[<span class="number">3</span>][maxn];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">yyy</span>&#123;</span><br><span class="line">	<span class="type">int</span> sum[<span class="number">3</span>],lazy;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++) sum[i]=<span class="number">0</span>;&#125;</span><br><span class="line">&#125;f[maxn&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> rt)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++) f[rt].sum[i]=f[rt&lt;&lt;<span class="number">1</span>].sum[i]+f[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].sum[i];</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">cover</span><span class="params">(<span class="type">int</span> rt,<span class="type">int</span> k,<span class="type">int</span> l,<span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++) f[rt].sum[i]+=k*(s[i][r]-s[i][l<span class="number">-1</span>]);</span><br><span class="line">	f[rt].lazy+=k;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> rt)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (f[rt].lazy) &#123;</span><br><span class="line">		<span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">		<span class="built_in">cover</span>(rt&lt;&lt;<span class="number">1</span>,f[rt].lazy,l,mid);</span><br><span class="line">		<span class="built_in">cover</span>(rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,f[rt].lazy,mid+<span class="number">1</span>,r);</span><br><span class="line">		f[rt].lazy=<span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Update</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> rt,<span class="type">int</span> head,<span class="type">int</span> tail,<span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (head&lt;=l&amp;&amp;r&lt;=tail) <span class="keyword">return</span> <span class="built_in">cover</span>(rt,k,l,r),<span class="built_in">void</span>();</span><br><span class="line">	<span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;<span class="built_in">pushdown</span>(l,r,rt);</span><br><span class="line">	<span class="keyword">if</span> (head&lt;=mid) <span class="built_in">Update</span>(l,mid,rt&lt;&lt;<span class="number">1</span>,head,tail,k);</span><br><span class="line">	<span class="keyword">if</span> (tail&gt;mid)  <span class="built_in">Update</span>(mid+<span class="number">1</span>,r,rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,head,tail,k);</span><br><span class="line">	<span class="built_in">pushup</span>(rt);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">yyy <span class="title">Query</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> rt,<span class="type">int</span> head,<span class="type">int</span> tail)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (head&lt;=l&amp;&amp;r&lt;=tail) <span class="keyword">return</span> f[rt];</span><br><span class="line">	<span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;<span class="built_in">pushdown</span>(l,r,rt);</span><br><span class="line">	yyy tmp1,tmp2;tmp1.<span class="built_in">clear</span>();tmp2.<span class="built_in">clear</span>();</span><br><span class="line">	<span class="keyword">if</span> (head&lt;=mid) tmp1=<span class="built_in">Query</span>(l,mid,rt&lt;&lt;<span class="number">1</span>,head,tail);</span><br><span class="line">	<span class="keyword">if</span> (tail&gt;mid)  tmp2=<span class="built_in">Query</span>(mid+<span class="number">1</span>,r,rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,head,tail);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++) tmp1.sum[i]+=tmp2.sum[i];</span><br><span class="line">	<span class="keyword">return</span> tmp1;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line"><span class="comment">//	freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);</span></span><br><span class="line">	<span class="type">int</span> i,l,r,x;<span class="type">char</span> ch;</span><br><span class="line">	<span class="built_in">read</span>(n);<span class="built_in">read</span>(m);</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) s[<span class="number">0</span>][i]=s[<span class="number">0</span>][i<span class="number">-1</span>]+<span class="number">1</span>,s[<span class="number">1</span>][i]=s[<span class="number">1</span>][i<span class="number">-1</span>]+i,s[<span class="number">2</span>][i]=s[<span class="number">2</span>][i<span class="number">-1</span>]+i*i;</span><br><span class="line">	<span class="keyword">while</span> (m--) &#123;</span><br><span class="line">		ch=<span class="built_in">getchar</span>();<span class="keyword">while</span> (ch!=<span class="string">&#x27;C&#x27;</span>&amp;&amp;ch!=<span class="string">&#x27;Q&#x27;</span>) ch=<span class="built_in">getchar</span>();</span><br><span class="line">		<span class="built_in">read</span>(l);<span class="built_in">read</span>(r);r--;</span><br><span class="line">		<span class="keyword">if</span> (ch==<span class="string">&#x27;C&#x27;</span>) <span class="built_in">read</span>(x),<span class="built_in">Update</span>(<span class="number">1</span>,n,<span class="number">1</span>,l,r,x);</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">auto</span> tmp=<span class="built_in">Query</span>(<span class="number">1</span>,n,<span class="number">1</span>,l,r);</span><br><span class="line">			<span class="type">int</span> ans=tmp.sum[<span class="number">0</span>]*(r-l+<span class="number">1</span>-r*l)+tmp.sum[<span class="number">1</span>]*(r+l)-tmp.sum[<span class="number">2</span>];</span><br><span class="line"><span class="comment">//			gdb(tmp.sum[0],tmp.sum[1],tmp.sum[2],ans);</span></span><br><span class="line">			<span class="type">int</span> pus=(r-l+<span class="number">2</span>)*(r-l+<span class="number">1</span>)/<span class="number">2</span>,g=__gcd(ans,pus);</span><br><span class="line">			<span class="keyword">if</span> (!ans) <span class="built_in">puts</span>(<span class="string">&quot;0/1&quot;</span>);</span><br><span class="line">			<span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%lld/%lld\n&quot;</span>,ans/g,pus/g);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>线段树</tag>
        <tag>贡献</tag>
      </tags>
  </entry>
  <entry>
    <title>P2839 [国家集训队] Middle</title>
    <url>/2023/08/24/P2839-%E5%9B%BD%E5%AE%B6%E9%9B%86%E8%AE%AD%E9%98%9F-middle/</url>
    <content><![CDATA[<h1 id="国家集训队-middle"><a href="#国家集训队-middle" class="headerlink" title="[国家集训队] middle"></a>[国家集训队] middle</h1><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p><a href="https://www.luogu.com.cn/problem/P2839">https://www.luogu.com.cn/problem/P2839</a></p>
<p>但是关于题面，$b$ 应该是从大到小排序。</p>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>考虑中位数的经典套路，二分答案，大于等于这个数的设为 $1$，小于这个数的设为 $-1$。序列之和为 $\ge 0$ 将右端点移到中点，反之移动左端点。</p>
<p>现在应用这个套路。将权值作为主席树的下标，每次单点修改。</p>
<p>问题关键在于不强制但可以选的那一部分。因为我们要中位数最大，做前缀最大和和后缀最大和即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 50005</span></span><br><span class="line"><span class="type">int</span> n,q;</span><br><span class="line"><span class="type">int</span> a[maxn],g[maxn],tot,cnt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">yyy</span>&#123;</span><br><span class="line">	<span class="type">int</span> ls,rs,sum,lsum,rsum;</span><br><span class="line">	<span class="built_in">yyy</span>(<span class="type">int</span> a=<span class="number">0</span>,<span class="type">int</span> b=<span class="number">0</span>,<span class="type">int</span> c=<span class="number">0</span>) &#123;sum=a,lsum=b,rsum=c;&#125;</span><br><span class="line">&#125;f[maxn*<span class="number">20</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">calc</span><span class="params">(yyy x,yyy y,yyy &amp;ans)</span> </span>&#123;</span><br><span class="line">	ans.sum=x.sum+y.sum;</span><br><span class="line">	ans.lsum=<span class="built_in">max</span>(x.lsum,x.sum+y.lsum);</span><br><span class="line">	ans.rsum=<span class="built_in">max</span>(y.rsum,x.rsum+y.sum);</span><br><span class="line">	<span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">Update</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> pre,<span class="type">int</span> head,<span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> rt=++cnt;f[rt]=f[pre];</span><br><span class="line">	<span class="keyword">if</span> (l==r) <span class="keyword">return</span> f[rt].sum=f[rt].lsum=f[rt].rsum=k,rt;</span><br><span class="line">	<span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span> (head&lt;=mid) f[rt].ls=<span class="built_in">Update</span>(l,mid,f[rt].ls,head,k); </span><br><span class="line">	<span class="keyword">else</span> f[rt].rs=<span class="built_in">Update</span>(mid+<span class="number">1</span>,r,f[rt].rs,head,k);</span><br><span class="line">	<span class="built_in">calc</span>(f[f[rt].ls],f[f[rt].rs],f[rt]);</span><br><span class="line">	<span class="keyword">return</span> rt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf=<span class="number">1e9</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> yyy <span class="title">Query</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> rt,<span class="type">int</span> head,<span class="type">int</span> tail)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!rt) <span class="keyword">return</span> <span class="built_in">yyy</span>(-inf,-inf,-inf);</span><br><span class="line">	<span class="keyword">if</span> (head&lt;=l&amp;&amp;r&lt;=tail) <span class="keyword">return</span> f[rt];</span><br><span class="line">	<span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span> (head&lt;=mid&amp;&amp;mid&lt;tail) &#123;</span><br><span class="line">		yyy tmp1=<span class="built_in">Query</span>(l,mid,f[rt].ls,head,tail);</span><br><span class="line">		yyy tmp2=<span class="built_in">Query</span>(mid+<span class="number">1</span>,r,f[rt].rs,head,tail);</span><br><span class="line">		yyy tmp3;<span class="built_in">calc</span>(tmp1,tmp2,tmp3);</span><br><span class="line">		<span class="keyword">return</span> tmp3;</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (head&lt;=mid) <span class="keyword">return</span> <span class="built_in">Query</span>(l,mid,f[rt].ls,head,tail);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (tail&gt;mid)  <span class="keyword">return</span> <span class="built_in">Query</span>(mid+<span class="number">1</span>,r,f[rt].rs,head,tail);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> root[maxn],id[maxn];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span> </span>&#123;<span class="keyword">return</span> a[x]&lt;a[y];&#125;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;O[maxn];</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="built_in">read</span>(n);</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">read</span>(a[i]),g[i]=a[i];</span><br><span class="line">	<span class="built_in">sort</span>(g+<span class="number">1</span>,g+<span class="number">1</span>+n);</span><br><span class="line">	tot=<span class="built_in">unique</span>(g+<span class="number">1</span>,g+<span class="number">1</span>+n)-g<span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) a[i]=<span class="built_in">lower_bound</span>(g+<span class="number">1</span>,g+<span class="number">1</span>+n,a[i])-g,O[a[i]].<span class="built_in">push_back</span>(i);</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) root[<span class="number">0</span>]=<span class="built_in">Update</span>(<span class="number">1</span>,n,root[<span class="number">0</span>],i,<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=tot;i++) &#123;</span><br><span class="line">		root[i]=root[i<span class="number">-1</span>];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> tmp:O[i<span class="number">-1</span>]) </span><br><span class="line">			root[i]=<span class="built_in">Update</span>(<span class="number">1</span>,n,root[i],tmp,<span class="number">-1</span>);</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="built_in">read</span>(q);</span><br><span class="line">	<span class="type">int</span> las=<span class="number">0</span>,tmp1,tmp2,tmp3,tmp4,s1,s2,s3;</span><br><span class="line">	<span class="keyword">while</span> (q--) &#123;</span><br><span class="line">		<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=<span class="number">4</span>;i++) <span class="built_in">read</span>(id[i]),id[i]=(id[i]+las)%n+<span class="number">1</span>;</span><br><span class="line">		<span class="built_in">sort</span>(id+<span class="number">1</span>,id+<span class="number">5</span>);</span><br><span class="line">		tmp1=id[<span class="number">1</span>],tmp2=id[<span class="number">2</span>],tmp3=id[<span class="number">3</span>],tmp4=id[<span class="number">4</span>];</span><br><span class="line">		<span class="type">int</span> l=<span class="number">0</span>,r=tot+<span class="number">1</span>,mid;</span><br><span class="line">		<span class="keyword">while</span> (l+<span class="number">1</span>&lt;r) &#123;</span><br><span class="line">			mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">			s1=s2=s3=<span class="number">0</span>;</span><br><span class="line">			<span class="keyword">if</span> (tmp1&lt;tmp2) s1=<span class="built_in">Query</span>(<span class="number">1</span>,n,root[mid],tmp1,tmp2).rsum;</span><br><span class="line">			<span class="keyword">if</span> (tmp2+<span class="number">1</span>&lt;tmp3) s2=<span class="built_in">Query</span>(<span class="number">1</span>,n,root[mid],tmp2+<span class="number">1</span>,tmp3<span class="number">-1</span>).sum;</span><br><span class="line">			<span class="keyword">if</span> (tmp3&lt;tmp4) s3=<span class="built_in">Query</span>(<span class="number">1</span>,n,root[mid],tmp3,tmp4).lsum;</span><br><span class="line">			<span class="keyword">if</span> (s1+s2+s3&gt;=<span class="number">0</span>) l=mid;</span><br><span class="line">			<span class="keyword">else</span> r=mid;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,las=g[l]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>主席树</tag>
      </tags>
  </entry>
  <entry>
    <title>P3343 [ZJOI2015] 地震后的幻想乡</title>
    <url>/2023/08/30/P3343-ZJOI2015-%E5%9C%B0%E9%9C%87%E5%90%8E%E7%9A%84%E5%B9%BB%E6%83%B3%E4%B9%A1/</url>
    <content><![CDATA[<h1 id="P3343-ZJOI2015-地震后的幻想乡"><a href="#P3343-ZJOI2015-地震后的幻想乡" class="headerlink" title="P3343 [ZJOI2015] 地震后的幻想乡"></a>P3343 [ZJOI2015] 地震后的幻想乡</h1><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p><a href="https://www.luogu.com.cn/problem/P3343">https://www.luogu.com.cn/problem/P3343</a></p>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>相当妙妙的题目啊。</p>
<p>根据提示，就直接把第 $k$ 大权值设为 $\dfrac{k}{m+1}$。</p>
<p>考虑<strong>恰好</strong>选 $k$ 条边使图联通的概率 $g_k$，则答案为 $\sum\limits_{i&#x3D;1}^m \dfrac{ig_i}{m+1}$。</p>
<p>恰好是不好做的，转化为选 $k$ 条边<strong>依然不能使图联通</strong>的概率 $f_k$，则答案为 $\sum\limits_{i&#x3D;0}^m \dfrac{f_i}{m+1}$。</p>
<p>观察到点比较少，记 $f_{S,i}$ 表示点集为 $S$，选了 $i$ 条边依然不能使图联通的个数。考虑容斥转移，记 $x$ 是 $S$ 中最小的一个点（其实可以是任意一个点，但是为了方便），枚举包含 $x$ 的连通块，然后枚举联通块选了几条边，钦定这个连通块一定联通，而连通块的在 $S$ 补集中的边随便选，两个连通块之间没有边。这样可以找到不连通的全部情况。这种容斥的想法真是很妙啊！！！</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">double</span> dp[(<span class="number">1</span>&lt;&lt;<span class="number">10</span>)+<span class="number">5</span>][<span class="number">105</span>],c[<span class="number">105</span>][<span class="number">105</span>],ans;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">yyy</span>&#123;</span><br><span class="line">	<span class="type">int</span> x,y;</span><br><span class="line">&#125;e[<span class="number">105</span>];</span><br><span class="line"><span class="type">int</span> n,m,g[(<span class="number">1</span>&lt;&lt;<span class="number">10</span>)];</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line"><span class="comment">//	freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);</span></span><br><span class="line">	<span class="type">int</span> i,j,k,t;</span><br><span class="line">	<span class="built_in">read</span>(n);<span class="built_in">read</span>(m);</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=m;i++) <span class="built_in">read</span>(e[i].x),<span class="built_in">read</span>(e[i].y),e[i].x--,e[i].y--;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;(<span class="number">1</span>&lt;&lt;n);i++) </span><br><span class="line">		<span class="keyword">for</span> (j=<span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line">			<span class="keyword">if</span> ((i&gt;&gt;e[j].x)%<span class="number">2</span>&amp;&amp;(i&gt;&gt;e[j].y)%<span class="number">2</span>) g[i]++;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;=m;i++) &#123;</span><br><span class="line">		c[i][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span> (j=<span class="number">1</span>;j&lt;=i;j++) c[i][j]=c[i<span class="number">-1</span>][j<span class="number">-1</span>]+c[i<span class="number">-1</span>][j];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> N=(<span class="number">1</span>&lt;&lt;n);</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;N;i++) &#123;</span><br><span class="line">		<span class="type">int</span> z=<span class="built_in">min</span>(n+<span class="number">1</span>,__builtin_ctz(i));</span><br><span class="line">		<span class="keyword">for</span> (t=i&amp;(i<span class="number">-1</span>);t;t=(t<span class="number">-1</span>)&amp;i) <span class="keyword">if</span> ((t&gt;&gt;z)&amp;<span class="number">1</span>) &#123;</span><br><span class="line">			<span class="keyword">for</span> (j=<span class="number">0</span>;j&lt;=g[i^t];j++) &#123;</span><br><span class="line">				<span class="keyword">for</span> (k=<span class="number">0</span>;k&lt;=g[t];k++)</span><br><span class="line">					dp[i][j+k]+=(<span class="number">1</span>-dp[t][k])*c[g[t]][k]*c[g[t^i]][j]/c[g[i]][j+k];<span class="comment">//这j+k条边并没有先后顺序</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125; 	</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;=m;i++) ans+=dp[N<span class="number">-1</span>][i]/(m+<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%.6lf&quot;</span>,ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>dp</tag>
        <tag>容斥</tag>
        <tag>组合</tag>
        <tag>计数</tag>
      </tags>
  </entry>
  <entry>
    <title>P3350 [ZJOI2016] 旅行者</title>
    <url>/2023/08/24/P3350-ZJOI2016-%E6%97%85%E8%A1%8C%E8%80%85/</url>
    <content><![CDATA[<h1 id="ZJOI2016-旅行者"><a href="#ZJOI2016-旅行者" class="headerlink" title="[ZJOI2016] 旅行者"></a>[ZJOI2016] 旅行者</h1><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p><a href="https://www.luogu.com.cn/problem/P3350">https://www.luogu.com.cn/problem/P3350</a></p>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>考虑分治。每次找当前矩阵较长的那一条边，取中点作为划分，暴力求出经过划分的线的最短路。如果两个点再划分之后的同一边，则递归下去。</p>
<p>每次都找中点划分，令 $S&#x3D;nm$，则复杂度是 $S\sqrt S \log S$，后面的 $\log$ 是最短路。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 205</span></span><br><span class="line"><span class="type">int</span> n,m,T;</span><br><span class="line"><span class="type">int</span> head=<span class="number">1</span>,h[maxn*maxn];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">id</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span> </span>&#123;<span class="keyword">return</span> (x<span class="number">-1</span>)*(m+<span class="number">1</span>)+y;&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">yyy</span>&#123;</span><br><span class="line">	<span class="type">int</span> to,z,w;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">		to=y;z=h[x];h[x]=head;w=val;</span><br><span class="line">	&#125; </span><br><span class="line">&#125;a[<span class="number">160005</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">ins</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> z)</span> </span>&#123;</span><br><span class="line">	a[++head].<span class="built_in">add</span>(x,y,z);</span><br><span class="line">	a[++head].<span class="built_in">add</span>(y,x,z);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">	<span class="type">int</span> x,xx,y,yy,id;</span><br><span class="line">&#125;tmp;</span><br><span class="line">vector&lt;node&gt;O;</span><br><span class="line"><span class="type">int</span> Ans[<span class="number">100005</span>];</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mk make_pair</span></span><br><span class="line">priority_queue&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span> &gt; &gt;q;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf=<span class="number">1e9</span>;</span><br><span class="line"><span class="type">int</span> vis[maxn*maxn],dis[maxn][maxn*maxn];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">dj</span><span class="params">(<span class="type">int</span> pos,<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> Lx,<span class="type">int</span> Rx,<span class="type">int</span> Ly,<span class="type">int</span> Ry)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> i,j;</span><br><span class="line">	<span class="built_in">assert</span>(pos&lt;=<span class="number">200</span>);</span><br><span class="line">	<span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) q.<span class="built_in">pop</span>();</span><br><span class="line">	<span class="keyword">for</span> (i=Lx;i&lt;=Rx;i++) <span class="keyword">for</span> (j=Ly;j&lt;=Ry;j++) dis[pos][<span class="built_in">id</span>(i,j)]=inf,vis[<span class="built_in">id</span>(i,j)]=<span class="number">0</span>;</span><br><span class="line">	dis[pos][<span class="built_in">id</span>(x,y)]=<span class="number">0</span>;q.<span class="built_in">push</span>(<span class="built_in">mk</span>(-dis[pos][<span class="built_in">id</span>(x,y)],<span class="built_in">id</span>(x,y)));</span><br><span class="line">	<span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">		<span class="type">int</span> tmp=q.<span class="built_in">top</span>().se;q.<span class="built_in">pop</span>();</span><br><span class="line">		y=tmp%(m+<span class="number">1</span>),x=tmp/(m+<span class="number">1</span>)+<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span> (vis[tmp]) <span class="keyword">continue</span>;</span><br><span class="line">		vis[tmp]=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span> (i=h[tmp];i;i=a[i].z) <span class="keyword">if</span> (dis[pos][a[i].to]&gt;dis[pos][tmp]+a[i].w</span><br><span class="line">		&amp;&amp;Lx&lt;=a[i].to/(m+<span class="number">1</span>)+<span class="number">1</span>&amp;&amp;a[i].to/(m+<span class="number">1</span>)+<span class="number">1</span>&lt;=Rx&amp;&amp;Ly&lt;=a[i].to%(m+<span class="number">1</span>)&amp;&amp;a[i].to%(m+<span class="number">1</span>)&lt;=Ry) &#123;</span><br><span class="line">			dis[pos][a[i].to]=dis[pos][tmp]+a[i].w;</span><br><span class="line">			q.<span class="built_in">push</span>(<span class="built_in">mk</span>(-dis[pos][a[i].to],a[i].to));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> lx,<span class="type">int</span> rx,<span class="type">int</span> ly,<span class="type">int</span> ry,vector&lt;node&gt;q)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> i,j;</span><br><span class="line">	<span class="keyword">if</span> (ry-ly+<span class="number">1</span>&lt;=<span class="number">3</span>&amp;&amp;rx-lx+<span class="number">1</span>&lt;=<span class="number">3</span>) &#123;</span><br><span class="line">		<span class="type">int</span> tot=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (i=lx;i&lt;=rx;i++) 	</span><br><span class="line">			<span class="keyword">for</span> (j=ly;j&lt;=ry;j++)</span><br><span class="line">				++tot,<span class="built_in">dj</span>(tot,i,j,lx,rx,ly,ry);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> tmp:q) &#123;</span><br><span class="line">			<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=tot;i++) </span><br><span class="line">				Ans[tmp.id]=<span class="built_in">min</span>(Ans[tmp.id],dis[i][<span class="built_in">id</span>(tmp.x,tmp.y)]+dis[i][<span class="built_in">id</span>(tmp.xx,tmp.yy)]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (rx-lx&lt;ry-ly) &#123;</span><br><span class="line">		<span class="type">int</span> mid=ly+ry&gt;&gt;<span class="number">1</span>,tot=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (i=lx;i&lt;=rx;i++) <span class="built_in">dj</span>(++tot,i,mid,lx,rx,ly,ry);</span><br><span class="line">		vector&lt;node&gt;ql,qr;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> tmp:q) &#123;	</span><br><span class="line">			<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=tot;i++) Ans[tmp.id]=<span class="built_in">min</span>(Ans[tmp.id],dis[i][<span class="built_in">id</span>(tmp.x,tmp.y)]+dis[i][<span class="built_in">id</span>(tmp.xx,tmp.yy)]);</span><br><span class="line">			<span class="keyword">if</span> (<span class="built_in">max</span>(tmp.y,tmp.yy)&lt;=mid) ql.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">min</span>(tmp.y,tmp.yy)&gt;mid) qr.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">solve</span>(lx,rx,ly,mid,ql);</span><br><span class="line">		<span class="built_in">solve</span>(lx,rx,mid,ry,qr);	</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="type">int</span> mid=lx+rx&gt;&gt;<span class="number">1</span>,tot=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (i=ly;i&lt;=ry;i++) ++tot,<span class="built_in">dj</span>(tot,mid,i,lx,rx,ly,ry);</span><br><span class="line">		vector&lt;node&gt;ql,qr;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> tmp:q) &#123;</span><br><span class="line">			<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=tot;i++) Ans[tmp.id]=<span class="built_in">min</span>(Ans[tmp.id],dis[i][<span class="built_in">id</span>(tmp.x,tmp.y)]+dis[i][<span class="built_in">id</span>(tmp.xx,tmp.yy)]);</span><br><span class="line">			<span class="keyword">if</span> (<span class="built_in">max</span>(tmp.x,tmp.xx)&lt;=mid) ql.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">min</span>(tmp.x,tmp.xx)&gt;mid) qr.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">solve</span>(lx,mid,ly,ry,ql);</span><br><span class="line">		<span class="built_in">solve</span>(mid,rx,ly,ry,qr);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> i,j,x;</span><br><span class="line">	<span class="built_in">read</span>(n);<span class="built_in">read</span>(m);</span><br><span class="line">	<span class="built_in">memset</span>(Ans,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(Ans));</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		<span class="keyword">for</span> (j=<span class="number">1</span>;j&lt;m;j++) </span><br><span class="line">			<span class="built_in">read</span>(x),<span class="built_in">ins</span>(<span class="built_in">id</span>(i,j),<span class="built_in">id</span>(i,j+<span class="number">1</span>),x);</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;n;i++) </span><br><span class="line">		<span class="keyword">for</span> (j=<span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line">			<span class="built_in">read</span>(x),<span class="built_in">ins</span>(<span class="built_in">id</span>(i,j),<span class="built_in">id</span>(i+<span class="number">1</span>,j),x);</span><br><span class="line">	<span class="built_in">read</span>(T);node tmp;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=T;i++) &#123;</span><br><span class="line">		<span class="built_in">read</span>(tmp.x),<span class="built_in">read</span>(tmp.y),<span class="built_in">read</span>(tmp.xx),<span class="built_in">read</span>(tmp.yy);tmp.id=i;</span><br><span class="line">		O.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">solve</span>(<span class="number">1</span>,n,<span class="number">1</span>,m,O);</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=T;i++) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,Ans[i]);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>分治</tag>
      </tags>
  </entry>
  <entry>
    <title>P3590 [POI2015] TRZ</title>
    <url>/2023/02/28/P3590-POI2015-TRZ/</url>
    <content><![CDATA[<p>有趣的结论题。</p>
<p>结论就是最长的满足条件的字串的<strong>左端点在最左边三个</strong>或者<strong>右端点在最右边三个</strong>。</p>
<p>枚举即可。至于结论怎么来的？场上只能打表了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 1000005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> put() putchar(<span class="string">&#x27;\n&#x27;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Tp template<span class="string">&lt;typename Ty&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Ts template<span class="string">&lt;typename Ty,typename... Ar&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(<span class="type">int</span> &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> f=<span class="number">1</span>;x=<span class="number">0</span>;<span class="type">char</span> c=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (c&lt;<span class="string">&#x27;0&#x27;</span>||c&gt;<span class="string">&#x27;9&#x27;</span>) &#123;<span class="keyword">if</span> (c==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">-1</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span> (c&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;c&lt;=<span class="string">&#x27;9&#x27;</span>) &#123;x=x*<span class="number">10</span>+c-<span class="string">&#x27;0&#x27;</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> Debug&#123;</span><br><span class="line">	Tp <span class="type">void</span> _debug(<span class="type">char</span>* f,Ty t)&#123;cerr&lt;&lt;f&lt;&lt;<span class="string">&#x27;=&#x27;</span>&lt;&lt;t&lt;&lt;endl;&#125;</span><br><span class="line">	Ts <span class="type">void</span> _debug(<span class="type">char</span>* f,Ty x,Ar... y)&#123;<span class="keyword">while</span>(*f!=<span class="string">&#x27;,&#x27;</span>) cerr&lt;&lt;*f++;cerr&lt;&lt;<span class="string">&#x27;=&#x27;</span>&lt;&lt;x&lt;&lt;<span class="string">&quot;,&quot;</span>;_debug(f+<span class="number">1</span>,y...);&#125;</span><br><span class="line">	Tp ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; os,vector&lt;Ty&gt;&amp; V)&#123;os&lt;&lt;<span class="string">&quot;[&quot;</span>;<span class="keyword">for</span>(<span class="keyword">auto</span>&amp; vv:V) os&lt;&lt;vv&lt;&lt;<span class="string">&quot;,&quot;</span>;os&lt;&lt;<span class="string">&quot;]&quot;</span>;<span class="keyword">return</span> os;&#125;</span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> gdb(...) _debug((char*)#__VA_ARGS__,__VA_ARGS__)</span></span><br><span class="line">&#125;<span class="keyword">using</span> <span class="keyword">namespace</span> Debug;</span><br><span class="line"><span class="type">int</span> suf[maxn][<span class="number">3</span>];</span><br><span class="line"><span class="type">char</span> s[maxn];</span><br><span class="line"><span class="type">int</span> ans;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> x,y,z;</span><br><span class="line">	x=suf[r][<span class="number">0</span>]-suf[l<span class="number">-1</span>][<span class="number">0</span>];</span><br><span class="line">	y=suf[r][<span class="number">1</span>]-suf[l<span class="number">-1</span>][<span class="number">1</span>];</span><br><span class="line">	z=suf[r][<span class="number">2</span>]-suf[l<span class="number">-1</span>][<span class="number">2</span>];</span><br><span class="line">	<span class="type">int</span> sum=(x==<span class="number">0</span>)+(y==<span class="number">0</span>)+(z==<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span> (sum==<span class="number">2</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span> (x==y||y==z||z==x) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line"><span class="comment">//	freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);</span></span><br><span class="line">	<span class="type">int</span> i,j,n;</span><br><span class="line">	<span class="built_in">read</span>(n);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s+<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (s[i]==<span class="string">&#x27;B&#x27;</span>) suf[i][<span class="number">0</span>]=suf[i<span class="number">-1</span>][<span class="number">0</span>]+<span class="number">1</span>;<span class="keyword">else</span> suf[i][<span class="number">0</span>]=suf[i<span class="number">-1</span>][<span class="number">0</span>];</span><br><span class="line">		<span class="keyword">if</span> (s[i]==<span class="string">&#x27;C&#x27;</span>) suf[i][<span class="number">1</span>]=suf[i<span class="number">-1</span>][<span class="number">1</span>]+<span class="number">1</span>;<span class="keyword">else</span> suf[i][<span class="number">1</span>]=suf[i<span class="number">-1</span>][<span class="number">1</span>];</span><br><span class="line">		<span class="keyword">if</span> (s[i]==<span class="string">&#x27;S&#x27;</span>) suf[i][<span class="number">2</span>]=suf[i<span class="number">-1</span>][<span class="number">2</span>]+<span class="number">1</span>;<span class="keyword">else</span> suf[i][<span class="number">2</span>]=suf[i<span class="number">-1</span>][<span class="number">2</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=<span class="number">3</span>&amp;&amp;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (j=n;j&gt;=i;j--) <span class="keyword">if</span> (<span class="built_in">solve</span>(i,j)) &#123;ans=<span class="built_in">max</span>(ans,j-i+<span class="number">1</span>);<span class="keyword">break</span>;&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (i=n;i&gt;=n<span class="number">-2</span>&amp;&amp;i&gt;=<span class="number">1</span>;i--) &#123;</span><br><span class="line">		<span class="keyword">for</span> (j=<span class="number">1</span>;j&lt;=i;j++) <span class="keyword">if</span> (<span class="built_in">solve</span>(j,i)) &#123;ans=<span class="built_in">max</span>(ans,i-j+<span class="number">1</span>);<span class="keyword">break</span>;&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>POI</tag>
        <tag>结论</tag>
      </tags>
  </entry>
  <entry>
    <title>P3607 [USACO17JAN] Subsequence Reversal P</title>
    <url>/2023/08/30/P3607-USACO17JAN-Subsequence-Reversal-P/</url>
    <content><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p><a href="https://www.luogu.com.cn/problem/P3607">https://www.luogu.com.cn/problem/P3607</a></p>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>只记录区间是难处理的，考虑多记录值域 $[l,r]$ ，表示在区间的 $[i,j]$ 值域 $[l,r]$ 之间的最长不下降子序列。</p>
<p>转移简单。</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 55</span></span><br><span class="line"><span class="type">int</span> n,a[maxn],f[maxn][maxn][maxn][maxn];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">amax</span><span class="params">(<span class="type">int</span> &amp;x,<span class="type">int</span> y)</span> </span>&#123;x=<span class="built_in">max</span>(x,y);&#125;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> base=<span class="number">50</span>;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> i,j,l,r;</span><br><span class="line">	<span class="built_in">read</span>(n);</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">read</span>(a[i]),f[i][i][a[i]][a[i]]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;n;i++) f[i][i+<span class="number">1</span>][<span class="built_in">min</span>(a[i],a[i+<span class="number">1</span>])][<span class="built_in">max</span>(a[i],a[i+<span class="number">1</span>])]=<span class="number">2</span>;</span><br><span class="line">	<span class="keyword">for</span> (i=n;i&gt;=<span class="number">1</span>;i--) &#123;</span><br><span class="line">		<span class="keyword">for</span> (j=i;j&lt;=n;j++) &#123;</span><br><span class="line">			<span class="keyword">for</span> (l=base;l&gt;=<span class="number">1</span>;l--)</span><br><span class="line">				<span class="keyword">for</span> (r=l+<span class="number">1</span>;r&lt;=base;r++) &#123;</span><br><span class="line">					<span class="built_in">amax</span>(f[i][j][l][r],<span class="built_in">max</span>(f[i][j][l+<span class="number">1</span>][r],f[i][j][l][r<span class="number">-1</span>]));</span><br><span class="line">					<span class="built_in">amax</span>(f[i][j][l][r],f[i+<span class="number">1</span>][j][l][r]+(a[i]==l));</span><br><span class="line">					<span class="built_in">amax</span>(f[i][j][l][r],f[i][j<span class="number">-1</span>][l][r]+(a[j]==r));</span><br><span class="line">					<span class="built_in">amax</span>(f[i][j][l][r],f[i+<span class="number">1</span>][j<span class="number">-1</span>][l][r]+(a[i]==r)+(a[j]==l));</span><br><span class="line">				&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,f[<span class="number">1</span>][n][<span class="number">1</span>][base]);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title>P3645 [APIO2015] 雅加达的摩天楼</title>
    <url>/2023/08/24/P3645-APIO2015-%E9%9B%85%E5%8A%A0%E8%BE%BE%E7%9A%84%E6%91%A9%E5%A4%A9%E6%A5%BC/</url>
    <content><![CDATA[<h1 id="APIO2010-雅加达的摩天楼"><a href="#APIO2010-雅加达的摩天楼" class="headerlink" title="APIO2010 雅加达的摩天楼"></a>APIO2010 雅加达的摩天楼</h1><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p><a href="https://www.luogu.com.cn/problem/P3645">https://www.luogu.com.cn/problem/P3645</a></p>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>根号分治。</p>
<p>跳跃能力相同且小于阈值 $B$ 的优化建边。</p>
<p>这样边数是 $O(nB+\dfrac{n^2}{B})$ 的。取 $B&#x3D;\sqrt n$。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 30005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> put() putchar(<span class="string">&#x27;\n&#x27;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Tp template<span class="string">&lt;typename Ty&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Ts template<span class="string">&lt;typename Ty,typename... Ar&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(<span class="type">int</span> &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> f=<span class="number">1</span>;x=<span class="number">0</span>;<span class="type">char</span> c=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (c&lt;<span class="string">&#x27;0&#x27;</span>||c&gt;<span class="string">&#x27;9&#x27;</span>) &#123;<span class="keyword">if</span> (c==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">-1</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span> (c&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;c&lt;=<span class="string">&#x27;9&#x27;</span>) &#123;x=x*<span class="number">10</span>+c-<span class="string">&#x27;0&#x27;</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> Debug&#123;</span><br><span class="line">	Tp <span class="type">void</span> _debug(<span class="type">char</span>* f,Ty t)&#123;cerr&lt;&lt;f&lt;&lt;<span class="string">&#x27;=&#x27;</span>&lt;&lt;t&lt;&lt;endl;&#125;</span><br><span class="line">	Ts <span class="type">void</span> _debug(<span class="type">char</span>* f,Ty x,Ar... y)&#123;<span class="keyword">while</span>(*f!=<span class="string">&#x27;,&#x27;</span>) cerr&lt;&lt;*f++;cerr&lt;&lt;<span class="string">&#x27;=&#x27;</span>&lt;&lt;x&lt;&lt;<span class="string">&quot;,&quot;</span>;_debug(f+<span class="number">1</span>,y...);&#125;</span><br><span class="line">	Tp ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; os,vector&lt;Ty&gt;&amp; V)&#123;os&lt;&lt;<span class="string">&quot;[&quot;</span>;<span class="keyword">for</span>(<span class="keyword">auto</span>&amp; vv:V) os&lt;&lt;vv&lt;&lt;<span class="string">&quot;,&quot;</span>;os&lt;&lt;<span class="string">&quot;]&quot;</span>;<span class="keyword">return</span> os;&#125;</span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> gdb(...) _debug((char*)#__VA_ARGS__,__VA_ARGS__)</span></span><br><span class="line">&#125;<span class="keyword">using</span> <span class="keyword">namespace</span> Debug;</span><br><span class="line"><span class="type">int</span> n,m,b[maxn],p[maxn];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;O[maxn];</span><br><span class="line"><span class="type">int</span> head=<span class="number">1</span>,h[maxn];</span><br><span class="line"><span class="type">int</span> pre[maxn],nex[maxn],t[maxn];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">yyy</span>&#123;</span><br><span class="line">	<span class="type">int</span> to,z,w;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">		to=y;z=h[x];h[x]=head;w=val;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;a[<span class="number">12000005</span>];	</span><br><span class="line"><span class="type">int</span> dis[maxn],vis[maxn];</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mk make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line">priority_queue&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; &gt;q;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">dj</span><span class="params">(<span class="type">int</span> s)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> i,x;</span><br><span class="line">	<span class="built_in">memset</span>(dis,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(dis));</span><br><span class="line">	q.<span class="built_in">push</span>(<span class="built_in">mk</span>(<span class="number">0</span>,s));dis[s]=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">		x=q.<span class="built_in">top</span>().se;q.<span class="built_in">pop</span>();</span><br><span class="line">		<span class="keyword">if</span> (vis[x]) <span class="keyword">continue</span>;vis[x]=<span class="number">1</span>;  </span><br><span class="line">		<span class="keyword">for</span> (i=h[x];i;i=a[i].z) <span class="keyword">if</span> (dis[a[i].to]&gt;dis[x]+a[i].w) &#123;</span><br><span class="line">			dis[a[i].to]=dis[x]+a[i].w;</span><br><span class="line">			q.<span class="built_in">push</span>(<span class="built_in">mk</span>(-dis[a[i].to],a[i].to));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> i,j,k,o;</span><br><span class="line">	<span class="built_in">read</span>(m);<span class="built_in">read</span>(n);</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">read</span>(b[i]),b[i]++,<span class="built_in">read</span>(p[i]),O[p[i]].<span class="built_in">push_back</span>(i);</span><br><span class="line">	<span class="type">int</span> block=<span class="built_in">sqrt</span>(m)+<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (j=<span class="number">1</span>;j&lt;=block;j++) &#123;</span><br><span class="line">		<span class="built_in">sort</span>(O[j].<span class="built_in">begin</span>(),O[j].<span class="built_in">end</span>());</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> tmp:O[j]) t[b[tmp]]=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span> (k=<span class="number">1</span>;k&lt;=j;k++) &#123;</span><br><span class="line">			<span class="type">int</span> las=k;</span><br><span class="line">			<span class="keyword">for</span> (i=k;i&lt;=m;i+=j) pre[i]=las,las=(t[i]?i:las);</span><br><span class="line">			i-=j;las=i;</span><br><span class="line">			<span class="keyword">for</span> (;i&gt;=k;i-=j) nex[i]=las,las=(t[i]?i:las);</span><br><span class="line">			<span class="keyword">for</span> (i=k;i&lt;=m;i+=j) <span class="keyword">if</span> (t[i]) &#123;</span><br><span class="line">				<span class="keyword">for</span> (o=pre[i];o&lt;=nex[i];o+=j) <span class="keyword">if</span> (i^o) a[++head].<span class="built_in">add</span>(i,o,<span class="built_in">abs</span>(i-o)/j);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> tmp:O[j]) t[b[tmp]]=<span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (j=block+<span class="number">1</span>;j&lt;=m;j++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> tmp:O[j]) &#123;</span><br><span class="line">			<span class="keyword">for</span> (i=b[tmp]-j;i&gt;=<span class="number">1</span>;i-=j) a[++head].<span class="built_in">add</span>(b[tmp],i,<span class="built_in">abs</span>(b[tmp]-i)/j);</span><br><span class="line">			<span class="keyword">for</span> (i=b[tmp]+j;i&lt;=m;i+=j) a[++head].<span class="built_in">add</span>(b[tmp],i,<span class="built_in">abs</span>(b[tmp]-i)/j); </span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> tmp=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (i=b[tmp]-j;i&gt;=<span class="number">1</span>;i-=j) a[++head].<span class="built_in">add</span>(b[tmp],i,<span class="built_in">abs</span>(b[tmp]-i)/p[tmp]);</span><br><span class="line">	<span class="keyword">for</span> (i=b[tmp]+j;i&lt;=m;i+=j) a[++head].<span class="built_in">add</span>(b[tmp],i,<span class="built_in">abs</span>(b[tmp]-i)/p[tmp]);</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">dj</span>(b[<span class="number">1</span>]);</span><br><span class="line">	<span class="keyword">if</span> (dis[b[<span class="number">2</span>]]&gt;<span class="number">1e9</span>) <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>);</span><br><span class="line">	<span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,dis[b[<span class="number">2</span>]]);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>gen&#39;hao</tag>
      </tags>
  </entry>
  <entry>
    <title>P4007 小 Y 和恐怖的奴隶主</title>
    <url>/2023/08/31/P4007-%E5%B0%8F-Y-%E5%92%8C%E6%81%90%E6%80%96%E7%9A%84%E5%A5%B4%E9%9A%B6%E4%B8%BB/</url>
    <content><![CDATA[<h1 id="小-Y-和恐怖的奴隶主"><a href="#小-Y-和恐怖的奴隶主" class="headerlink" title="小 Y 和恐怖的奴隶主"></a>小 Y 和恐怖的奴隶主</h1><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p><a href="https://www.luogu.com.cn/problem/P4007">https://www.luogu.com.cn/problem/P4007</a></p>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>看到数据范围想到矩阵乘法。考虑递推，知道状态的概率，再维护期望。</p>
<p>但是很多状态是重复的。例如 $m&#x3D;3$ 只需要维护 $(a,b,c)$ 表示血量为 $1,2,3$ 的分别有 $a,b,c$ 个，其中 $a+b+c\le K$。搜出来大概不到两百个状态，转移矩阵直接暴力搞出来。设状态数为 $w$。</p>
<p>然后查询的时候预处理出 $2^i$ 的矩阵，矩阵乘向量是 $O(w^2)$ 的，总的复杂度就是 $O(w^3\log n+Tw^2\log n)$。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 205</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">998244353</span>;</span><br><span class="line"><span class="type">int</span> base,m,K;</span><br><span class="line"><span class="type">int</span> id[<span class="number">5005</span>],cnt;</span><br><span class="line"><span class="type">int</span> s[<span class="number">5</span>],tot,inv[<span class="number">15</span>],p[maxn];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Mat</span> &#123;</span><br><span class="line">	<span class="type">int</span> a[maxn][maxn];</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">		<span class="built_in">memset</span>(a,<span class="number">0</span>,<span class="built_in">sizeof</span>(a));</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=base;i++) a[i][i]=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	Mat <span class="keyword">operator</span> *(<span class="type">const</span> Mat &amp;x) <span class="type">const</span> &#123;</span><br><span class="line">		<span class="type">int</span> i,j,k;Mat ans;<span class="built_in">memset</span>(ans.a,<span class="number">0</span>,<span class="built_in">sizeof</span>(ans.a));</span><br><span class="line">		<span class="keyword">for</span> (k=<span class="number">1</span>;k&lt;=base;k++) &#123;</span><br><span class="line">			<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=base;i++) &#123;</span><br><span class="line">				<span class="keyword">for</span> (j=<span class="number">1</span>;j&lt;=base;j++)</span><br><span class="line">					ans.a[i][j]=(ans.a[i][j]+a[i][k]*x.a[k][j])%mod;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> ans;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;size = %d\n&quot;</span>,base);</span><br><span class="line">		<span class="type">int</span> i,j;</span><br><span class="line">		<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=base;i++,<span class="built_in">put</span>()) <span class="keyword">for</span> (j=<span class="number">1</span>;j&lt;=base;j++) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,a[i][j]);<span class="built_in">put</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;g,pw[<span class="number">61</span>],ans;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">calc</span><span class="params">(<span class="type">int</span> stat)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (stat%<span class="number">10</span>)+(stat/<span class="number">10</span>%<span class="number">10</span>)+(stat/<span class="number">100</span>%<span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">cs</span><span class="params">(<span class="type">int</span> *s)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> s[<span class="number">3</span>]*<span class="number">100</span>+s[<span class="number">2</span>]*<span class="number">10</span>+s[<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> now,<span class="type">int</span> sum)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (now==m+<span class="number">1</span>) &#123;</span><br><span class="line">		<span class="type">int</span> stat=<span class="number">0</span>,i;</span><br><span class="line">		<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=m;i++) stat=stat*<span class="number">10</span>+s[i];		</span><br><span class="line">		<span class="keyword">if</span> (!id[stat]) id[stat]=++cnt,p[cnt]=stat;</span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;=K-sum;i++) s[now]=i,<span class="built_in">dfs</span>(now+<span class="number">1</span>,sum+i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> &amp;x,<span class="type">int</span> y)</span> </span>&#123;x=(x+y)%mod;&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> T,stat,i,j,l,n;</span><br><span class="line">	<span class="built_in">read</span>(T);<span class="built_in">read</span>(m);<span class="built_in">read</span>(K);</span><br><span class="line">	<span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">for</span> (inv[<span class="number">0</span>]=<span class="number">1</span>,i=<span class="number">1</span>;i&lt;=<span class="number">10</span>;i++) inv[i]=<span class="built_in">power</span>(i,mod<span class="number">-2</span>); </span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=cnt;i++) &#123;</span><br><span class="line">		<span class="type">int</span> tmp=p[i];</span><br><span class="line">		s[<span class="number">3</span>]=tmp/<span class="number">100</span>%<span class="number">10</span>,s[<span class="number">2</span>]=tmp/<span class="number">10</span>%<span class="number">10</span>,s[<span class="number">1</span>]=tmp%<span class="number">10</span>;</span><br><span class="line">		<span class="type">int</span> nums=s[<span class="number">1</span>]+s[<span class="number">2</span>]+s[<span class="number">3</span>];</span><br><span class="line">		<span class="keyword">for</span> (j=<span class="number">1</span>;j&lt;=m;j++) <span class="keyword">if</span> (s[j]&gt;<span class="number">0</span>) &#123;</span><br><span class="line">			s[j]--;s[j<span class="number">-1</span>]++;<span class="keyword">if</span> (nums&lt;K&amp;&amp;j&gt;=<span class="number">2</span>) s[m]++;</span><br><span class="line">			stat=<span class="built_in">cs</span>(s);</span><br><span class="line">			s[j]++;s[j<span class="number">-1</span>]--;<span class="keyword">if</span> (nums&lt;K&amp;&amp;j&gt;=<span class="number">2</span>) s[m]--;</span><br><span class="line">			g.a[i][id[stat]]+=(s[j])*<span class="built_in">power</span>(nums+<span class="number">1</span>)%mod;</span><br><span class="line">		&#125;</span><br><span class="line">		stat=<span class="built_in">cs</span>(s);</span><br><span class="line">		<span class="type">int</span> pus=<span class="built_in">power</span>(nums+<span class="number">1</span>);</span><br><span class="line">		g.a[i][id[stat]]+=<span class="built_in">power</span>(nums+<span class="number">1</span>)%mod;</span><br><span class="line">		<span class="built_in">add</span>(g.a[i][cnt+<span class="number">1</span>],<span class="built_in">power</span>(nums+<span class="number">1</span>));</span><br><span class="line">	&#125;</span><br><span class="line">	g.a[cnt+<span class="number">1</span>][cnt+<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">	</span><br><span class="line">	base=cnt+<span class="number">1</span>;</span><br><span class="line">	<span class="type">int</span> now=<span class="number">100</span>;</span><br><span class="line">	<span class="keyword">if</span> (m==<span class="number">1</span>) now=<span class="number">1</span>;<span class="keyword">else</span> <span class="keyword">if</span> (m==<span class="number">2</span>) now=<span class="number">10</span>;</span><br><span class="line">	</span><br><span class="line">	pw[<span class="number">0</span>]=g;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=<span class="number">60</span>;i++) pw[i]=pw[i<span class="number">-1</span>]*pw[i<span class="number">-1</span>];</span><br><span class="line">	<span class="keyword">while</span> (T--) &#123;</span><br><span class="line">		<span class="built_in">read</span>(n);</span><br><span class="line">		<span class="built_in">memset</span>(ans.a,<span class="number">0</span>,<span class="built_in">sizeof</span>(ans.a));</span><br><span class="line">		ans.a[<span class="number">1</span>][id[now]]=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span> (l=<span class="number">60</span>;l&gt;=<span class="number">0</span>;l--) <span class="keyword">if</span> ((n&gt;&gt;l)&amp;<span class="number">1</span>) &#123;</span><br><span class="line">			<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=base;i++) g.a[<span class="number">1</span>][i]=<span class="number">0</span>;</span><br><span class="line">			<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=base;i++)</span><br><span class="line">				<span class="keyword">for</span> (j=<span class="number">1</span>;j&lt;=base;j++) </span><br><span class="line">					<span class="built_in">add</span>(g.a[<span class="number">1</span>][j],ans.a[<span class="number">1</span>][i]*pw[l].a[i][j]);</span><br><span class="line">			<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=base;i++) ans.a[<span class="number">1</span>][i]=g.a[<span class="number">1</span>][i];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans.a[<span class="number">1</span>][base]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>dp</tag>
        <tag>期望</tag>
        <tag>矩阵</tag>
      </tags>
  </entry>
  <entry>
    <title>P4492 [HAOI2018]苹果树</title>
    <url>/2023/03/29/P4492-HAOI2018-%E8%8B%B9%E6%9E%9C%E6%A0%91/</url>
    <content><![CDATA[<p>一个显然的结论就是生成树的个数为 $n!$。</p>
<h2 id="Solution1"><a href="#Solution1" class="headerlink" title="Solution1"></a>Solution1</h2><p>考虑每条边的贡献，连接的两个连通块大小分别为 $i$ 和 $n-i$，贡献为 $i(n-i)$。</p>
<p>对于第 $i$ 个节点，分别考虑子树内的个数和子树外子树。</p>
<h3 id="子树内"><a href="#子树内" class="headerlink" title="子树内"></a>子树内</h3><p>枚举子树大小 $s$。</p>
<p>在 $i$ 子树内的数的大小一定比 $i$ 大，子树大小为 $s$，方案数为 $\dbinom{n-i}{s-1}$。</p>
<p>排列方式有 $s!$，所以总方案数为 $\dbinom{n-i}{s-1}\times s!$。</p>
<h3 id="子树外"><a href="#子树外" class="headerlink" title="子树外"></a>子树外</h3><p>枚举子树大小 $s$。</p>
<p>在 $i$ 之前的数的方案为 $i!$。在剩下 $n-i-s+1$ 个数中，一定不能在子树 $i$ 中。所以方案为 $(i-1)\times i\times …\times (n-s-1)$</p>
<p>两者相乘，答案即为：<br>$$<br>\sum_{i&#x3D;2}^n\sum_{s&#x3D;1}^{n-i+1} s(n-s)\times (n-s-1)!i(i-1)s!\times \dbinom{n-i}{s-1}<br>$$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 2005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> put() putchar(<span class="string">&#x27;\n&#x27;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Tp template<span class="string">&lt;typename Ty&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Ts template<span class="string">&lt;typename Ty,typename... Ar&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(<span class="type">int</span> &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> f=<span class="number">1</span>;x=<span class="number">0</span>;<span class="type">char</span> c=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (c&lt;<span class="string">&#x27;0&#x27;</span>||c&gt;<span class="string">&#x27;9&#x27;</span>) &#123;<span class="keyword">if</span> (c==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">-1</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span> (c&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;c&lt;=<span class="string">&#x27;9&#x27;</span>) &#123;x=x*<span class="number">10</span>+c-<span class="string">&#x27;0&#x27;</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> Debug&#123;</span><br><span class="line">	Tp <span class="type">void</span> _debug(<span class="type">char</span>* f,Ty t)&#123;cerr&lt;&lt;f&lt;&lt;<span class="string">&#x27;=&#x27;</span>&lt;&lt;t&lt;&lt;endl;&#125;</span><br><span class="line">	Ts <span class="type">void</span> _debug(<span class="type">char</span>* f,Ty x,Ar... y)&#123;<span class="keyword">while</span>(*f!=<span class="string">&#x27;,&#x27;</span>) cerr&lt;&lt;*f++;cerr&lt;&lt;<span class="string">&#x27;=&#x27;</span>&lt;&lt;x&lt;&lt;<span class="string">&quot;,&quot;</span>;_debug(f+<span class="number">1</span>,y...);&#125;</span><br><span class="line">	Tp ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; os,vector&lt;Ty&gt;&amp; V)&#123;os&lt;&lt;<span class="string">&quot;[&quot;</span>;<span class="keyword">for</span>(<span class="keyword">auto</span>&amp; vv:V) os&lt;&lt;vv&lt;&lt;<span class="string">&quot;,&quot;</span>;os&lt;&lt;<span class="string">&quot;]&quot;</span>;<span class="keyword">return</span> os;&#125;</span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> gdb(...) _debug((char*)#__VA_ARGS__,__VA_ARGS__)</span></span><br><span class="line">&#125;<span class="keyword">using</span> <span class="keyword">namespace</span> Debug;</span><br><span class="line"><span class="type">int</span> n,mod;</span><br><span class="line"><span class="type">int</span> c[maxn][maxn],g[maxn],f[maxn],suf[maxn];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> &amp;x,<span class="type">int</span> y)</span> </span>&#123;x=(x+y)%mod;&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line"><span class="comment">//  freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);</span></span><br><span class="line">	<span class="type">int</span> i,j;</span><br><span class="line">	<span class="built_in">read</span>(n);<span class="built_in">read</span>(mod);</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		c[i][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span> (j=<span class="number">1</span>;j&lt;=n;j++) c[i][j]=(c[i<span class="number">-1</span>][j<span class="number">-1</span>]+c[i<span class="number">-1</span>][j])%mod;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (suf[<span class="number">0</span>]=<span class="number">1</span>,i=<span class="number">1</span>;i&lt;=n;i++) suf[i]=suf[i<span class="number">-1</span>]*i%mod;</span><br><span class="line">	<span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">2</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (j=<span class="number">1</span>;j&lt;=n-i+<span class="number">1</span>;j++) &#123;</span><br><span class="line">			<span class="built_in">add</span>(ans,j*(n-j)%mod*c[n-i][j<span class="number">-1</span>]%mod*suf[j]%mod*i%mod*(i<span class="number">-1</span>)%mod*suf[n-j<span class="number">-1</span>]%mod);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="Solution2"><a href="#Solution2" class="headerlink" title="Solution2"></a>Solution2</h2><p>另一种想法是考虑两个子树合并。</p>
<p>令 $f_i$ 表示子树大小为 $i$ 时答案，$g_i$ 表示子树到根的距离之和。</p>
<p>不难发现 $f_i$ 的转移依赖于 $g_i$ 。考虑先转移 $g_i$。<br>$$<br>g_i&#x3D;i!(i-1)+\sum\limits_{j&#x3D;0}^{i-1} (g_i\times (n-i-1)!+g_{n-i-1}\times (i!))\dbinom{i-1}{j}<br>$$<br>转移 $f_i$ 可以分为两步。</p>
<ul>
<li>两个子树对根的贡献</li>
<li>两个子树之间的贡献</li>
</ul>
<p>条件 $1$ 已经被解决。 </p>
<p>子树内的贡献 $f_j\times (n-j-1)!+f_{n-j-1}\times j!$</p>
<p>两条边的贡献为 $2\times j\times j!\times (i-j-1)\times (i-j-1)!$</p>
<p>子树之间的贡献为 $g_j\times (n-j-1)!\times (n-j-1)+g_{n-j-1}\times j!\times j$</p>
<p>$$<br>f_i&#x3D;g_i+\sum_{j&#x3D;0}^{i-1}\dbinom{i-1}{j}(f_j\times (n-j-1)!+f_{n-j-1}\times j!+2\times j\times j!\times (i-j-1)\times (i-j-1)!+g_j\times (n-j-1)!\times (n-j-1)+g_{n-j-1}\times j!\times j)<br>$$<br>加起来即可。</p>
]]></content>
      <tags>
        <tag>dp</tag>
        <tag>计数</tag>
      </tags>
  </entry>
  <entry>
    <title>P5327 [ZJOI2019] 语言</title>
    <url>/2023/08/28/P5327-ZJOI2019-%E8%AF%AD%E8%A8%80/</url>
    <content><![CDATA[<h1 id="ZJOI2019-语言"><a href="#ZJOI2019-语言" class="headerlink" title="[ZJOI2019] 语言"></a>[ZJOI2019] 语言</h1><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p><a href="https://www.luogu.com.cn/problem/P5327">https://www.luogu.com.cn/problem/P5327</a></p>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>考虑暴力。在一种语言之中，用树剖分成 $O(\log n)$ 个区间，将每种语言的做 $O(\log n)$ 次区间覆盖。最后统计每个点覆盖了多少个点。除去自己再除 $2$，即为可以互通的个数。</p>
<p><strong>做一堆点相同的操作，考虑差分+线段树合并。</strong></p>
<p>线段树每个节点统计前缀最小值的个数。维护前缀和，前缀最小值，前缀最小值的个数，左右合并时平凡的。</p>
<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 100005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> put() putchar(<span class="string">&#x27;\n&#x27;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Tp template<span class="string">&lt;typename Ty&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Ts template<span class="string">&lt;typename Ty,typename... Ar&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(<span class="type">int</span> &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> f=<span class="number">1</span>;x=<span class="number">0</span>;<span class="type">char</span> c=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (c&lt;<span class="string">&#x27;0&#x27;</span>||c&gt;<span class="string">&#x27;9&#x27;</span>) &#123;<span class="keyword">if</span> (c==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">-1</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span> (c&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;c&lt;=<span class="string">&#x27;9&#x27;</span>) &#123;x=x*<span class="number">10</span>+c-<span class="string">&#x27;0&#x27;</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> Debug&#123;</span><br><span class="line">	Tp <span class="type">void</span> _debug(<span class="type">char</span>* f,Ty t)&#123;cerr&lt;&lt;f&lt;&lt;<span class="string">&#x27;=&#x27;</span>&lt;&lt;t&lt;&lt;endl;&#125;</span><br><span class="line">	Ts <span class="type">void</span> _debug(<span class="type">char</span>* f,Ty x,Ar... y)&#123;<span class="keyword">while</span>(*f!=<span class="string">&#x27;,&#x27;</span>) cerr&lt;&lt;*f++;cerr&lt;&lt;<span class="string">&#x27;=&#x27;</span>&lt;&lt;x&lt;&lt;<span class="string">&quot;,&quot;</span>;_debug(f+<span class="number">1</span>,y...);&#125;</span><br><span class="line">	Tp ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; os,vector&lt;Ty&gt;&amp; V)&#123;os&lt;&lt;<span class="string">&quot;[&quot;</span>;<span class="keyword">for</span>(<span class="keyword">auto</span>&amp; vv:V) os&lt;&lt;vv&lt;&lt;<span class="string">&quot;,&quot;</span>;os&lt;&lt;<span class="string">&quot;]&quot;</span>;<span class="keyword">return</span> os;&#125;</span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> gdb(...) _debug((char*)#__VA_ARGS__,__VA_ARGS__)</span></span><br><span class="line">&#125;<span class="keyword">using</span> <span class="keyword">namespace</span> Debug;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mk make_pair</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">power</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y=mod<span class="number">-2</span>)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> sum=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (y) &#123;</span><br><span class="line">		<span class="keyword">if</span> (y&amp;<span class="number">1</span>) sum=sum*x%mod;</span><br><span class="line">		x=x*x%mod;y&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;to[maxn];</span><br><span class="line"><span class="type">int</span> dfn[maxn],times,son[maxn],siz[maxn],fa[maxn],top[maxn],deep[maxn],p[maxn];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> pre)</span> </span>&#123;</span><br><span class="line">	siz[x]=<span class="number">1</span>;fa[x]=pre;deep[x]=deep[pre]+<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> y:to[x]) <span class="keyword">if</span> (y^pre) &#123;</span><br><span class="line">		<span class="built_in">dfs1</span>(y,x);</span><br><span class="line">		siz[x]+=siz[y];</span><br><span class="line">		<span class="keyword">if</span> (!son[x]||siz[y]&gt;siz[son[x]]) son[x]=y;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> pre,<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line">	top[x]=u;dfn[x]=++times;p[times]=x;</span><br><span class="line">	<span class="keyword">if</span> (!son[x]) <span class="keyword">return</span> ;</span><br><span class="line">	<span class="built_in">dfs2</span>(son[x],x,u);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> y:to[x]) <span class="keyword">if</span> (y!=pre&amp;&amp;y!=son[x]) &#123;</span><br><span class="line">		<span class="built_in">dfs2</span>(y,x,y);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">lca</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (top[x]^top[y]) &#123;</span><br><span class="line">		<span class="keyword">if</span> (deep[top[x]]&lt;deep[top[y]]) <span class="built_in">swap</span>(x,y);</span><br><span class="line">		x=fa[top[x]];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> deep[x]&lt;deep[y]?x:y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> ql[maxn],qr[maxn],cnt,root[maxn];</span><br><span class="line">ll ans;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">query</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">	cnt=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (top[x]^top[y]) &#123;</span><br><span class="line">		<span class="keyword">if</span> (deep[top[x]]&lt;deep[top[y]]) <span class="built_in">swap</span>(x,y);</span><br><span class="line">		++cnt;qr[cnt]=dfn[x],ql[cnt]=dfn[top[x]];</span><br><span class="line">		x=fa[top[x]];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (deep[x]&lt;deep[y]) <span class="built_in">swap</span>(x,y);</span><br><span class="line">	++cnt;ql[cnt]=dfn[y],qr[cnt]=dfn[x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> seg&#123;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">		<span class="type">int</span> ls,rs,Min,sum,suf;</span><br><span class="line">	&#125;f[maxn*<span class="number">400</span>];</span><br><span class="line">	<span class="type">int</span> total;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Pushup</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> mid,<span class="type">int</span> rt)</span> </span>&#123;</span><br><span class="line">		<span class="type">int</span> tmp1,tmp2,tmp3,tmp4,tmp5,tmp6;</span><br><span class="line">		<span class="keyword">if</span> (f[rt].ls) tmp1=f[f[rt].ls].Min,tmp2=f[f[rt].ls].sum,tmp5=f[f[rt].ls].suf;</span><br><span class="line">		<span class="keyword">else</span> tmp1=<span class="number">0</span>,tmp2=(mid-l+<span class="number">1</span>),tmp5=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span> (f[rt].rs) tmp3=f[f[rt].rs].Min,tmp4=f[f[rt].rs].sum,tmp6=f[f[rt].rs].suf;</span><br><span class="line">		<span class="keyword">else</span> tmp3=<span class="number">0</span>,tmp4=r-mid,tmp6=<span class="number">0</span>;</span><br><span class="line">		f[rt].Min=<span class="built_in">min</span>(tmp1,tmp5+tmp3);</span><br><span class="line">		f[rt].suf=tmp5+tmp6;</span><br><span class="line">		<span class="keyword">if</span> (tmp5+tmp3&lt;tmp1) f[rt].sum=tmp4;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (tmp5+tmp3==tmp1) f[rt].sum=tmp2+tmp4;</span><br><span class="line">		<span class="keyword">else</span> f[rt].sum=tmp2;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Update</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> &amp;rt,<span class="type">int</span> head,<span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (!rt) rt=++total,f[rt].Min=<span class="number">0</span>,f[rt].sum=r-l+<span class="number">1</span>,f[rt];</span><br><span class="line">		<span class="keyword">if</span> (l==r) <span class="keyword">return</span> f[rt].Min+=k,f[rt].suf+=k,f[rt].sum=<span class="number">1</span>,<span class="built_in">void</span>();</span><br><span class="line">		<span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span> (head&lt;=mid) <span class="built_in">Update</span>(l,mid,f[rt].ls,head,k);</span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">Update</span>(mid+<span class="number">1</span>,r,f[rt].rs,head,k);</span><br><span class="line">		<span class="built_in">Pushup</span>(l,r,mid,rt);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> &amp;x,<span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (!x||!y) <span class="keyword">return</span> x=x+y,<span class="built_in">void</span>();</span><br><span class="line">		<span class="keyword">if</span> (l==r) <span class="keyword">return</span> f[x].Min+=f[y].Min,f[x].suf+=f[y].suf,f[x].sum=<span class="number">1</span>,<span class="built_in">void</span>();</span><br><span class="line">		<span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">		<span class="built_in">merge</span>(l,mid,f[x].ls,f[y].ls);</span><br><span class="line">		<span class="built_in">merge</span>(mid+<span class="number">1</span>,r,f[x].rs,f[y].rs);</span><br><span class="line">		<span class="built_in">Pushup</span>(l,r,mid,x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> &amp;rt)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (!rt) <span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">&quot;[%d , %d] = %d %d\n&quot;</span>,l,r,<span class="number">0</span>,<span class="number">1</span>),<span class="built_in">void</span>();</span><br><span class="line">		<span class="keyword">if</span> (l==r) <span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">&quot;%d : %d %d\n&quot;</span>,l,f[rt].Min,f[rt].sum),<span class="built_in">void</span>();</span><br><span class="line">		 <span class="built_in">printf</span>(<span class="string">&quot;[%d , %d] = %d %d\n&quot;</span>,l,r,f[rt].Min,f[rt].sum,f[rt].suf);</span><br><span class="line">		<span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">		<span class="built_in">print</span>(l,mid,f[rt].ls);<span class="built_in">print</span>(mid+<span class="number">1</span>,r,f[rt].rs);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> flag)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="keyword">if</span> (!x) <span class="keyword">return</span> ;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=cnt;i++) &#123;</span><br><span class="line">		seg::<span class="built_in">Update</span>(<span class="number">1</span>,n,root[x],ql[i],flag);</span><br><span class="line">		<span class="keyword">if</span> (qr[i]&lt;n) seg::<span class="built_in">Update</span>(<span class="number">1</span>,n,root[x],qr[i]+<span class="number">1</span>,-flag);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> y:to[x]) <span class="keyword">if</span> (y^fa[x]) &#123;</span><br><span class="line">		<span class="built_in">solve</span>(y);</span><br><span class="line">		seg::<span class="built_in">merge</span>(<span class="number">1</span>,n,root[x],root[y]);</span><br><span class="line">	&#125;</span><br><span class="line">	ans+=n-(seg::f[root[x]].Min==<span class="number">0</span>)*seg::f[root[x]].sum<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> i,x,y,g;</span><br><span class="line">	<span class="built_in">read</span>(n);<span class="built_in">read</span>(m);</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n<span class="number">-1</span>;i++) <span class="built_in">read</span>(x),<span class="built_in">read</span>(y),to[x].<span class="built_in">push_back</span>(y),to[y].<span class="built_in">push_back</span>(x);</span><br><span class="line">	<span class="built_in">dfs1</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">dfs2</span>(<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="built_in">query</span>(i,i);</span><br><span class="line">		<span class="built_in">update</span>(i,<span class="number">1</span>);</span><br><span class="line">		<span class="built_in">update</span>(fa[i],<span class="number">-1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=m;i++) &#123;</span><br><span class="line">		<span class="built_in">read</span>(x),<span class="built_in">read</span>(y);g=<span class="built_in">lca</span>(x,y);</span><br><span class="line">		<span class="keyword">if</span> (x==y) <span class="keyword">continue</span>;</span><br><span class="line">		<span class="built_in">query</span>(x,y);</span><br><span class="line">		<span class="built_in">update</span>(x,<span class="number">1</span>);<span class="built_in">update</span>(y,<span class="number">1</span>);<span class="built_in">update</span>(g,<span class="number">-1</span>);<span class="built_in">update</span>(fa[g],<span class="number">-1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">solve</span>(<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,ans/<span class="number">2</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>计数</tag>
        <tag>差分</tag>
        <tag>线段树合并</tag>
      </tags>
  </entry>
  <entry>
    <title>P5492 [PKUWC2018] 随机算法</title>
    <url>/2023/08/28/P5492-PKUWC2018-%E9%9A%8F%E6%9C%BA%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1 id="P5492-PKUWC2018-随机算法"><a href="#P5492-PKUWC2018-随机算法" class="headerlink" title="P5492 [PKUWC2018] 随机算法"></a>P5492 [PKUWC2018] 随机算法</h1><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p><a href="https://www.luogu.com.cn/problem/P5492">https://www.luogu.com.cn/problem/P5492</a></p>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>令 $f_{s,j}$ 表示点集为 $s$，独立集为 $j$ 的方案数。</p>
<p>考虑刷表，令加入一个点 $x$，且一定不在当前的点集 $s$ 之中。$x$ 相邻且不在点集 $s$ 的点，这些可以在 $x$ 选过以后随意选。</p>
<p>令 $g_s$ 表示点集 $s$ 中点的个数，$to_x$ 表示与 $x$ 相邻的点构成的点集。</p>
<p>有转移：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">f[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (s=<span class="number">0</span>;s&lt;N;s++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;n;i++) <span class="keyword">if</span> (((s&gt;&gt;i)&amp;<span class="number">1</span>)==<span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">for</span> (j=<span class="number">0</span>;j&lt;=g[s];j++) &#123;</span><br><span class="line">				<span class="built_in">add</span>(f[s|(<span class="number">1</span>&lt;&lt;i)|to[i]][j+<span class="number">1</span>],<span class="number">1ll</span>*f[s][j]*suf[n-g[s]<span class="number">-1</span>]%mod*isuf[n-g[s]<span class="number">-1</span>-g[to[i]-(to[i]&amp;s)]]%mod);</span><br><span class="line">			&#125;	</span><br><span class="line">		&#125; </span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>复杂度是 $O(2^nn^2)$ ，需要卡卡常。</p>
<p>事实上，一个最大独立集只会从最大独立集转移过来。所以先求出点集 $s$ 的最大独立集 $siz_s$。再进行转移，这样只需要记录 $f_s$ 表示点集 $s$ 构成的最大独立集的方案数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> put() putchar(<span class="string">&#x27;\n&#x27;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Tp template<span class="string">&lt;typename Ty&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Ts template<span class="string">&lt;typename Ty,typename... Ar&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(<span class="type">int</span> &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> f=<span class="number">1</span>;x=<span class="number">0</span>;<span class="type">char</span> c=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (c&lt;<span class="string">&#x27;0&#x27;</span>||c&gt;<span class="string">&#x27;9&#x27;</span>) &#123;<span class="keyword">if</span> (c==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">-1</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span> (c&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;c&lt;=<span class="string">&#x27;9&#x27;</span>) &#123;x=x*<span class="number">10</span>+c-<span class="string">&#x27;0&#x27;</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> Debug&#123;</span><br><span class="line">	Tp <span class="type">void</span> _debug(<span class="type">char</span>* f,Ty t)&#123;cerr&lt;&lt;f&lt;&lt;<span class="string">&#x27;=&#x27;</span>&lt;&lt;t&lt;&lt;endl;&#125;</span><br><span class="line">	Ts <span class="type">void</span> _debug(<span class="type">char</span>* f,Ty x,Ar... y)&#123;<span class="keyword">while</span>(*f!=<span class="string">&#x27;,&#x27;</span>) cerr&lt;&lt;*f++;cerr&lt;&lt;<span class="string">&#x27;=&#x27;</span>&lt;&lt;x&lt;&lt;<span class="string">&quot;,&quot;</span>;_debug(f+<span class="number">1</span>,y...);&#125;</span><br><span class="line">	Tp ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; os,vector&lt;Ty&gt;&amp; V)&#123;os&lt;&lt;<span class="string">&quot;[&quot;</span>;<span class="keyword">for</span>(<span class="keyword">auto</span>&amp; vv:V) os&lt;&lt;vv&lt;&lt;<span class="string">&quot;,&quot;</span>;os&lt;&lt;<span class="string">&quot;]&quot;</span>;<span class="keyword">return</span> os;&#125;</span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> gdb(...) _debug((char*)#__VA_ARGS__,__VA_ARGS__)</span></span><br><span class="line">&#125;<span class="keyword">using</span> <span class="keyword">namespace</span> Debug;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mk make_pair</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">998244353</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">power</span><span class="params">(ll x,<span class="type">int</span> y=mod<span class="number">-2</span>)</span> </span>&#123;</span><br><span class="line">	ll sum=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (y) &#123;</span><br><span class="line">		<span class="keyword">if</span> (y&amp;<span class="number">1</span>) sum=sum*x%mod;</span><br><span class="line">		x=x*x%mod;y&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> f[(<span class="number">1</span>&lt;&lt;<span class="number">20</span>)+<span class="number">5</span>],siz[(<span class="number">1</span>&lt;&lt;<span class="number">20</span>)+<span class="number">5</span>];</span><br><span class="line"><span class="type">int</span> to[<span class="number">21</span>],g[(<span class="number">1</span>&lt;&lt;<span class="number">20</span>)+<span class="number">5</span>];</span><br><span class="line">ll suf[<span class="number">21</span>],isuf[<span class="number">21</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> &amp;x,ll y)</span> </span>&#123;x=(x+y)%mod;&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> i,j,x,y,s;</span><br><span class="line">	<span class="built_in">read</span>(n);<span class="built_in">read</span>(m);</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=m;i++) &#123;</span><br><span class="line">		<span class="built_in">read</span>(x),<span class="built_in">read</span>(y);x--,y--;</span><br><span class="line">		to[x]|=(<span class="number">1</span>&lt;&lt;y);</span><br><span class="line">		to[y]|=(<span class="number">1</span>&lt;&lt;x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> N=<span class="number">1</span>&lt;&lt;n;</span><br><span class="line">	<span class="keyword">for</span> (s=<span class="number">0</span>;s&lt;N;s++) g[s]=__builtin_popcount(s);</span><br><span class="line">	suf[<span class="number">0</span>]=<span class="number">1</span>;<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) suf[i]=suf[i<span class="number">-1</span>]*i%mod;</span><br><span class="line">	isuf[n]=<span class="built_in">power</span>(suf[n]);<span class="keyword">for</span> (i=n;i&gt;=<span class="number">1</span>;i--) isuf[i<span class="number">-1</span>]=isuf[i]*i%mod;</span><br><span class="line">	<span class="keyword">for</span> (s=<span class="number">0</span>;s&lt;N;s++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;n;i++) <span class="keyword">if</span> (((s&gt;&gt;i)&amp;<span class="number">1</span>)==<span class="number">0</span>) &#123;</span><br><span class="line">			siz[s|(<span class="number">1</span>&lt;&lt;i)|to[i]]=<span class="built_in">max</span>(siz[s|(<span class="number">1</span>&lt;&lt;i)|to[i]],siz[s]+<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;<span class="comment">//求出最大独立集</span></span><br><span class="line">	f[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (s=<span class="number">0</span>;s&lt;N;s++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;n;i++) <span class="keyword">if</span> (((s&gt;&gt;i)&amp;<span class="number">1</span>)==<span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (siz[s|(<span class="number">1</span>&lt;&lt;i)|to[i]]==siz[s]+<span class="number">1</span>)<span class="comment">//强制从一个最大独立集转移到另外一个最大独立集</span></span><br><span class="line">				<span class="built_in">add</span>(f[s|(<span class="number">1</span>&lt;&lt;i)|to[i]],<span class="number">1ll</span>*f[s]*suf[n-g[s]<span class="number">-1</span>]%mod*isuf[n-g[s]<span class="number">-1</span>-g[to[i]-(to[i]&amp;s)]]%mod);</span><br><span class="line">		&#125; </span><br><span class="line">	&#125;</span><br><span class="line">	ll is=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) is=<span class="number">1ll</span>*is*i%mod;is=<span class="built_in">power</span>(is);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,<span class="number">1ll</span>*f[N<span class="number">-1</span>]*is%mod);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>复杂度 $O(2^nn)$，可以稳稳通过。</p>
]]></content>
      <tags>
        <tag>dp</tag>
        <tag>计数</tag>
      </tags>
  </entry>
  <entry>
    <title>P6405 [COCI2014-2015#2] ŠUMA</title>
    <url>/2022/10/17/P6405-COCI2014-2015-2-SUMA/</url>
    <content><![CDATA[<p><a href="https://wgyhm.cf/2022/10/17/P6405-COCI2014-2015-2-SUMA/">BLOG</a></p>
<p>相邻两棵树的关系是以下几种之一：</p>
<ul>
<li>$h_i&#x3D;h_j,v_i&#x3D;v_j$ 永远相等，我们称为 <strong>万能边</strong></li>
<li>$h_i&#x3D;h_j,v_i\not &#x3D; v_j$ 永远不相等。</li>
<li>$t&#x3D;\dfrac{h_i-h_j}{v_j-v_i}$，两棵树当且仅当在时刻 $t$ 时相等。如果时刻 $t&lt;0$ ，那么永远不相等。否则，我们把两棵树的边权设为 $t$。</li>
</ul>
<p>我们把万能边用并查集缩成一个点，并重新建图。然后把所有的两个数相等的时刻 $t$ 离散化，方便枚举。</p>
<p>枚举时刻 $t$，将所有边权为 $t$ 的两个点合并。并判断最大的连通块。</p>
<p>每个非万能边最多枚举一次。万能边已经缩没了。所以复杂度时 $O(cn^2)$，其中 $c$ 是并查集的复杂度。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 705</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> put() putchar(<span class="string">&#x27;\n&#x27;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Tp template<span class="string">&lt;typename Ty&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Ts template<span class="string">&lt;typename Ty,typename... Ar&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(<span class="type">int</span> &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> f=<span class="number">1</span>;x=<span class="number">0</span>;<span class="type">char</span> c=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (c&lt;<span class="string">&#x27;0&#x27;</span>||c&gt;<span class="string">&#x27;9&#x27;</span>) &#123;<span class="keyword">if</span> (c==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">-1</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span> (c&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;c&lt;=<span class="string">&#x27;9&#x27;</span>) &#123;x=x*<span class="number">10</span>+c-<span class="string">&#x27;0&#x27;</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> Debug&#123;</span><br><span class="line">	Tp <span class="type">void</span> _debug(<span class="type">char</span>* f,Ty t)&#123;cerr&lt;&lt;f&lt;&lt;<span class="string">&#x27;=&#x27;</span>&lt;&lt;t&lt;&lt;endl;&#125;</span><br><span class="line">	Ts <span class="type">void</span> _debug(<span class="type">char</span>* f,Ty x,Ar... y)&#123;<span class="keyword">while</span>(*f!=<span class="string">&#x27;,&#x27;</span>) cerr&lt;&lt;*f++;cerr&lt;&lt;<span class="string">&#x27;=&#x27;</span>&lt;&lt;x&lt;&lt;<span class="string">&quot;,&quot;</span>;_debug(f+<span class="number">1</span>,y...);&#125;</span><br><span class="line">	Tp ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; os,vector&lt;Ty&gt;&amp; V)&#123;os&lt;&lt;<span class="string">&quot;[&quot;</span>;<span class="keyword">for</span>(<span class="keyword">auto</span>&amp; vv:V) os&lt;&lt;vv&lt;&lt;<span class="string">&quot;,&quot;</span>;os&lt;&lt;<span class="string">&quot;]&quot;</span>;<span class="keyword">return</span> os;&#125;</span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> gdb(...) _debug(#__VA_ARGS__,__VA_ARGS__)</span></span><br><span class="line">&#125;<span class="keyword">using</span> <span class="keyword">namespace</span> Debug;</span><br><span class="line"><span class="type">int</span> h[maxn][maxn],v[maxn][maxn],n,m;</span><br><span class="line"><span class="type">int</span> he[maxn*maxn],head=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">yyy</span>&#123;</span><br><span class="line">	<span class="type">int</span> to,z,wx,wy;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> val,<span class="type">int</span> vall)</span> </span>&#123;</span><br><span class="line">		to=y;z=he[x];he[x]=head;wx=val;wy=vall;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;a[maxn*maxn*<span class="number">8</span>];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edges</span> &#123;</span><br><span class="line">	<span class="type">int</span> x,y;</span><br><span class="line">	<span class="built_in">edges</span>(<span class="type">int</span> a=<span class="number">0</span>,<span class="type">int</span> b=<span class="number">0</span>) &#123;x=a;y=b;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> fx[<span class="number">5</span>]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int</span> fy[<span class="number">5</span>]=&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>&#125;;</span><br><span class="line">vector&lt;edges&gt;e[maxn*maxn];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">id</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span> </span>&#123;<span class="keyword">return</span> (x<span class="number">-1</span>)*n+y;&#125;</span><br><span class="line"><span class="type">int</span> size[maxn*maxn],fa[maxn*maxn],vis[maxn*maxn],nsize[maxn*maxn],tr[maxn*maxn];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">getfa</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;<span class="keyword">return</span> x==fa[x]?x:fa[x]=<span class="built_in">getfa</span>(fa[x]);&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">	x=<span class="built_in">getfa</span>(x),y=<span class="built_in">getfa</span>(y);</span><br><span class="line">	<span class="keyword">if</span> (x^y) fa[x]=y,size[y]+=size[x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> cur)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> i;vis[x]=<span class="number">1</span>,<span class="built_in">merge</span>(x,cur);</span><br><span class="line">	<span class="keyword">for</span> (i=he[x];i;i=a[i].z) <span class="keyword">if</span> (a[i].wx==<span class="number">-1</span>&amp;&amp;a[i].wy==<span class="number">-1</span>&amp;&amp;!vis[a[i].to]) <span class="built_in">dfs</span>(a[i].to,cur);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> tot,ans;</span><br><span class="line">ll g[maxn*maxn*<span class="number">4</span>];</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> base=<span class="number">1e6</span>;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> i,j,k,x,y,gg;</span><br><span class="line">	<span class="built_in">read</span>(n);</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) <span class="keyword">for</span> (j=<span class="number">1</span>;j&lt;=n;j++) <span class="built_in">read</span>(h[i][j]);</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) <span class="keyword">for</span> (j=<span class="number">1</span>;j&lt;=n;j++) <span class="built_in">read</span>(v[i][j]);</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (j=<span class="number">1</span>;j&lt;=n;j++) &#123;</span><br><span class="line">			<span class="keyword">for</span> (k=<span class="number">1</span>;k&lt;=<span class="number">4</span>;k++) &#123;</span><br><span class="line">				x=i+fx[k],y=j+fy[k];</span><br><span class="line">				<span class="keyword">if</span> (x&gt;=<span class="number">1</span>&amp;&amp;x&lt;=n&amp;&amp;y&gt;=<span class="number">1</span>&amp;&amp;y&lt;=n) ;<span class="keyword">else</span> <span class="keyword">continue</span>;</span><br><span class="line">				<span class="keyword">if</span> (v[i][j]==v[x][y]) &#123;</span><br><span class="line">					<span class="keyword">if</span> (h[i][j]==h[x][y]) a[++head].<span class="built_in">add</span>(<span class="built_in">id</span>(i,j),<span class="built_in">id</span>(x,y),<span class="number">-1</span>,<span class="number">-1</span>);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">if</span> (h[i][j]==h[x][y]) a[++head].<span class="built_in">add</span>(<span class="built_in">id</span>(i,j),<span class="built_in">id</span>(x,y),<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">				<span class="keyword">else</span> &#123;</span><br><span class="line">					<span class="type">int</span> tmpy=h[x][y]-h[i][j],tmpx=v[i][j]-v[x][y];</span><br><span class="line">					<span class="keyword">if</span> (<span class="number">1ll</span>*tmpx*tmpy&lt;<span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">					tmpy=<span class="built_in">abs</span>(tmpy),tmpx=<span class="built_in">abs</span>(tmpx);gg=__gcd(tmpx,tmpy);</span><br><span class="line">					a[++head].<span class="built_in">add</span>(<span class="built_in">id</span>(i,j),<span class="built_in">id</span>(x,y),tmpy/gg,tmpx/gg);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) <span class="keyword">for</span> (j=<span class="number">1</span>;j&lt;=n;j++) size[<span class="built_in">id</span>(i,j)]=<span class="number">1</span>,fa[<span class="built_in">id</span>(i,j)]=<span class="built_in">id</span>(i,j);</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) <span class="keyword">for</span> (j=<span class="number">1</span>;j&lt;=n;j++) <span class="keyword">if</span> (!vis[<span class="built_in">id</span>(i,j)]) <span class="built_in">dfs</span>(<span class="built_in">id</span>(i,j),<span class="built_in">id</span>(i,j));<span class="comment">//,gdb(i,j,size[getfa(id(i,j))]);</span></span><br><span class="line">	<span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) <span class="keyword">for</span> (j=<span class="number">1</span>;j&lt;=n;j++) <span class="keyword">if</span> (fa[<span class="built_in">id</span>(i,j)]==<span class="built_in">id</span>(i,j)) tr[<span class="built_in">id</span>(i,j)]=++cnt,nsize[cnt]=size[<span class="built_in">id</span>(i,j)];<span class="comment">//,gdb(i,j,cnt,nsize[cnt]);</span></span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (j=<span class="number">1</span>;j&lt;=n;j++) &#123;</span><br><span class="line">			<span class="type">int</span> pus=<span class="built_in">getfa</span>(<span class="built_in">id</span>(i,j));</span><br><span class="line">			<span class="keyword">for</span> (k=he[pus];k;k=a[k].z) &#123;</span><br><span class="line">				<span class="type">int</span> now=<span class="built_in">getfa</span>(a[k].to);</span><br><span class="line">				<span class="keyword">if</span> (tr[now]!=tr[pus])<span class="built_in">assert</span>(a[k].wx!=<span class="number">-1</span>),g[++tot]=<span class="number">1ll</span>*a[k].wx*base+a[k].wy;</span><br><span class="line">			&#125; </span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">sort</span>(g+<span class="number">1</span>,g+<span class="number">1</span>+tot);</span><br><span class="line">	tot=<span class="built_in">unique</span>(g+<span class="number">1</span>,g+<span class="number">1</span>+tot)-g<span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (j=<span class="number">1</span>;j&lt;=n;j++) &#123;</span><br><span class="line">			<span class="type">int</span> pus=<span class="built_in">getfa</span>(<span class="built_in">id</span>(i,j));</span><br><span class="line">			<span class="keyword">for</span> (k=he[pus];k;k=a[k].z) &#123;</span><br><span class="line">				<span class="type">int</span> now=<span class="built_in">getfa</span>(a[k].to);</span><br><span class="line">				<span class="keyword">if</span> (tr[now]!=tr[pus]) &#123;</span><br><span class="line">					<span class="type">int</span> w=<span class="built_in">lower_bound</span>(g+<span class="number">1</span>,g+<span class="number">1</span>+tot,<span class="number">1ll</span>*a[k].wx*base+a[k].wy)-g;</span><br><span class="line">					e[w].<span class="built_in">push_back</span>(<span class="built_in">edges</span>(tr[pus],tr[now]));</span><br><span class="line">				&#125;</span><br><span class="line">			&#125; </span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=cnt;i++) fa[i]=i,size[i]=nsize[i];</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=tot;i++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> tmp:e[i]) &#123;</span><br><span class="line">			<span class="built_in">merge</span>(tmp.x,tmp.y);</span><br><span class="line">			ans=<span class="built_in">max</span>(ans,size[<span class="built_in">getfa</span>(tmp.x)]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> tmp:e[i]) fa[tmp.x]=tmp.x,size[tmp.x]=nsize[tmp.x],fa[tmp.y]=tmp.y,size[tmp.y]=nsize[tmp.y];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title>P6620 [省选联考 2020]组合数问题</title>
    <url>/2023/03/21/P6620-%E7%9C%81%E9%80%89%E8%81%94%E8%80%83-2020-%E7%BB%84%E5%90%88%E6%95%B0%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>$$<br>\left(\sum_{k&#x3D;0}^{n}f(k)\times x^k\times \binom{n}{k}\right)\bmod p<br>$$</p>
<p>的值。其中 $n$, $x$, $p$ 为给定的整数，$f(k)$ 为给定的一个 $m$ 次多项式 $f(k) &#x3D; a_0 + a_1k + a_2k^2 + \cdots + a_mk^m$。$\binom{n}{k}$ 为组合数，其值为 $\binom{n}{k} &#x3D; \frac{n!}{k!(n-k)!}$。</p>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>手玩。</p>
<p>考虑 $m&#x3D;0$ 的情况。<br>$$<br>a_0\left(\sum_{k&#x3D;0}^{n}x^k\times \binom{n}{k}\right)\bmod p&#x3D;(a_0(x+1)^{n}) \bmod p<br>$$<br>然后考虑 $m&#x3D;1$ 的情况。<br>$$<br>a_1\left(\sum_{k&#x3D;0}^{n}k\times x^k\times \binom{n}{k}\right)\bmod p<br>$$</p>
<p>$$<br>&#x3D;a_1\left(\sum_{k&#x3D;0}^{n}k\times x^k\times \dfrac{n!}{k!(n-k)!}\right)\bmod p<br>$$</p>
<p>$$<br>&#x3D;a_1\left(\sum_{k&#x3D;0}^{n}x^k\times \dfrac{n!}{k!(n-k-1)!}\right)\bmod p<br>$$</p>
<p>$$<br>&#x3D;a_1\times n\left(\sum_{k&#x3D;1}^{n}x^k\times \dfrac{(n-1)!}{k!(n-k-1)!}\right)\bmod p<br>$$</p>
<p>$$<br>&#x3D;a_1\times n\times x\left(\sum_{k&#x3D;0}^{n}x^k\times \binom{n-1}{k}\right)\bmod p<br>$$</p>
<p>不难发现这是二项式定理的形式。<br>$$<br>&#x3D;a_1\times n\times x\times (x+1)^{n}\bmod p&#x3D;a_1\times g_n(1)<br>$$<br>同样，考虑 $m&#x3D;2$ 的情况：<br>$$<br>a_2\left(\sum_{k&#x3D;0}^{n}k^2\times x^k\times \binom{n}{k}\right)\bmod p<br>$$</p>
<p>$$<br>&#x3D;a_2\left(\sum_{k&#x3D;0}^{n}k\times x\times \binom{n}{k}+\sum_{k&#x3D;0}^n k(k-1)\times x\times \binom{n}{k}\right)\bmod p<br>$$</p>
<p>$$<br>&#x3D;a_2\times g_n(1)+a_2\times n(n-1)x^2\times (x+1)^{n-1}&#x3D;a_2(g_n(1)+g_n(2))<br>$$</p>
<p>关于 $g_n$ 的递推是显然。现在我们需要找到关于 $n^k&#x3D;\sum\limits_{i&#x3D;1}^k b_{k,i} \dfrac{n!}{(n-i)!}$ 的系数 $b$。这个是可以 $O(m^2)$ 递推的。</p>
<p>总复杂度 $O(m+m^2)$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 1005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> put() putchar(<span class="string">&#x27;\n&#x27;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Tp template<span class="string">&lt;typename Ty&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Ts template<span class="string">&lt;typename Ty,typename... Ar&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(<span class="type">int</span> &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> f=<span class="number">1</span>;x=<span class="number">0</span>;<span class="type">char</span> c=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (c&lt;<span class="string">&#x27;0&#x27;</span>||c&gt;<span class="string">&#x27;9&#x27;</span>) &#123;<span class="keyword">if</span> (c==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">-1</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span> (c&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;c&lt;=<span class="string">&#x27;9&#x27;</span>) &#123;x=x*<span class="number">10</span>+c-<span class="string">&#x27;0&#x27;</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> Debug&#123;</span><br><span class="line">	Tp <span class="type">void</span> _debug(<span class="type">char</span>* f,Ty t)&#123;cerr&lt;&lt;f&lt;&lt;<span class="string">&#x27;=&#x27;</span>&lt;&lt;t&lt;&lt;endl;&#125;</span><br><span class="line">	Ts <span class="type">void</span> _debug(<span class="type">char</span>* f,Ty x,Ar... y)&#123;<span class="keyword">while</span>(*f!=<span class="string">&#x27;,&#x27;</span>) cerr&lt;&lt;*f++;cerr&lt;&lt;<span class="string">&#x27;=&#x27;</span>&lt;&lt;x&lt;&lt;<span class="string">&quot;,&quot;</span>;_debug(f+<span class="number">1</span>,y...);&#125;</span><br><span class="line">	Tp ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; os,vector&lt;Ty&gt;&amp; V)&#123;os&lt;&lt;<span class="string">&quot;[&quot;</span>;<span class="keyword">for</span>(<span class="keyword">auto</span>&amp; vv:V) os&lt;&lt;vv&lt;&lt;<span class="string">&quot;,&quot;</span>;os&lt;&lt;<span class="string">&quot;]&quot;</span>;<span class="keyword">return</span> os;&#125;</span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> gdb(...) _debug((char*)#__VA_ARGS__,__VA_ARGS__)</span></span><br><span class="line">&#125;<span class="keyword">using</span> <span class="keyword">namespace</span> Debug;</span><br><span class="line"><span class="type">int</span> g[maxn],n,x,mod,m,a[maxn];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">power</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> sum=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (y) &#123;</span><br><span class="line">		<span class="keyword">if</span> (y&amp;<span class="number">1</span>) sum=sum*x%mod;</span><br><span class="line">		x=x*x%mod;y&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> ans,b[maxn][maxn],f[maxn];</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> i,j,sum1,sum2;</span><br><span class="line">	<span class="built_in">read</span>(n);<span class="built_in">read</span>(x);<span class="built_in">read</span>(mod);<span class="built_in">read</span>(m);</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;=m;i++) <span class="built_in">read</span>(a[i]);</span><br><span class="line">	sum1=<span class="number">1</span>,sum2=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;=m;i++) &#123;</span><br><span class="line">		g[i]=sum1*sum2%mod*<span class="built_in">power</span>(x+<span class="number">1</span>,n-i)%mod;</span><br><span class="line">		sum1=sum1*x%mod;sum2=sum2*(n-i)%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//预处理</span></span><br><span class="line">    <span class="comment">//其实可以不需要快速幂</span></span><br><span class="line">	f[<span class="number">0</span>]=g[<span class="number">0</span>];b[<span class="number">1</span>][<span class="number">1</span>]=<span class="number">1</span>;f[<span class="number">1</span>]=g[<span class="number">1</span>];</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">2</span>;i&lt;=m;i++) &#123;</span><br><span class="line">		b[i][<span class="number">1</span>]=(-b[i<span class="number">-1</span>][<span class="number">1</span>]*(i<span class="number">-1</span>)%mod+mod)%mod;</span><br><span class="line">		<span class="keyword">for</span> (j=<span class="number">1</span>;j&lt;i;j++) &#123;</span><br><span class="line">			b[i][j+<span class="number">1</span>]=(b[i<span class="number">-1</span>][j]-b[i<span class="number">-1</span>][j+<span class="number">1</span>]*(i<span class="number">-1</span>)%mod+mod)%mod;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (j=<span class="number">1</span>;j&lt;i;j++) f[i]=(f[i]+f[j]*(-b[i][j])%mod+mod)%mod;</span><br><span class="line">		f[i]=(f[i]+g[i])%mod;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//计算系数 b</span></span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;=m;i++) ans=(ans+f[i]*a[i])%mod;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>数学</tag>
        <tag>省选</tag>
        <tag>组合数</tag>
      </tags>
  </entry>
  <entry>
    <title>P6624 [省选联考 2020 a 卷] 作业题</title>
    <url>/2023/05/07/P6624-%E7%9C%81%E9%80%89%E8%81%94%E8%80%83-2020-A-%E5%8D%B7-%E4%BD%9C%E4%B8%9A%E9%A2%98/</url>
    <content><![CDATA[<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>感觉这个要求的形式很矩阵树，考虑矩阵树定理。</p>
<p>答案是加和的形式，不能直接矩阵树。考虑求对于每条边的贡献。</p>
<p>令当前枚举的边的编号为 $i$ 。枚举 $w_i$ 的因数 $d$ ，钦定所有边权的 $\gcd$ 的值必须是 $d$ 的倍数。用两遍矩阵树定理算加上和不加上这条边产生的生成树的个数，之差即为这条边的贡献。不妨设 $g_d$ 表示所有边权的 $\gcd$ 的值必须是 $d$ 的倍数的这条边的贡献。同样的，设 $f_d$ 为所有边权的 $\gcd$ 的值<strong>为 $d$ ** 的个数。</strong>注意到 $g$ 和 $f$ 都是对于枚举的这条边 $i$ 来说的。**</p>
<p>现在有关系<br>$$<br>g_i&#x3D;\sum_{i|d} f_d<br>$$<br> 要求的即为<br>$$<br>ans&#x3D;\sum_{i&#x3D;1}^n f_i\times i<br>$$<br>考虑反演：<br>$$<br>f_i&#x3D;\sum_{d|i} \mu(\dfrac{d}{i})g_d<br>$$<br>其实好像可以直接算，但是为了回忆一下反演。考虑继续化简：<br>$$<br>ans&#x3D;\sum\limits_{i&#x3D;1}^nf_i\times i&#x3D;\sum_{i&#x3D;1}^ni\sum_{d|i} \mu(\dfrac{d}{i})g_d<br>$$</p>
<p>$$<br>&#x3D;\sum_{d&#x3D;1}^ng_d\sum_{d|i}i\mu(\dfrac{d}{i})&#x3D;\sum_{d&#x3D;1}^n\varphi(d) g_d<br>$$</p>
<p>每次处理出每条边的 $g$，即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 35</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> put() putchar(<span class="string">&#x27;\n&#x27;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Tp template<span class="string">&lt;typename Ty&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Ts template<span class="string">&lt;typename Ty,typename... Ar&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(<span class="type">int</span> &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> f=<span class="number">1</span>;x=<span class="number">0</span>;<span class="type">char</span> c=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (c&lt;<span class="string">&#x27;0&#x27;</span>||c&gt;<span class="string">&#x27;9&#x27;</span>) &#123;<span class="keyword">if</span> (c==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">-1</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span> (c&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;c&lt;=<span class="string">&#x27;9&#x27;</span>) &#123;x=x*<span class="number">10</span>+c-<span class="string">&#x27;0&#x27;</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> Debug&#123;</span><br><span class="line">	Tp <span class="type">void</span> _debug(<span class="type">char</span>* f,Ty t)&#123;cerr&lt;&lt;f&lt;&lt;<span class="string">&#x27;=&#x27;</span>&lt;&lt;t&lt;&lt;endl;&#125;</span><br><span class="line">	Ts <span class="type">void</span> _debug(<span class="type">char</span>* f,Ty x,Ar... y)&#123;<span class="keyword">while</span>(*f!=<span class="string">&#x27;,&#x27;</span>) cerr&lt;&lt;*f++;cerr&lt;&lt;<span class="string">&#x27;=&#x27;</span>&lt;&lt;x&lt;&lt;<span class="string">&quot;,&quot;</span>;_debug(f+<span class="number">1</span>,y...);&#125;</span><br><span class="line">	Tp ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; os,vector&lt;Ty&gt;&amp; V)&#123;os&lt;&lt;<span class="string">&quot;[&quot;</span>;<span class="keyword">for</span>(<span class="keyword">auto</span>&amp; vv:V) os&lt;&lt;vv&lt;&lt;<span class="string">&quot;,&quot;</span>;os&lt;&lt;<span class="string">&quot;]&quot;</span>;<span class="keyword">return</span> os;&#125;</span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> gdb(...) _debug((char*)#__VA_ARGS__,__VA_ARGS__)</span></span><br><span class="line">&#125;<span class="keyword">using</span> <span class="keyword">namespace</span> Debug;</span><br><span class="line"><span class="type">int</span> a[maxn][maxn],n,m;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">	<span class="type">int</span> x,y,z,id;</span><br><span class="line">&#125;e[maxn*maxn],h[maxn*maxn];</span><br><span class="line"><span class="type">int</span> g[<span class="number">100005</span>],ans,rt[<span class="number">100005</span>];</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">998244353</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">power</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> ans=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (y) &#123;</span><br><span class="line">		<span class="keyword">if</span> (y&amp;<span class="number">1</span>) ans=ans*x%mod;</span><br><span class="line">		x=x*x%mod;y&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">calc</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> i,j,k,sum=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="type">int</span> inv=<span class="built_in">power</span>(a[i][i],mod<span class="number">-2</span>); </span><br><span class="line">		<span class="keyword">if</span> (!a[i][i]) &#123;</span><br><span class="line">			<span class="keyword">for</span> (j=i+<span class="number">1</span>;j&lt;=n;j++) <span class="keyword">if</span> (a[j][i]) &#123;</span><br><span class="line">				<span class="built_in">swap</span>(a[i],a[j]);sum*=<span class="number">-1</span>;<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (j=i+<span class="number">1</span>;j&lt;=n;j++) &#123;</span><br><span class="line">			<span class="type">int</span> tmp=a[j][i]*inv%mod;</span><br><span class="line">			<span class="keyword">for</span> (k=i;k&lt;=n;k++) &#123;</span><br><span class="line">				a[j][k]=(a[j][k]-a[i][k]*tmp%mod+mod)%mod;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	sum=(sum+mod)%mod;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) sum=sum*a[i][i]%mod;</span><br><span class="line">	<span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> prime[<span class="number">200005</span>],cnt,fi[<span class="number">200005</span>],vis[<span class="number">200005</span>],f[<span class="number">200005</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">getprime</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">	vis[<span class="number">1</span>]=<span class="number">1</span>;fi[<span class="number">1</span>]=<span class="number">1</span>;<span class="type">int</span> i,j;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">2</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!vis[i]) prime[++cnt]=i,fi[i]=i<span class="number">-1</span>;</span><br><span class="line">		<span class="keyword">for</span> (j=<span class="number">1</span>;j&lt;=cnt&amp;&amp;prime[j]*i&lt;=n;j++) &#123;</span><br><span class="line">			vis[prime[j]*i]=<span class="number">1</span>,fi[prime[j]*i]=fi[i]*(prime[j]<span class="number">-1</span>);</span><br><span class="line">			<span class="keyword">if</span> (i%prime[j]==<span class="number">0</span>) &#123;fi[i*prime[j]]=fi[i]*prime[j];<span class="keyword">break</span>;&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> i,j,tot,k,l;</span><br><span class="line">	<span class="built_in">read</span>(n);<span class="built_in">read</span>(m);</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=m;i++) &#123;</span><br><span class="line">		<span class="built_in">read</span>(e[i].x),<span class="built_in">read</span>(e[i].y),<span class="built_in">read</span>(e[i].z);e[i].id=i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">getprime</span>(<span class="number">200000</span>);</span><br><span class="line">	<span class="keyword">for</span> (l=<span class="number">1</span>;l&lt;=m;l++) &#123;</span><br><span class="line">		tot=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (j=<span class="number">1</span>;j*j&lt;=e[l].z;j++) <span class="keyword">if</span> (e[l].z%j==<span class="number">0</span>) &#123;rt[++tot]=j,rt[++tot]=e[l].z/j;&#125;</span><br><span class="line">		<span class="built_in">sort</span>(rt+<span class="number">1</span>,rt+<span class="number">1</span>+tot);tot=<span class="built_in">unique</span>(rt+<span class="number">1</span>,rt+<span class="number">1</span>+tot)-rt<span class="number">-1</span>;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span> (i=tot;i&gt;=<span class="number">1</span>;i--) &#123;</span><br><span class="line">			tot=<span class="number">0</span>;</span><br><span class="line">			<span class="keyword">for</span> (j=<span class="number">1</span>;j&lt;=m;j++) <span class="keyword">if</span> (e[j].z%rt[i]==<span class="number">0</span>) h[++tot]=e[j];</span><br><span class="line">			<span class="keyword">if</span> (tot&lt;n<span class="number">-1</span>) <span class="keyword">continue</span>; <span class="comment">//显然只选边数&gt;=n-1的跑，否则没有贡献</span></span><br><span class="line">			<span class="built_in">memset</span>(a,<span class="number">0</span>,<span class="built_in">sizeof</span>(a));</span><br><span class="line">			<span class="keyword">for</span> (j=<span class="number">1</span>;j&lt;=tot;j++) a[h[j].x][h[j].y]-=<span class="number">1</span>,a[h[j].y][h[j].x]-=<span class="number">1</span>,a[h[j].x][h[j].x]+=<span class="number">1</span>,a[h[j].y][h[j].y]+=<span class="number">1</span>;</span><br><span class="line">			<span class="keyword">for</span> (k=<span class="number">1</span>;k&lt;=n;k++) <span class="keyword">for</span> (j=<span class="number">1</span>;j&lt;=n;j++) a[k][j]=(a[k][j]%mod+mod)%mod;</span><br><span class="line">			<span class="type">int</span> sum1=<span class="built_in">calc</span>(n<span class="number">-1</span>);</span><br><span class="line">			</span><br><span class="line">			<span class="built_in">memset</span>(a,<span class="number">0</span>,<span class="built_in">sizeof</span>(a));</span><br><span class="line">			<span class="keyword">for</span> (j=<span class="number">1</span>;j&lt;=tot;j++) a[h[j].x][h[j].y]-=<span class="number">1</span>,a[h[j].y][h[j].x]-=<span class="number">1</span>,a[h[j].x][h[j].x]+=<span class="number">1</span>,a[h[j].y][h[j].y]+=<span class="number">1</span>;</span><br><span class="line">			a[e[l].x][e[l].y]+=<span class="number">1</span>,a[e[l].y][e[l].x]+=<span class="number">1</span>,a[e[l].x][e[l].x]-=<span class="number">1</span>,a[e[l].y][e[l].y]-=<span class="number">1</span>;</span><br><span class="line">			<span class="keyword">for</span> (k=<span class="number">1</span>;k&lt;=n;k++) <span class="keyword">for</span> (j=<span class="number">1</span>;j&lt;=n;j++) a[k][j]=(a[k][j]%mod+mod)%mod;</span><br><span class="line">			<span class="type">int</span> sum2=<span class="built_in">calc</span>(n<span class="number">-1</span>);</span><br><span class="line"><span class="comment">//			gdb(e[l].x,e[l].y,e[l].z,fi[i],rt[i],sum1,sum2);</span></span><br><span class="line">			ans=(ans+(sum1-sum2)*fi[rt[i]]%mod*e[l].z%mod+mod)%mod;</span><br><span class="line">		&#125;</span><br><span class="line"><span class="comment">//		for (i=1;i&lt;=tot;i++) f[rt[i]]=0;</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>复杂度 $O(n^2\sum \sigma_o(w_i))$</p>
<p>实际跑不满。</p>
]]></content>
      <tags>
        <tag>莫比乌斯反演</tag>
        <tag>矩阵树定理</tag>
      </tags>
  </entry>
  <entry>
    <title>P6628 [省选联考 2020 B 卷] 丁香之路</title>
    <url>/2023/09/06/P6628-%E7%9C%81%E9%80%89%E8%81%94%E8%80%83-2020-B-%E5%8D%B7-%E4%B8%81%E9%A6%99%E4%B9%8B%E8%B7%AF/</url>
    <content><![CDATA[<h1 id="省选联考-2020-B-卷-丁香之路"><a href="#省选联考-2020-B-卷-丁香之路" class="headerlink" title="[省选联考 2020 B 卷] 丁香之路"></a>[省选联考 2020 B 卷] 丁香之路</h1><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>感觉有点妙妙的题目。</p>
<p>首先显然是要求一个欧拉路径（起点和终点相同的情况是欧拉回路）。满足必须经过给定的边。有除了起点和终点度数为奇数外，其余点都是偶数。</p>
<p>我们把不满足读数要求的点称为坏点。</p>
<p>考虑把相邻的坏点连一条边。看上去这图就满足欧拉回路了。</p>
<p>但是手玩一下样例发现没有考虑不连通的情况。</p>
<p>只需要把在不同连通块的点做一个最小生成树。实现上，按照权值顺序枚举相邻点，如果两个点不在一个连通块就连起来。</p>
<p>有一个细节，在连相邻的坏点中，比如连接 $(i,j)$ ，一个显然的贪心就是把 $i,i+1,i+2,…,j$ 都连起来，这样权值最小，且让之后不同连通块的权值减小。不这么做会有一点问题。比如之间有一个需要走的点但不是坏点，到最后一步的时候代码认为他们不在一个连通块中导致权值又加了一遍。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 3005</span></span><br><span class="line"><span class="type">int</span> fa[maxn];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getfa</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;<span class="keyword">return</span> x==fa[x]?x:fa[x]=<span class="built_in">getfa</span>(fa[x]);&#125;</span><br><span class="line"><span class="type">int</span> in[maxn],s[maxn][<span class="number">3</span>];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">yyy</span> &#123;</span><br><span class="line">	<span class="type">int</span> x,y;</span><br><span class="line">&#125;e[maxn*maxn];</span><br><span class="line"><span class="type">int</span> n,m,ss;ll SUM;</span><br><span class="line">vector&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; &gt;O[maxn];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">getfa</span>(x)^<span class="built_in">getfa</span>(y)) fa[<span class="built_in">getfa</span>(x)]=<span class="built_in">getfa</span>(y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> fl[maxn];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> S,<span class="type">int</span> T)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> i,j;ll ans=SUM;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) fl[i]=in[i]=<span class="number">0</span>,fa[i]=i,O[i].<span class="built_in">clear</span>();</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) in[i]=s[i][<span class="number">0</span>],fa[i]=s[i][<span class="number">1</span>],fl[i]=s[i][<span class="number">2</span>];</span><br><span class="line">	in[S]^=<span class="number">1</span>,in[T]^=<span class="number">1</span>;fl[S]=fl[T]=<span class="number">1</span>;</span><br><span class="line">	<span class="type">int</span> las=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) <span class="keyword">if</span> (in[i]) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!las) las=i;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">for</span> (j=las;j&lt;i;j++) <span class="built_in">merge</span>(j,i);</span><br><span class="line">			ans+=<span class="built_in">abs</span>(i-las),las=<span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; </span><br><span class="line">	las=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) <span class="keyword">if</span> (fl[i]) &#123;</span><br><span class="line">		<span class="keyword">if</span> (las) O[<span class="built_in">abs</span>(las-i)].<span class="built_in">push_back</span>(<span class="built_in">mk</span>(las,i));</span><br><span class="line">		las=i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> tmp:O[i]) </span><br><span class="line">			<span class="keyword">if</span> (<span class="built_in">getfa</span>(tmp.fi)^<span class="built_in">getfa</span>(tmp.se)) &#123;</span><br><span class="line">				ans+=<span class="number">2</span>*<span class="built_in">abs</span>(tmp.fi-tmp.se);</span><br><span class="line">				fa[<span class="built_in">getfa</span>(tmp.fi)]=<span class="built_in">getfa</span>(tmp.se);</span><br><span class="line">			&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld &quot;</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="built_in">read</span>(n);<span class="built_in">read</span>(m);<span class="built_in">read</span>(ss);</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=m;i++) <span class="built_in">read</span>(e[i].x),<span class="built_in">read</span>(e[i].y),SUM+=<span class="built_in">abs</span>(e[i].x-e[i].y);</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) fa[i]=i;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=m;i++) &#123;</span><br><span class="line">		in[e[i].x]++,in[e[i].y]++;</span><br><span class="line">		<span class="built_in">merge</span>(e[i].x,e[i].y);</span><br><span class="line">		fl[e[i].x]=<span class="number">1</span>,fl[e[i].y]=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) in[i]%=<span class="number">2</span>,s[i][<span class="number">0</span>]=in[i],s[i][<span class="number">1</span>]=fa[i],s[i][<span class="number">2</span>]=fl[i];</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">solve</span>(ss,i); </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>欧拉回路</tag>
        <tag>最小生成树</tag>
      </tags>
  </entry>
  <entry>
    <title>P6811 「MCOI-02」Build Battle 建筑大师</title>
    <url>/2023/07/09/P6811-%E3%80%8CMCOI-02%E3%80%8DBuild-Battle-%E5%BB%BA%E7%AD%91%E5%A4%A7%E5%B8%88/</url>
    <content><![CDATA[<h2 id="P6811-「MCOI-02」Build-Battle-建筑大师"><a href="#P6811-「MCOI-02」Build-Battle-建筑大师" class="headerlink" title="P6811 「MCOI-02」Build Battle 建筑大师"></a>P6811 「MCOI-02」Build Battle 建筑大师</h2><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>一个序列 $n$，给定<strong>独立</strong>询问 $m_i$，序列为 $1,2,3,…,m_i,1,2,…,(n-1)\bmod m_i+1$</p>
<p>求<strong>本质不同</strong>的子序列数。$q$ 组询问。</p>
<p>$n,q\le 1\times 10^6$</p>
<p>1s 512MB</p>
<h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><h4 id="Step1"><a href="#Step1" class="headerlink" title="Step1"></a>Step1</h4><p>定义 $f_i$ 表示到 $i$ 的本质序列不同的个数。</p>
<p>枚举 $x$ 表示子序列下一个<strong>权值</strong>，为了避免重复，$nex_{i,x}$ 表示从 $i$ 开始，下一个权值为 $x$ 的点的位置。$f_{nex[i][x]}\Leftarrow f_i$。</p>
<p>复杂度 $O(n^2q)$</p>
<h4 id="Step2"><a href="#Step2" class="headerlink" title="Step2"></a>Step2</h4><p>可以发现，这样丝毫没有用到这个序列的<strong>特殊性</strong>。</p>
<p>$i$ 可以从 $i-1,i-2,…,i-m$ 转移过来。前缀和优化。</p>
<p>复杂度 $O(nq)$</p>
<h4 id="Step3"><a href="#Step3" class="headerlink" title="Step3"></a>Step3</h4><p>令 $s_i&#x3D;\sum\limits_{j&#x3D;1}^{i} f_j$</p>
<p>则 $s_i&#x3D;s_{i-1}+f_i&#x3D;2s_{i-1}-s_{i-m-1}$ 。我们要求的就是 $s_n$。</p>
<p><strong>接下来是从题解贺来的小 trick</strong>。</p>
<p>相同于从 $1$ 开始，目前在位置 $i$ ，可以走一步让 $i+1$ 让阈值 $v&#x3D;v*2$，也可以走到 $i+m+1$ 让阈值 $v&#x3D;-v$。答案就是走到位置 $n$ 的阈值之和。</p>
<p>观察到和怎么走并没有关系，而和走的步数有关系。则枚举走 $m+1$ 步的次数。则答案为<br>$$<br>s_n&#x3D;\sum\limits_{i&#x3D;0}^{\frac{n}{m}} 2^{n-(m+1)i} \times (-1)^i\times \dbinom{n-(m+1)i+i}{i}<br>$$<br>每次枚举 $m$ ，暴力计算。复杂度是调和级数 $O(n\log n)$</p>
<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 1000005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> put() putchar(<span class="string">&#x27;\n&#x27;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Tp template<span class="string">&lt;typename Ty&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Ts template<span class="string">&lt;typename Ty,typename... Ar&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(<span class="type">int</span> &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> f=<span class="number">1</span>;x=<span class="number">0</span>;<span class="type">char</span> c=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (c&lt;<span class="string">&#x27;0&#x27;</span>||c&gt;<span class="string">&#x27;9&#x27;</span>) &#123;<span class="keyword">if</span> (c==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">-1</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span> (c&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;c&lt;=<span class="string">&#x27;9&#x27;</span>) &#123;x=x*<span class="number">10</span>+c-<span class="string">&#x27;0&#x27;</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> Debug&#123;</span><br><span class="line">	Tp <span class="type">void</span> _debug(<span class="type">char</span>* f,Ty t)&#123;cerr&lt;&lt;f&lt;&lt;<span class="string">&#x27;=&#x27;</span>&lt;&lt;t&lt;&lt;endl;&#125;</span><br><span class="line">	Ts <span class="type">void</span> _debug(<span class="type">char</span>* f,Ty x,Ar... y)&#123;<span class="keyword">while</span>(*f!=<span class="string">&#x27;,&#x27;</span>) cerr&lt;&lt;*f++;cerr&lt;&lt;<span class="string">&#x27;=&#x27;</span>&lt;&lt;x&lt;&lt;<span class="string">&quot;,&quot;</span>;_debug(f+<span class="number">1</span>,y...);&#125;</span><br><span class="line">	Tp ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; os,vector&lt;Ty&gt;&amp; V)&#123;os&lt;&lt;<span class="string">&quot;[&quot;</span>;<span class="keyword">for</span>(<span class="keyword">auto</span>&amp; vv:V) os&lt;&lt;vv&lt;&lt;<span class="string">&quot;,&quot;</span>;os&lt;&lt;<span class="string">&quot;]&quot;</span>;<span class="keyword">return</span> os;&#125;</span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> gdb(...) _debug((char*)#__VA_ARGS__,__VA_ARGS__)</span></span><br><span class="line">&#125;<span class="keyword">using</span> <span class="keyword">namespace</span> Debug;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">int</span> suf[maxn*<span class="number">2</span>],isuf[maxn*<span class="number">2</span>],n,q,Ans[maxn],pw[maxn*<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> &amp;x,<span class="type">int</span> y)</span> </span>&#123;x=(x+y)%mod;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">power</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> ans=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (y) &#123;</span><br><span class="line">		<span class="keyword">if</span> (y&amp;<span class="number">1</span>) ans=ans*x%mod;</span><br><span class="line">		x=x*x%mod;y&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">C</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span> </span>&#123;<span class="keyword">return</span> suf[x]*isuf[y]%mod*isuf[x-y]%mod;&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> i,m,j;</span><br><span class="line">	<span class="built_in">read</span>(n);<span class="built_in">read</span>(q);</span><br><span class="line">	suf[<span class="number">0</span>]=<span class="number">1</span>;pw[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=<span class="number">2</span>*n;i++) pw[i]=pw[i<span class="number">-1</span>]*<span class="number">2</span>%mod,suf[i]=suf[i<span class="number">-1</span>]*i%mod;</span><br><span class="line">	isuf[<span class="number">2</span>*n]=<span class="built_in">power</span>(suf[<span class="number">2</span>*n],mod<span class="number">-2</span>);</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">2</span>*n;i&gt;=<span class="number">1</span>;i--) isuf[i<span class="number">-1</span>]=isuf[i]*i%mod;</span><br><span class="line">	<span class="keyword">for</span> (j=<span class="number">1</span>;j&lt;=n;j++) &#123;</span><br><span class="line">		<span class="type">int</span> m=j+<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;=n/m;i++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (i&amp;<span class="number">1</span>) <span class="built_in">add</span>(Ans[j],mod-pw[n-m*i]*<span class="built_in">C</span>(n-m*i+i,i)%mod);</span><br><span class="line">			<span class="keyword">else</span> <span class="built_in">add</span>(Ans[j],pw[n-m*i]*<span class="built_in">C</span>(n-m*i+i,i));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">while</span> (q--) &#123;</span><br><span class="line">		<span class="built_in">read</span>(m);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,Ans[<span class="built_in">min</span>(n,m)]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>dp</tag>
        <tag>计数</tag>
      </tags>
  </entry>
  <entry>
    <title>P7219 [JOISC2020] 星座 3</title>
    <url>/2023/08/30/P7219-JOISC2020-%E6%98%9F%E5%BA%A7-3/</url>
    <content><![CDATA[<h1 id="JOISC2020-星座-3"><a href="#JOISC2020-星座-3" class="headerlink" title="[JOISC2020] 星座 3"></a>[JOISC2020] 星座 3</h1><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p><a href="https://www.luogu.com.cn/problem/P7219">https://www.luogu.com.cn/problem/P7219</a></p>
<p>HInt：如果感觉图一点性质都没有<del>就像我一样</del>，请考虑 $A_{X_i}&lt;Y_i$ 。</p>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>最小的不自然度转化为最大的选中的节点的权值。</p>
<p>考虑一种情况，$i&lt;j&lt;k$，$a_i&lt;a_j,a_k&lt;a_j$，那么如果存在一个点 $a_i&lt;x_d\le a_j$ ，那么点 $d$ 不会对 $[j,k]$ 之间的任何点产生影响。所以可以考虑建出大根的笛卡尔树，一个节点 $x$ 的左右子树在 $\le a_x$ 的点不会产生影响。</p>
<p>令 $f_{i,j}$ 表示当前在 $i$ 号点，子树中选中的点最高为 $j$。</p>
<p>令互不影响的两部分先计算出来，<br>$$<br>lm&#x3D;\max\limits <em>{j\le a_x} f</em>{lson,j},rm&#x3D;\max\limits_{j\le a_x} f_{rson,j}<br>$$<br> 考虑两种情况：</p>
<ul>
<li>在 $x$ 位置新加入一个点，$f_{i,x_i}&#x3D;\max c_x+lm+rm$</li>
<li>$x$ 位置不加入新点，$f_{i,j}&#x3D;\max{f_{lson,j}+rm,lm+f_{rson,j}}$</li>
</ul>
<p>这样状态数是 $n^2$ 的，但由于点只有 $m$ 个，显然有效状态没有这么多。我们不妨钦定选中的点最高为 $j$ 且一定要选中。</p>
<p>第一种转移为单点修改取 $\max$，第二种转移为区间加，合并取 $\max$。考虑线段树合并。</p>
<p>复杂度 $O(m\log n)$。</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 200005</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">yyy</span>&#123;</span><br><span class="line">	<span class="type">int</span> ls,rs,lazy,Max;</span><br><span class="line">&#125;f[maxn*<span class="number">20</span>];</span><br><span class="line"><span class="type">int</span> n,m,root[maxn],cnt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Pushup</span><span class="params">(<span class="type">int</span> rt)</span> </span>&#123;</span><br><span class="line">	f[rt].Max=<span class="built_in">max</span>(f[f[rt].ls].Max,f[f[rt].rs].Max);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Pushdown</span><span class="params">(<span class="type">int</span> rt)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (f[rt].lazy) &#123;</span><br><span class="line">		<span class="type">int</span> k=f[rt].lazy;f[rt].lazy=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span> (f[rt].ls) f[f[rt].ls].lazy+=k,f[f[rt].ls].Max+=k;</span><br><span class="line">		<span class="keyword">if</span> (f[rt].rs) f[f[rt].rs].lazy+=k,f[f[rt].rs].Max+=k;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Update</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> &amp;rt,<span class="type">int</span> head,<span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!rt) rt=++cnt,f[rt].Max=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (l==r) <span class="keyword">return</span> f[rt].Max=<span class="built_in">max</span>(f[rt].Max,k),<span class="built_in">void</span>();</span><br><span class="line">	<span class="built_in">Pushdown</span>(rt);</span><br><span class="line">	<span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span> (head&lt;=mid) <span class="built_in">Update</span>(l,mid,f[rt].ls,head,k);</span><br><span class="line">	<span class="keyword">else</span> <span class="built_in">Update</span>(mid+<span class="number">1</span>,r,f[rt].rs,head,k);</span><br><span class="line">	<span class="built_in">Pushup</span>(rt);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf=<span class="number">1e9</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">Query</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> rt,<span class="type">int</span> head,<span class="type">int</span> tail)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!rt) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (head&lt;=l&amp;&amp;r&lt;=tail) <span class="keyword">return</span> f[rt].Max;</span><br><span class="line">	<span class="built_in">Pushdown</span>(rt);</span><br><span class="line">	<span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>,tmp1=<span class="number">0</span>,tmp2=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (head&lt;=mid) tmp1=<span class="built_in">Query</span>(l,mid,f[rt].ls,head,tail);</span><br><span class="line">	<span class="keyword">if</span> (tail&gt;mid) tmp2=<span class="built_in">Query</span>(mid+<span class="number">1</span>,r,f[rt].rs,head,tail);</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">max</span>(tmp1,tmp2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> sum1,sum2;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> &amp;x,<span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!x||!y) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!x&amp;&amp;!y) x=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (!x) x=y,f[x].Max+=sum1,f[x].lazy+=sum1;</span><br><span class="line">		<span class="keyword">else</span> f[x].Max+=sum2,f[x].lazy+=sum2;</span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span> (l==r) &#123;</span><br><span class="line">		<span class="keyword">if</span> (f[x].Max+sum2&gt;f[y].Max+sum1) f[x].Max+=sum2,f[x].lazy+=sum2;</span><br><span class="line">		<span class="keyword">else</span> x=y,f[x].Max+=sum1,f[x].lazy+=sum1;</span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">Pushdown</span>(x);<span class="built_in">Pushdown</span>(y);</span><br><span class="line">	<span class="built_in">merge</span>(l,mid,f[x].ls,f[y].ls);</span><br><span class="line">	<span class="built_in">merge</span>(mid+<span class="number">1</span>,r,f[x].rs,f[y].rs);</span><br><span class="line">	<span class="built_in">Pushup</span>(x);</span><br><span class="line">&#125; </span><br><span class="line"><span class="type">int</span> a[maxn];</span><br><span class="line">vector&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; &gt;O[maxn];</span><br><span class="line"><span class="type">int</span> ls[maxn],rs[maxn],stac[maxn],tot;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> L,<span class="type">int</span> R)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> tmp1=<span class="number">0</span>,tmp2=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (ls[x]&amp;&amp;rs[x]) &#123;</span><br><span class="line">		<span class="built_in">solve</span>(ls[x],L,x<span class="number">-1</span>);</span><br><span class="line">		<span class="built_in">solve</span>(rs[x],x+<span class="number">1</span>,R);</span><br><span class="line">		tmp1=sum1=<span class="built_in">Query</span>(<span class="number">1</span>,n,root[ls[x]],<span class="number">1</span>,a[x]);</span><br><span class="line">		tmp2=sum2=<span class="built_in">Query</span>(<span class="number">1</span>,n,root[rs[x]],<span class="number">1</span>,a[x]);</span><br><span class="line">		<span class="built_in">merge</span>(<span class="number">1</span>,n,root[ls[x]],root[rs[x]]);</span><br><span class="line">		root[x]=root[ls[x]];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (ls[x]) &#123;</span><br><span class="line">		<span class="built_in">solve</span>(ls[x],L,x<span class="number">-1</span>);</span><br><span class="line">		tmp2=<span class="number">0</span>;tmp1=<span class="built_in">Query</span>(<span class="number">1</span>,n,root[ls[x]],<span class="number">1</span>,a[x]);</span><br><span class="line">		root[x]=root[ls[x]];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (rs[x]) &#123;</span><br><span class="line">		<span class="built_in">solve</span>(rs[x],x+<span class="number">1</span>,R); </span><br><span class="line">		tmp1=<span class="number">0</span>;tmp2=<span class="built_in">Query</span>(<span class="number">1</span>,n,root[rs[x]],<span class="number">1</span>,a[x]);</span><br><span class="line">		root[x]=root[rs[x]];</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> tmp:O[x]) <span class="built_in">Update</span>(<span class="number">1</span>,n,root[x],tmp.fi,tmp.se+tmp1+tmp2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> i,x,y,c,ans=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">read</span>(n);</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">read</span>(a[i]);</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="keyword">while</span> (tot&amp;&amp;a[stac[tot]]&lt;a[i]) ls[i]=stac[tot],tot--;</span><br><span class="line">		rs[stac[tot]]=i,stac[++tot]=i; </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">read</span>(m);</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=m;i++) &#123; </span><br><span class="line">		<span class="built_in">read</span>(x);<span class="built_in">read</span>(y);<span class="built_in">read</span>(c);ans+=c;</span><br><span class="line">		O[x].<span class="built_in">push_back</span>(<span class="built_in">mk</span>(y,c));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">solve</span>(stac[<span class="number">1</span>],<span class="number">1</span>,n);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,ans-f[root[stac[<span class="number">1</span>]]].Max);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>dp</tag>
        <tag>线段树合并</tag>
        <tag>笛卡尔树</tag>
        <tag>JOISC</tag>
      </tags>
  </entry>
  <entry>
    <title>P8321『JROI-4』沈阳大街 2</title>
    <url>/2023/02/28/P8321%E3%80%8EJROI-4%E3%80%8F%E6%B2%88%E9%98%B3%E5%A4%A7%E8%A1%97-2/</url>
    <content><![CDATA[<p>把 $a$ 和 $b$ 放到一个长度为 $2n$ 的序列中，从大到小排序。</p>
<p>每次匹配可以匹配两个颜色不同的点，权值为位置靠后的点权。</p>
<p>令 $f[i][j]$ 为当前匹配到位置 $i$，$j$ 为已经匹配了 $j$ 对。<br>$$<br>f[i][j]&#x3D;f[i-1][j-1]\times (\sum_{k&#x3D;1}^{i} [c_k\not &#x3D; c_i]-(j-1))\times w_i+f[i-1][j]<br>$$<br>输出 $f[2*n][n]$。</p>
<p>这里用了状态压缩。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 10005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> put() putchar(<span class="string">&#x27;\n&#x27;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Tp template<span class="string">&lt;typename Ty&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Ts template<span class="string">&lt;typename Ty,typename... Ar&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(<span class="type">int</span> &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> f=<span class="number">1</span>;x=<span class="number">0</span>;<span class="type">char</span> c=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (c&lt;<span class="string">&#x27;0&#x27;</span>||c&gt;<span class="string">&#x27;9&#x27;</span>) &#123;<span class="keyword">if</span> (c==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">-1</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span> (c&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;c&lt;=<span class="string">&#x27;9&#x27;</span>) &#123;x=x*<span class="number">10</span>+c-<span class="string">&#x27;0&#x27;</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> Debug&#123;</span><br><span class="line">	Tp <span class="type">void</span> _debug(<span class="type">char</span>* f,Ty t)&#123;cerr&lt;&lt;f&lt;&lt;<span class="string">&#x27;=&#x27;</span>&lt;&lt;t&lt;&lt;endl;&#125;</span><br><span class="line">	Ts <span class="type">void</span> _debug(<span class="type">char</span>* f,Ty x,Ar... y)&#123;<span class="keyword">while</span>(*f!=<span class="string">&#x27;,&#x27;</span>) cerr&lt;&lt;*f++;cerr&lt;&lt;<span class="string">&#x27;=&#x27;</span>&lt;&lt;x&lt;&lt;<span class="string">&quot;,&quot;</span>;_debug(f+<span class="number">1</span>,y...);&#125;</span><br><span class="line">	Tp ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; os,vector&lt;Ty&gt;&amp; V)&#123;os&lt;&lt;<span class="string">&quot;[&quot;</span>;<span class="keyword">for</span>(<span class="keyword">auto</span>&amp; vv:V) os&lt;&lt;vv&lt;&lt;<span class="string">&quot;,&quot;</span>;os&lt;&lt;<span class="string">&quot;]&quot;</span>;<span class="keyword">return</span> os;&#125;</span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> gdb(...) _debug((char*)#__VA_ARGS__,__VA_ARGS__)</span></span><br><span class="line">&#125;<span class="keyword">using</span> <span class="keyword">namespace</span> Debug;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">yyy</span>&#123;</span><br><span class="line">	<span class="type">int</span> w,flag;</span><br><span class="line">&#125;a[maxn*<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">cmp</span><span class="params">(yyy x,yyy y)</span> </span>&#123;<span class="keyword">return</span> x.w&gt;y.w;&#125;</span><br><span class="line"><span class="type">int</span> f[<span class="number">2</span>][maxn],nums[<span class="number">3</span>],n;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">power</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> ans=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (y) &#123;</span><br><span class="line">		<span class="keyword">if</span> (y&amp;<span class="number">1</span>) ans=ans*x%mod;</span><br><span class="line">		y&gt;&gt;=<span class="number">1</span>;x=x*x%mod;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> i,x,j;</span><br><span class="line">	<span class="built_in">read</span>(n);</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">read</span>(a[i].w),a[i].flag=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">read</span>(a[i+n].w),a[i+n].flag=<span class="number">1</span>;</span><br><span class="line">	<span class="built_in">sort</span>(a+<span class="number">1</span>,a+<span class="number">1</span>+n*<span class="number">2</span>,cmp);</span><br><span class="line">	f[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n*<span class="number">2</span>;i++) &#123;</span><br><span class="line">		nums[a[i].flag]++;</span><br><span class="line">		<span class="type">int</span> now=i&amp;<span class="number">1</span>,pre=now^<span class="number">1</span>;</span><br><span class="line">		f[now][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span> (j=<span class="number">1</span>;j&lt;=<span class="built_in">min</span>(i,n);j++) f[now][j]=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (j=<span class="number">1</span>;j&lt;=<span class="built_in">min</span>(i,n);j++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (nums[a[i].flag^<span class="number">1</span>]&gt;=j&amp;&amp;j&gt;=<span class="number">1</span>) f[now][j]=f[pre][j<span class="number">-1</span>]*a[i].w%mod*(nums[a[i].flag^<span class="number">1</span>]-(j<span class="number">-1</span>))%mod;</span><br><span class="line">			f[now][j]=(f[now][j]+f[pre][j])%mod;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> sum=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">2</span>;i&lt;=n;i++) sum=sum*i%mod;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,f[<span class="number">0</span>][n]*<span class="built_in">power</span>(sum,mod<span class="number">-2</span>)%mod);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title>P9187 [USACO23OPEN] Field Day S</title>
    <url>/2023/05/07/P9187-USACO23OPEN-Field-Day-S/</url>
    <content><![CDATA[<p>连 S 组 T2 都做不来了（悲</p>
<p>令原来的字符串序列为 $s_i$。正难则反，考虑取反以后不同的最少。取反以后的字符出序列为 $t_i$</p>
<p>以 $s_i$ 为起点跑 bfs。每个数向二进制下一个位置不同的数连边权为 $1$ 的边。跑出来的答案就是最少不同数。</p>
<p>复杂度 $O(2^c\times C)$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 500005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> put() putchar(<span class="string">&#x27;\n&#x27;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Tp template<span class="string">&lt;typename Ty&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Ts template<span class="string">&lt;typename Ty,typename... Ar&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(<span class="type">int</span> &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> f=<span class="number">1</span>;x=<span class="number">0</span>;<span class="type">char</span> c=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (c&lt;<span class="string">&#x27;0&#x27;</span>||c&gt;<span class="string">&#x27;9&#x27;</span>) &#123;<span class="keyword">if</span> (c==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">-1</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span> (c&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;c&lt;=<span class="string">&#x27;9&#x27;</span>) &#123;x=x*<span class="number">10</span>+c-<span class="string">&#x27;0&#x27;</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> Debug&#123;</span><br><span class="line">	Tp <span class="type">void</span> _debug(<span class="type">char</span>* f,Ty t)&#123;cerr&lt;&lt;f&lt;&lt;<span class="string">&#x27;=&#x27;</span>&lt;&lt;t&lt;&lt;endl;&#125;</span><br><span class="line">	Ts <span class="type">void</span> _debug(<span class="type">char</span>* f,Ty x,Ar... y)&#123;<span class="keyword">while</span>(*f!=<span class="string">&#x27;,&#x27;</span>) cerr&lt;&lt;*f++;cerr&lt;&lt;<span class="string">&#x27;=&#x27;</span>&lt;&lt;x&lt;&lt;<span class="string">&quot;,&quot;</span>;_debug(f+<span class="number">1</span>,y...);&#125;</span><br><span class="line">	Tp ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; os,vector&lt;Ty&gt;&amp; V)&#123;os&lt;&lt;<span class="string">&quot;[&quot;</span>;<span class="keyword">for</span>(<span class="keyword">auto</span>&amp; vv:V) os&lt;&lt;vv&lt;&lt;<span class="string">&quot;,&quot;</span>;os&lt;&lt;<span class="string">&quot;]&quot;</span>;<span class="keyword">return</span> os;&#125;</span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> gdb(...) _debug((char*)#__VA_ARGS__,__VA_ARGS__)</span></span><br><span class="line">&#125;<span class="keyword">using</span> <span class="keyword">namespace</span> Debug;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> f[<span class="number">500005</span>],b[maxn],c[maxn],h[maxn],head=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">	<span class="type">int</span> to,z,w;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">		to=y;z=h[x];h[x]=head;w=val;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;a[<span class="number">5000005</span>];</span><br><span class="line">queue&lt;<span class="type">int</span>&gt;q;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line"><span class="comment">//  freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);</span></span><br><span class="line">	<span class="type">int</span> i,j,x;<span class="type">char</span> ch;</span><br><span class="line">	<span class="built_in">read</span>(m);<span class="built_in">read</span>(n);</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		cin&gt;&gt;ch;</span><br><span class="line">		<span class="keyword">for</span> (j=<span class="number">0</span>;j&lt;m;j++,ch=<span class="built_in">getchar</span>()) c[i]+=(ch==<span class="string">&#x27;G&#x27;</span>)*(<span class="number">1</span>&lt;&lt;j),b[i]+=(ch!=<span class="string">&#x27;G&#x27;</span>)*(<span class="number">1</span>&lt;&lt;j);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;(<span class="number">1</span>&lt;&lt;m);i++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (j=<span class="number">0</span>;j&lt;m;j++) &#123;</span><br><span class="line">			<span class="keyword">if</span> ((i&gt;&gt;j)%<span class="number">2</span>==<span class="number">0</span>) a[++head].<span class="built_in">add</span>(i,i|(<span class="number">1</span>&lt;&lt;j),<span class="number">1</span>),a[++head].<span class="built_in">add</span>(i|(<span class="number">1</span>&lt;&lt;j),i,<span class="number">1</span>); </span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> s=(<span class="number">1</span>&lt;&lt;m);</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) a[++head].<span class="built_in">add</span>(s,c[i],<span class="number">0</span>);</span><br><span class="line">	f[s]=<span class="number">1</span>;q.<span class="built_in">push</span>(s);</span><br><span class="line">	<span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">		x=q.<span class="built_in">front</span>();q.<span class="built_in">pop</span>();</span><br><span class="line">		<span class="keyword">for</span> (i=h[x];i;i=a[i].z) <span class="keyword">if</span> (!f[a[i].to]) f[a[i].to]=f[x]+<span class="number">1</span>,q.<span class="built_in">push</span>(a[i].to);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,m-(f[b[i]]<span class="number">-2</span>));</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>最短路</tag>
        <tag>建图</tag>
      </tags>
  </entry>
  <entry>
    <title>P9377 [THUPC 2023 决赛] 百合</title>
    <url>/2023/08/30/P9377-THUPC-2023-%E5%86%B3%E8%B5%9B-%E7%99%BE%E5%90%88/</url>
    <content><![CDATA[<p>同周赛 round 4</p>
<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p><a href="https://www.luogu.com.cn/problem/P9377/">https://www.luogu.com.cn/problem/P9377\</a></p>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>定义 $n^2$ 条权值为 $a_k$ 的边为附加边。</p>
<p>一个重要的性质是最多只会走 $k$ 条附加边。如果走多了，一定有多余的，因为两个点之间最多二进制相差 $k$。</p>
<p>枚举现在走了几条附加边。先跑一遍最短路。令 $f_{i,j}$ 表示节点 $i$ ，经过权值为 $a_j$ 的附加边之后，最短路为 $f_{i,j}+a_j$。</p>
<p>用类似于<strong>高位前缀和</strong>的写法一样，外层枚举不同的位置。内层找到两个点转移。</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 300005</span></span><br><span class="line"><span class="type">int</span> k,m,s,n;</span><br><span class="line"><span class="type">int</span> f[maxn][<span class="number">18</span>],dis[maxn];</span><br><span class="line"><span class="type">int</span> head=<span class="number">1</span>,h[maxn];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">yyy</span> &#123;</span><br><span class="line">	<span class="type">int</span> to,z,w;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">		to=y;z=h[x];h[x]=head;w=val;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;a[maxn*<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> w[<span class="number">18</span>],vis[maxn];</span><br><span class="line">priority_queue&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; &gt;q;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dj</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> i,x;</span><br><span class="line"><span class="comment">//	q.push(mk(-dis[s],s));</span></span><br><span class="line">	<span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) q.<span class="built_in">pop</span>();</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;n;i++) q.<span class="built_in">push</span>(<span class="built_in">mk</span>(-dis[i],i)),vis[i]=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">		x=q.<span class="built_in">top</span>().se;q.<span class="built_in">pop</span>();</span><br><span class="line">		<span class="keyword">if</span> (vis[x]) <span class="keyword">continue</span>;vis[x]=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span> (i=h[x];i;i=a[i].z) <span class="keyword">if</span> (dis[a[i].to]&gt;dis[x]+a[i].w) &#123;</span><br><span class="line">			dis[a[i].to]=dis[x]+a[i].w;</span><br><span class="line">			q.<span class="built_in">push</span>(<span class="built_in">mk</span>(-dis[a[i].to],a[i].to));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf=<span class="number">1e12</span>;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> i,x,y,z,o,j,k,l;</span><br><span class="line">	<span class="built_in">read</span>(k);<span class="built_in">read</span>(m);<span class="built_in">read</span>(s);n=<span class="number">1</span>&lt;&lt;k;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=k;i++) <span class="built_in">read</span>(w[i]);</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=m;i++) &#123;</span><br><span class="line">		<span class="built_in">read</span>(x),<span class="built_in">read</span>(y),<span class="built_in">read</span>(z);</span><br><span class="line">		a[++head].<span class="built_in">add</span>(x,y,z);</span><br><span class="line">		a[++head].<span class="built_in">add</span>(y,x,z);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">memset</span>(dis,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(dis));dis[s]=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (o=<span class="number">1</span>;o&lt;=k;o++) &#123;</span><br><span class="line">		<span class="built_in">dj</span>();</span><br><span class="line">		<span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;n;i++) <span class="keyword">for</span> (j=<span class="number">1</span>;j&lt;=k;j++) f[i][j]=inf;</span><br><span class="line">		<span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;n;i++) f[i][<span class="number">0</span>]=dis[i];</span><br><span class="line">		<span class="keyword">for</span> (l=<span class="number">0</span>;l&lt;k;l++) 	</span><br><span class="line">			<span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;n;i++) <span class="keyword">if</span> ((i&gt;&gt;l)&amp;<span class="number">1</span>) &#123;</span><br><span class="line">				x=i,y=i^(<span class="number">1</span>&lt;&lt;l);</span><br><span class="line">				<span class="keyword">for</span> (j=k;j&gt;=<span class="number">1</span>;j--) &#123;</span><br><span class="line">					f[x][j]=<span class="built_in">min</span>(f[x][j],f[y][j<span class="number">-1</span>]);</span><br><span class="line">					f[y][j]=<span class="built_in">min</span>(f[y][j],f[x][j<span class="number">-1</span>]);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		<span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;n;i++) <span class="keyword">for</span> (j=<span class="number">0</span>;j&lt;=k;j++) &#123;</span><br><span class="line">			dis[i]=<span class="built_in">min</span>(dis[i],f[i][j]+w[j]);</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;n;i++) <span class="built_in">printf</span>(<span class="string">&quot;%lld &quot;</span>,dis[i]);  </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>最短路</tag>
        <tag>二进制</tag>
        <tag>SOSdp</tag>
      </tags>
  </entry>
  <entry>
    <title>P9388 [THUPC 2023 决赛] 先人类的人类选别</title>
    <url>/2023/08/31/P9388-THUPC-2023-%E5%86%B3%E8%B5%9B-%E5%85%88%E4%BA%BA%E7%B1%BB%E7%9A%84%E4%BA%BA%E7%B1%BB%E9%80%89%E5%88%AB/</url>
    <content><![CDATA[<h1 id="THUPC-2023-决赛-先人类的人类选别"><a href="#THUPC-2023-决赛-先人类的人类选别" class="headerlink" title="[THUPC 2023 决赛] 先人类的人类选别"></a>[THUPC 2023 决赛] 先人类的人类选别</h1><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p><a href="https://www.luogu.com.cn/problem/P9388">https://www.luogu.com.cn/problem/P9388</a></p>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>观察到操作序列一定，操作顺序对答案并没有影响。</p>
<p>将答案拆为 $\sum\limits_{i\le r}a_i-\sum\limits_{i&lt;l}a_i$ ，只需要求出操作后的前缀和即可。</p>
<p>观察到对于一个<strong>前缀区间</strong>，操作的本质就是将当前操作的所有 $x$ 和 $a_i$ 扔到一个堆里，取最小的前 $q$ 扔给后面。所以只需要快速找到前 $q$ 小之和即可。对于序列和操作分别用主席树和权值线段树，查询两个一起跑。</p>
<p>没有卡常。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 500005</span></span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> a[maxn],suf[maxn],root[maxn],rota,cnt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">	<span class="type">int</span> ls,rs,sum,siz;</span><br><span class="line">&#125; f[maxn*<span class="number">30</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Update</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> pre,<span class="type">int</span> head)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> rt=++cnt;</span><br><span class="line">	f[rt]=f[pre];</span><br><span class="line">	f[rt].siz++;</span><br><span class="line">	f[rt].sum+=head;</span><br><span class="line">	<span class="keyword">if</span> (l==r) <span class="keyword">return</span> rt;</span><br><span class="line">	<span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span> (head&lt;=mid) f[rt].ls=<span class="built_in">Update</span>(l,mid,f[rt].ls,head);</span><br><span class="line">	<span class="keyword">else</span> f[rt].rs=<span class="built_in">Update</span>(mid+<span class="number">1</span>,r,f[rt].rs,head);</span><br><span class="line">	<span class="keyword">return</span> rt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Update2</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> &amp;rt,<span class="type">int</span> head)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!rt) rt=++cnt;</span><br><span class="line">	f[rt].siz++,f[rt].sum+=head;</span><br><span class="line">	<span class="keyword">if</span> (l==r) <span class="keyword">return</span> ;</span><br><span class="line">	<span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span> (head&lt;=mid) <span class="built_in">Update2</span>(l,mid,f[rt].ls,head);</span><br><span class="line">	<span class="keyword">else</span> <span class="built_in">Update2</span>(mid+<span class="number">1</span>,r,f[rt].rs,head);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Query</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> rt1,<span class="type">int</span> rt2,<span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (l==r) <span class="keyword">return</span> k*l;</span><br><span class="line">	<span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>,siz=f[f[rt1].ls].siz+f[f[rt2].ls].siz;</span><br><span class="line">	<span class="keyword">if</span> (siz&gt;=k) <span class="keyword">return</span> <span class="built_in">Query</span>(l,mid,f[rt1].ls,f[rt2].ls,k);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> f[f[rt1].ls].sum+f[f[rt2].ls].sum+<span class="built_in">Query</span>(mid+<span class="number">1</span>,r,f[rt1].rs,f[rt2].rs,k-siz);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> i,x,l,r,sum=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">read</span>(n);</span><br><span class="line">	<span class="built_in">read</span>(m);</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>; i&lt;=n; i++) <span class="built_in">read</span>(a[i]),suf[i]=suf[i<span class="number">-1</span>]+a[i];</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line">		root[i]=<span class="built_in">Update</span>(<span class="number">1</span>,n,root[i<span class="number">-1</span>],a[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>; i&lt;=m; i++) &#123;</span><br><span class="line">		<span class="built_in">read</span>(x);<span class="built_in">read</span>(l);<span class="built_in">read</span>(r);sum+=x;</span><br><span class="line">		<span class="built_in">Update2</span>(<span class="number">1</span>,n,rota,x);</span><br><span class="line">		<span class="type">int</span> tmp1=suf[l<span class="number">-1</span>]+sum-<span class="built_in">Query</span>(<span class="number">1</span>,n,root[l<span class="number">-1</span>],rota,i);</span><br><span class="line">		<span class="type">int</span> tmp2=suf[r]+sum-<span class="built_in">Query</span>(<span class="number">1</span>,n,root[r],rota,i);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,tmp2-tmp1);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>差分</tag>
        <tag>主席树</tag>
      </tags>
  </entry>
  <entry>
    <title>P9387 [THUPC 2023 决赛] 巧克力</title>
    <url>/2023/08/31/P9387-THUPC-2023-%E5%86%B3%E8%B5%9B-%E5%B7%A7%E5%85%8B%E5%8A%9B/</url>
    <content><![CDATA[<h1 id="THUPC-2023-决赛-巧克力"><a href="#THUPC-2023-决赛-巧克力" class="headerlink" title="[THUPC 2023 决赛] 巧克力"></a>[THUPC 2023 决赛] 巧克力</h1><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p><a href="https://www.luogu.com.cn/problem/P9387">https://www.luogu.com.cn/problem/P9387</a></p>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>首先推一下必胜情况的充要条件。</p>
<p>本图是有向无环图，公平的两人游戏，考虑用 sg 函数。</p>
<p>令当前操作的巧克力长度为 $x$，实际上 $SG(x)&#x3D;x$。</p>
<ul>
<li>如果 $x\not &#x3D; 1$ ，显然可以先分为 $(0,x-1,1),…,(0,1,x-1)$，这样取 $\text{mex}$ 之后 sg 值已经为 $x$，所以有 $SG(x)\ge x$。</li>
<li>如果分为 $(a,b,c),a+b+c&#x3D;x,b&gt;0$ 。原问题拆成两个独立的的子博弈 $a$ 和 $c$，又有 $a\bigoplus c\le a+c$，所以这里不会对 $SG$ 值有影响。</li>
</ul>
<p>首先要全局的 $SG$ 异或和不为 $0$，保证先手不可能必败。令全局初始的异或和为 $N$。</p>
<p>再用令要把 $x$ 拆分为 $(a,b,c),a+b+c&#x3D;x,b&gt;0$，若操作完以后先手必败（这时候是后手先手）应该有：<br>$$<br>a\bigoplus c\bigoplus x\bigoplus N&#x3D;0<br>$$<br>即现在的 $SG$ 的异或和为 $0$。</p>
<p>移个项为：<br>$$<br>a\bigoplus c\bigoplus(a+b+c)&#x3D;N<br>$$<br>我们要求的是 $a+b+c\le n$ 或者 $a+b+c&#x3D;m$ 的方案数，令 $\le n$ 的方案数为 $F(n)$，那么答案为 $F(n)+F(m)-F(m-1)$。</p>
<p>考虑数位 dp。一种的做法选择是从低位到高位 dp。记录当前在第 $i$ 位，低位到第 $i$ 进了 $j$ 位， $b$ 是否等于 $0$，$a+b+c$ 的后 $i$ 位是否大于 $N$ 的后 $i$ 位的方案数。</p>
<p>另一种大概是从高到低位 dp。记录当前在第 $i$ 位，向低位借了 $j$ ，$b$ 是否为 $0$，是否大于 $N$。（这种是口胡的）。</p>
<p>实现是第一种。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="type">int</span> f[<span class="number">65</span>][<span class="number">4</span>][<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> stat[<span class="number">65</span>],p[<span class="number">65</span>];</span><br><span class="line"><span class="type">int</span> cnt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> &amp;x,<span class="type">int</span> y)</span> </span>&#123;x=(x+y)%mod;&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (n==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">memset</span>(f,<span class="number">0</span>,<span class="built_in">sizeof</span>(f));	</span><br><span class="line">	<span class="built_in">memset</span>(p,<span class="number">0</span>,<span class="built_in">sizeof</span>(p));</span><br><span class="line">	<span class="type">int</span> tot=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (n) p[++tot]=n%<span class="number">2</span>,n/=<span class="number">2</span>;</span><br><span class="line">	f[<span class="number">0</span>][<span class="number">0</span>][<span class="number">1</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">	<span class="type">int</span> i,j,k,l,a,b,c;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;=<span class="number">60</span>;i++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (j=<span class="number">0</span>;j&lt;=<span class="number">3</span>;j++) &#123;</span><br><span class="line">			<span class="keyword">for</span> (k=<span class="number">0</span>;k&lt;=<span class="number">1</span>;k++) &#123;</span><br><span class="line">				<span class="keyword">for</span> (l=<span class="number">0</span>;l&lt;=<span class="number">1</span>;l++) &#123;</span><br><span class="line">					<span class="keyword">for</span> (a=<span class="number">0</span>;a&lt;=<span class="number">1</span>;a++)</span><br><span class="line">						<span class="keyword">for</span> (b=<span class="number">0</span>;b&lt;=<span class="number">1</span>;b++)</span><br><span class="line">							<span class="keyword">for</span> (c=<span class="number">0</span>;c&lt;=<span class="number">1</span>;c++) &#123;</span><br><span class="line">								<span class="type">int</span> s=((a+b+c+j))%<span class="number">2</span>;</span><br><span class="line">								<span class="keyword">if</span> ((s^a^c)==stat[i+<span class="number">1</span>]) &#123;</span><br><span class="line">									<span class="type">int</span> pus=<span class="number">0</span>;</span><br><span class="line">									<span class="keyword">if</span> (s&gt;p[i+<span class="number">1</span>]||(l&amp;&amp;s==p[i+<span class="number">1</span>])) pus=<span class="number">1</span>;</span><br><span class="line">									<span class="built_in">add</span>(f[i+<span class="number">1</span>][(j+a+b+c)/<span class="number">2</span>][k&amp;(b==<span class="number">0</span>)][pus],f[i][j][k][l]);</span><br><span class="line">								&#125;</span><br><span class="line">							&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> f[<span class="number">60</span>][<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> i,n,m,s=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">read</span>(n);<span class="built_in">read</span>(m);</span><br><span class="line">	<span class="built_in">memset</span>(stat,<span class="number">0</span>,<span class="built_in">sizeof</span>(stat));</span><br><span class="line">	s=m;</span><br><span class="line">	<span class="keyword">if</span> (n%<span class="number">4</span>&gt;=<span class="number">1</span>) s^=n;</span><br><span class="line">	<span class="keyword">if</span> (n%<span class="number">4</span>&gt;=<span class="number">2</span>) s^=(n<span class="number">-1</span>);</span><br><span class="line">	<span class="keyword">if</span> (n%<span class="number">4</span>&gt;=<span class="number">3</span>) s^=(n<span class="number">-2</span>);</span><br><span class="line">	<span class="keyword">if</span> (s==<span class="number">0</span>) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;0&quot;</span>),<span class="built_in">void</span>();</span><br><span class="line">	cnt=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (s) stat[++cnt]=s%<span class="number">2</span>,s/=<span class="number">2</span>;</span><br><span class="line">	<span class="type">int</span> tmp1,tmp2;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,(<span class="built_in">get</span>(n)+<span class="built_in">get</span>(m)-<span class="built_in">get</span>(m<span class="number">-1</span>)+mod)%mod);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> T;</span><br><span class="line">	<span class="built_in">read</span>(T);<span class="keyword">while</span> (T--) <span class="built_in">solve</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>没卡常之前不太能过。卡常就跟另外一篇题解一样循环展开之类的，效果很明显。</p>
]]></content>
      <tags>
        <tag>计数</tag>
        <tag>数位dp</tag>
        <tag>博弈</tag>
        <tag>sg函数</tag>
      </tags>
  </entry>
  <entry>
    <title>Powerpoint中插入Latex</title>
    <url>/2022/06/29/Powerpoint%E4%B8%AD%E6%8F%92%E5%85%A5Latex/</url>
    <content><![CDATA[<p><a href="https://github.com/Jonathan-LeRoux/IguanaTex">github link</a></p>
<h3 id="使用要求"><a href="#使用要求" class="headerlink" title="使用要求"></a>使用要求</h3><ul>
<li><a href="https://www.tug.org/texlive/">TeXLive</a>或<a href="http://miktex.org/">MiKTeX</a></li>
<li><a href="http://www.ghostscript.com/download/gsdnld.html">GhostScript</a>（如果最新版本出现问题，请尝试 gs9.26）</li>
<li><a href="http://www.imagemagick.org/script/download.php#windows">ImageMagick</a></li>
<li>（可选）<a href="https://github.com/abenori/TeX2img">TeX2img</a>，用于通过 EMF 输出矢量图形（<a href="https://www.ms.u-tokyo.ac.jp/~abenori/soft/index.html#TEX2IMG">下载</a>）。</li>
</ul>
<h3 id="下载并安装"><a href="#下载并安装" class="headerlink" title="下载并安装"></a>下载并安装</h3><ol>
<li><p><a href="https://github.com/Jonathan-LeRoux/IguanaTex/releases">从此存储库的发布页面</a>或从<a href="http://www.jonathanleroux.org/software/iguanatex/download.html">IguanaTex 下载页面</a><strong>下载 .ppam 加载项</strong>文件。</p>
</li>
<li><p><strong>加载加载项</strong>：在“文件”&gt;“选项”&gt;“加载项”&gt;“管理：”中，选择“PowerPoint加载项”然后“转到…”，然后单击“添加新”，选择.ppam 文件在您下载它的文件夹中，然后“关闭”（如果您下载了 .pptm 源并将其保存为 .ppam，它将位于默认的加载项文件夹中）。</p>
</li>
<li><p><strong>创建和设置临时文件夹</strong>：IguanaTex 需要访问具有读&#x2F;写权限的文件夹来存储临时文件。</p>
<p><img src="https://s2.loli.net/2022/06/29/zr825QCKoDcGsv3.png" alt="image-20220626163651543"></p>
</li>
<li><p><strong>安装并设置 GhostScript , ImageMagick 和 TeX2img 的路径</strong>：</p>
</li>
</ol>
<ul>
<li>在机器上的某个地方解压 TeX2img 后，运行 TeX2img.exe 一次</li>
</ul>
<ul>
<li><p>在“主要设置”窗口中设置 gswin32c.exe 或 gswin64c.exe（注意“c”！）和 ImageMagick 的 magick.exe 以及 TeX2imgc.exe 的完整路径。</p>
</li>
<li><p>仅需要通过 EMF 支持矢量图形（与 SVG 相比，优点：适用于所有 PowerPoint 版本，完全可修改的形状；缺点：某些显示器随机出现失真）</p>
</li>
<li><p><img src="https://s2.loli.net/2022/06/29/yITOzCXF6H3uWRA.png" alt="image-20220626164004606"></p>
</li>
</ul>
<h3 id="写入"><a href="#写入" class="headerlink" title="写入"></a>写入</h3><p><img src="https://s2.loli.net/2022/06/29/rKGuVktDsFgdmwc.png" alt="image-20220626164039491"></p>
<p>直接打公式就好</p>
]]></content>
      <tags>
        <tag>杂项</tag>
      </tags>
  </entry>
  <entry>
    <title>QOJ5437. Graph Completing.t</title>
    <url>/2023/09/10/QOJ5437-Graph-Completing-t/</url>
    <content><![CDATA[<h1 id="5437-Graph-Completing"><a href="#5437-Graph-Completing" class="headerlink" title="5437. Graph Completing"></a>5437. Graph Completing</h1><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>已经有一个 $n$ 个点 $m$ 条边的无向连通图。求有几种加边方案使得整张图为一个边双联通分量。</p>
<p>$n&lt;&#x3D;5000$</p>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>先缩边双，原图为一棵树。</p>
<p>也就是说，可以在两个点之间连条边，意义为两点之间的路径缩成一个点双。目的是连若干条边使得所有边都被覆盖过。</p>
<p>考虑容斥，直接钦定 $i$ 条边不能选，然后剩下 $i+1$ 个连通块内部任意连边。</p>
<p>令 $f_{i,j,k}$ 表示当前在 $i$ 号子树，当前树的连通块大小为 $j$，钦定了 $k$ 条边。树上背包的做法，是 $O(n^3)$ 的。</p>
<p>但是我们发现记录第三维根本没有意义，只是记录了哪些最后答案 $\times 1$ 还是 $\times (-1)$。转移的时候如果 $k\to k+1$，则转移系数 $\times (-1)$。这样复杂度就是 $O(n^2)$ 的。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 5005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> put() putchar(<span class="string">&#x27;\n&#x27;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Tp template<span class="string">&lt;typename Ty&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Ts template<span class="string">&lt;typename Ty,typename... Ar&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">(<span class="type">int</span> &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> f=<span class="number">1</span>;x=<span class="number">0</span>;<span class="type">char</span> c=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (c&lt;<span class="string">&#x27;0&#x27;</span>||c&gt;<span class="string">&#x27;9&#x27;</span>) &#123;<span class="keyword">if</span> (c==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">-1</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span> (c&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;c&lt;=<span class="string">&#x27;9&#x27;</span>) &#123;x=x*<span class="number">10</span>+c-<span class="string">&#x27;0&#x27;</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> Debug&#123;</span><br><span class="line">	Tp <span class="type">void</span> _debug(<span class="type">char</span>* f,Ty t)&#123;cerr&lt;&lt;f&lt;&lt;<span class="string">&#x27;=&#x27;</span>&lt;&lt;t&lt;&lt;endl;&#125;</span><br><span class="line">	Ts <span class="type">void</span> _debug(<span class="type">char</span>* f,Ty x,Ar... y)&#123;<span class="keyword">while</span>(*f!=<span class="string">&#x27;,&#x27;</span>) cerr&lt;&lt;*f++;cerr&lt;&lt;<span class="string">&#x27;=&#x27;</span>&lt;&lt;x&lt;&lt;<span class="string">&quot;,&quot;</span>;_debug(f+<span class="number">1</span>,y...);&#125;</span><br><span class="line">	Tp ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; os,vector&lt;Ty&gt;&amp; V)&#123;os&lt;&lt;<span class="string">&quot;[&quot;</span>;<span class="keyword">for</span>(<span class="keyword">auto</span>&amp; vv:V) os&lt;&lt;vv&lt;&lt;<span class="string">&quot;,&quot;</span>;os&lt;&lt;<span class="string">&quot;]&quot;</span>;<span class="keyword">return</span> os;&#125;</span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> gdb(...) _debug((char*)#__VA_ARGS__,__VA_ARGS__)</span></span><br><span class="line">&#125;<span class="keyword">using</span> <span class="keyword">namespace</span> Debug;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mk make_pair</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">998244353</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">power</span><span class="params">(ll x,<span class="type">int</span> y=mod<span class="number">-2</span>)</span> </span>&#123;</span><br><span class="line">	ll sum=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (y) &#123;</span><br><span class="line">		<span class="keyword">if</span> (y&amp;<span class="number">1</span>) sum=sum*x%mod;</span><br><span class="line">		x=x*x%mod;y&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> h[maxn],head=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">yyy</span> &#123;</span><br><span class="line">	<span class="type">int</span> to,z,flag;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">		to=y;z=h[x];h[x]=head;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;a[maxn*<span class="number">4</span>];</span><br><span class="line"><span class="type">unsigned</span> pw[maxn*maxn];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;to[maxn];</span><br><span class="line"><span class="type">int</span> times,tot,n,m,eccnum;</span><br><span class="line"><span class="type">int</span> dfn[maxn],low[maxn],stac[maxn],vis[maxn],ecc[maxn];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tarjan</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> pre)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	dfn[x]=low[x]=++times;stac[++tot]=x;vis[x]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (i=h[x];i;i=a[i].z) <span class="keyword">if</span> ((i^<span class="number">1</span>)^pre) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!dfn[a[i].to]) &#123;</span><br><span class="line">			<span class="built_in">tarjan</span>(a[i].to,i);</span><br><span class="line">			low[x]=<span class="built_in">min</span>(low[x],low[a[i].to]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (vis[a[i].to]) low[x]=<span class="built_in">min</span>(low[x],dfn[a[i].to]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (dfn[x]==low[x]) &#123;</span><br><span class="line">		a[i].flag=a[i^<span class="number">1</span>].flag=<span class="number">1</span>;</span><br><span class="line">		++eccnum;</span><br><span class="line">		<span class="keyword">while</span> (tot) &#123;</span><br><span class="line">			ecc[stac[tot]]=eccnum;</span><br><span class="line">			vis[stac[tot]]=<span class="number">0</span>;</span><br><span class="line">			<span class="keyword">if</span> (stac[tot--]==x) <span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> f[maxn][maxn],g[maxn],siz[maxn],v[maxn];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> &amp;x,<span class="type">int</span> y)</span> </span>&#123;x=(x+y)%mod;&#125; </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> pre)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> i,j;</span><br><span class="line">	<span class="keyword">if</span> (v[x]) &#123;<span class="built_in">exit</span>(<span class="number">0</span>);&#125;</span><br><span class="line">	v[x]=<span class="number">1</span>;</span><br><span class="line">	f[x][siz[x]]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> y:to[x]) <span class="keyword">if</span> (y^pre) &#123;</span><br><span class="line">		<span class="built_in">dfs</span>(y,x);</span><br><span class="line">		<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=siz[x];i++) &#123;</span><br><span class="line">			<span class="keyword">for</span> (j=<span class="number">1</span>;j&lt;=siz[y];j++)&#123;</span><br><span class="line">				<span class="built_in">add</span>(g[i+j],<span class="number">1ll</span>*f[x][i]*f[y][j]%mod);</span><br><span class="line">				<span class="built_in">add</span>(g[i],mod<span class="number">-1ll</span>*f[x][i]*f[y][j]%mod*pw[j*(j<span class="number">-1</span>)/<span class="number">2</span>]*<span class="number">2</span>%mod);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		siz[x]+=siz[y];</span><br><span class="line">		<span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;=siz[x];i++) f[x][i]=g[i],g[i]=<span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> ans;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> i,j,x,y;</span><br><span class="line">	<span class="built_in">read</span>(n);<span class="built_in">read</span>(m);</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=m;i++) &#123;</span><br><span class="line">		<span class="built_in">read</span>(x);<span class="built_in">read</span>(y);</span><br><span class="line">		a[++head].<span class="built_in">add</span>(x,y);</span><br><span class="line">		a[++head].<span class="built_in">add</span>(y,x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) <span class="keyword">if</span> (!dfn[i]) &#123;</span><br><span class="line">		<span class="built_in">tarjan</span>(i,<span class="number">0</span>);</span><br><span class="line">		<span class="keyword">if</span> (tot) &#123;</span><br><span class="line">			++eccnum;</span><br><span class="line">			<span class="keyword">while</span> (tot) &#123;</span><br><span class="line">				ecc[stac[tot]]=eccnum;</span><br><span class="line">				vis[stac[tot]]=<span class="number">0</span>;</span><br><span class="line">				tot--;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		siz[ecc[i]]++;</span><br><span class="line">		<span class="keyword">for</span> (j=h[i];j;j=a[j].z) </span><br><span class="line">			<span class="keyword">if</span> (ecc[i]^ecc[a[j].to]) &#123;</span><br><span class="line">				to[ecc[i]].<span class="built_in">push_back</span>(ecc[a[j].to]);</span><br><span class="line">			&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> N=n*n;</span><br><span class="line">	<span class="keyword">for</span> (pw[<span class="number">0</span>]=<span class="number">1</span>,i=<span class="number">1</span>;i&lt;=N;i++) pw[i]=<span class="number">1ll</span>*pw[i<span class="number">-1</span>]*<span class="number">2</span>%mod;</span><br><span class="line">	<span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">add</span>(ans,<span class="number">1ll</span>*f[<span class="number">1</span>][i]*pw[i*(i<span class="number">-1</span>)/<span class="number">2</span>]%mod);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,<span class="number">1ll</span>*ans*<span class="built_in">power</span>(pw[m])%mod);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



]]></content>
      <tags>
        <tag>dp</tag>
        <tag>容斥</tag>
      </tags>
  </entry>
  <entry>
    <title>Shift-and 字符串匹配</title>
    <url>/2022/11/18/Shift-And-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D/</url>
    <content><![CDATA[<p>基于位运算的字符串匹配算法。</p>
<p>我们令模式串为 $s$，长度为 $n$ ，文本串为 $t$ ，长度为 $m$ 。字符集大小为 $k$</p>
<p>无特殊说明时，字符串从 $0$ 位开始。</p>
<h3 id="模式串匹配文本串"><a href="#模式串匹配文本串" class="headerlink" title="模式串匹配文本串"></a>模式串匹配文本串</h3><p>顾名思义，预处理在模式串中进行。而最终计算在文本串内进行。</p>
<p>预处理中，$B_{i,j}$ 表示<strong>字符</strong>在 $s$ 的第 $j$ 位是否为 $i$。</p>
<p>令 $P$ 表示文本串的匹配情况，$i$ 表示当前枚举到文本串的第 $i$ 位，$P_j$ 表示 $t$ 中 $[i-j,i]$ 与 $s$ 中 $[0,j]$ 是否相等。</p>
<p>考虑从 $i-1$ 到 $i$ 时转移 $P$，<code>P=(P&lt;&lt;1|1)&amp;B[s[i]]</code></p>
<p>根据定义，这是显然正确的。</p>
<p>我们发现这些操作都与二进制的位操作，所以可以用 bitset 优化。</p>
<p>复杂度预处理 $O(\dfrac{nk}{w})$，主算法 $O(\dfrac{mn}{w})$</p>
<p><strong>主要适用于 $k$ 比较小，且模式串长度也不长的情况。</strong></p>
<h3 id="文本串匹配模式串"><a href="#文本串匹配模式串" class="headerlink" title="文本串匹配模式串"></a>文本串匹配模式串</h3><p>同样的，预处理在文本串内进行，主算法在模式串中进行。</p>
<p>预处理中，$B_{i,j}$ 表示<strong>字符</strong>在 $t$ 中的第 $j$ 位为是否为 $i$。</p>
<p>令 $P$ 表示文本串的匹配情况，$i$ 表示当前枚举到<strong>模式串</strong>的第 $i$ 位，$P_j$ 表示 $s$ 中 $[j-i,j]$ 和 $t$ 中 $[0,i]$ 是否相等。</p>
<p>考虑从 $i-1$ 到 $i$ 时转移，<code>P=(P&lt;&lt;1)&amp;B[s[i]]</code></p>
<p>$P$ 一开始的 $[0,m-n]$ 位为 $1$。</p>
<p>主算法的复杂度同样也为 $O(\dfrac{mn}{w})$。</p>
<p>考虑到一般情况下文本串的大小大于模式串。<strong>主要适用于字符集数量比较小，文本串的动态变化的情况。</strong></p>
<h3 id="例题1"><a href="#例题1" class="headerlink" title="例题1"></a>例题1</h3><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=5972">http://acm.hdu.edu.cn/showproblem.php?pid=5972</a></p>
<p>解决了 KMP 不能解决的情况，</p>
<h3 id="例题2"><a href="#例题2" class="headerlink" title="例题2"></a>例题2</h3><p>bzoj2628</p>
<p>动态维护 $B$ 数组。</p>
]]></content>
      <tags>
        <tag>学习笔记</tag>
        <tag>字符串</tag>
        <tag>bitset</tag>
      </tags>
  </entry>
  <entry>
    <title>USACO22 Pair Programming G</title>
    <url>/2023/02/28/USACO22-Pair-Programming-G/</url>
    <content><![CDATA[<p>先做一遍预处理。忽略 $1$，和 $0$ 前面的部分（保留$0$）</p>
<p>考虑两个合并序列结果相同的情况，也就是不产生贡献的情况：</p>
<ul>
<li>相邻两项类型相同，且前者属于 $A$ ，后者属于 $B$</li>
</ul>
<p>如果一个序列中存在这种情况，交换相邻两项，结果显然相同。</p>
<p>令 $f[i][j][0&#x2F;1]$ 表示 $A$ 中前 $i$ 个，$B$ 中前 $j$ 个合并，且最后一位来自 $A&#x2F;B$ 之中。</p>
<p>转移便很好转移了。初始状态为 $f[0][0][1]&#x3D;1$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 2005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> put() putchar(<span class="string">&#x27;\n&#x27;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Tp template<span class="string">&lt;typename Ty&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Ts template<span class="string">&lt;typename Ty,typename... Ar&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(<span class="type">int</span> &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> f=<span class="number">1</span>;x=<span class="number">0</span>;<span class="type">char</span> c=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (c&lt;<span class="string">&#x27;0&#x27;</span>||c&gt;<span class="string">&#x27;9&#x27;</span>) &#123;<span class="keyword">if</span> (c==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">-1</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span> (c&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;c&lt;=<span class="string">&#x27;9&#x27;</span>) &#123;x=x*<span class="number">10</span>+c-<span class="string">&#x27;0&#x27;</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> Debug&#123;</span><br><span class="line">	Tp <span class="type">void</span> _debug(<span class="type">char</span>* f,Ty t)&#123;cerr&lt;&lt;f&lt;&lt;<span class="string">&#x27;=&#x27;</span>&lt;&lt;t&lt;&lt;endl;&#125;</span><br><span class="line">	Ts <span class="type">void</span> _debug(<span class="type">char</span>* f,Ty x,Ar... y)&#123;<span class="keyword">while</span>(*f!=<span class="string">&#x27;,&#x27;</span>) cerr&lt;&lt;*f++;cerr&lt;&lt;<span class="string">&#x27;=&#x27;</span>&lt;&lt;x&lt;&lt;<span class="string">&quot;,&quot;</span>;_debug(f+<span class="number">1</span>,y...);&#125;</span><br><span class="line">	Tp ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; os,vector&lt;Ty&gt;&amp; V)&#123;os&lt;&lt;<span class="string">&quot;[&quot;</span>;<span class="keyword">for</span>(<span class="keyword">auto</span>&amp; vv:V) os&lt;&lt;vv&lt;&lt;<span class="string">&quot;,&quot;</span>;os&lt;&lt;<span class="string">&quot;]&quot;</span>;<span class="keyword">return</span> os;&#125;</span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> gdb(...) _debug((char*)#__VA_ARGS__,__VA_ARGS__)</span></span><br><span class="line">&#125;<span class="keyword">using</span> <span class="keyword">namespace</span> Debug;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">string a,b;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">input</span><span class="params">(string &amp;s,<span class="type">int</span> &amp;lens)</span> </span>&#123;</span><br><span class="line">	lens=<span class="number">0</span>;<span class="type">int</span> i;string t=<span class="string">&quot;_&quot;</span>;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (s[i]==<span class="string">&#x27;0&#x27;</span>) lens=<span class="number">0</span>,t=<span class="string">&quot;_&quot;</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (s[i]==<span class="string">&#x27;1&#x27;</span>) <span class="keyword">continue</span>;</span><br><span class="line">		lens++;</span><br><span class="line">		<span class="keyword">if</span> (s[i]==<span class="string">&#x27;+&#x27;</span>) t+=s[i];</span><br><span class="line">		<span class="keyword">else</span> t+=<span class="string">&#x27;*&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	s=t;</span><br><span class="line">&#125; </span><br><span class="line"><span class="type">int</span> f[maxn][maxn][<span class="number">2</span>];</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">solve</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> i,j,lena,lenb;</span><br><span class="line">	<span class="built_in">read</span>(n);</span><br><span class="line">	cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">	a=<span class="string">&quot;_&quot;</span>+a,b=<span class="string">&quot;_&quot;</span>+b;</span><br><span class="line">	<span class="built_in">input</span>(a,lena),<span class="built_in">input</span>(b,lenb);</span><br><span class="line"><span class="comment">//	cout&lt;&lt;a&lt;&lt;endl&lt;&lt;b&lt;&lt;endl;</span></span><br><span class="line">	<span class="built_in">memset</span>(f,<span class="number">0</span>,<span class="built_in">sizeof</span>(f));</span><br><span class="line">	f[<span class="number">0</span>][<span class="number">0</span>][<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;=lena;i++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (j=<span class="number">0</span>;j&lt;=lenb;j++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (i&lt;lena) f[i+<span class="number">1</span>][j][<span class="number">0</span>]=(f[i][j][<span class="number">0</span>]+f[i][j][<span class="number">1</span>])%mod;</span><br><span class="line">			<span class="keyword">if</span> (j&lt;lenb) f[i][j+<span class="number">1</span>][<span class="number">1</span>]=(f[i][j][<span class="number">1</span>]);</span><br><span class="line">			<span class="keyword">if</span> (i&gt;<span class="number">0</span>&amp;&amp;j&lt;lenb&amp;&amp;a[i]!=b[j+<span class="number">1</span>]) f[i][j+<span class="number">1</span>][<span class="number">1</span>]=(f[i][j][<span class="number">0</span>]+f[i][j][<span class="number">1</span>])%mod;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,(f[lena][lenb][<span class="number">0</span>]+f[lena][lenb][<span class="number">1</span>])%mod);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> T;</span><br><span class="line">	<span class="built_in">read</span>(T);<span class="keyword">while</span> (T--) <span class="built_in">solve</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>dp</tag>
        <tag>USACO</tag>
      </tags>
  </entry>
  <entry>
    <title>UVA1608 Non-Boring Sequences</title>
    <url>/2023/07/05/UVA1608-Non-boring-sequences/</url>
    <content><![CDATA[<h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>如果一个序列的任意连续子序列都至少有一个元素唯一，则称这个序列“不无聊”，否则称这个序列“无聊”。给定 $T$ 个序列，求是否“无聊”。</p>
<p>$n\le 2\times 10^5$</p>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>今天学到了一个<strong>启发式分治</strong>的东西。</p>
<p>大致就是每次分治的时候，选择的不一定的是序列的中点，但是复杂度是分出去的小区间的长度。这样做<strong>外加的复杂度</strong>是 $O(\log)$ 级别的。</p>
<p>证明就考虑反着的合并过程，即为启发式合并。</p>
<p>回到这道题。找到区间中一个孤点，那么经过这个点的子序列都是合法的，然后左右分治。</p>
<p>这个孤点显然不一定是中点。所以我们考虑套用<strong>启发式分治</strong>，如何让<strong>找到孤点</strong>这个操作的复杂度是<strong>小区间的长度</strong>。</p>
<p>判断一个点在这个区间是不是孤点是 $O(1)$ 的，所以两个指针，一个从左往右，一个从右往左，如果找到孤点，直接分治。这样找的过程的次数显然就是小区间的长度。</p>
<p>复杂度 $O(n\log n)$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 200005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> put() putchar(<span class="string">&#x27;\n&#x27;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Tp template<span class="string">&lt;typename Ty&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Ts template<span class="string">&lt;typename Ty,typename... Ar&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(<span class="type">int</span> &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> f=<span class="number">1</span>;x=<span class="number">0</span>;<span class="type">char</span> c=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (c&lt;<span class="string">&#x27;0&#x27;</span>||c&gt;<span class="string">&#x27;9&#x27;</span>) &#123;<span class="keyword">if</span> (c==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">-1</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span> (c&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;c&lt;=<span class="string">&#x27;9&#x27;</span>) &#123;x=x*<span class="number">10</span>+c-<span class="string">&#x27;0&#x27;</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> Debug&#123;</span><br><span class="line">	Tp <span class="type">void</span> _debug(<span class="type">char</span>* f,Ty t)&#123;cerr&lt;&lt;f&lt;&lt;<span class="string">&#x27;=&#x27;</span>&lt;&lt;t&lt;&lt;endl;&#125;</span><br><span class="line">	Ts <span class="type">void</span> _debug(<span class="type">char</span>* f,Ty x,Ar... y)&#123;<span class="keyword">while</span>(*f!=<span class="string">&#x27;,&#x27;</span>) cerr&lt;&lt;*f++;cerr&lt;&lt;<span class="string">&#x27;=&#x27;</span>&lt;&lt;x&lt;&lt;<span class="string">&quot;,&quot;</span>;_debug(f+<span class="number">1</span>,y...);&#125;</span><br><span class="line">	Tp ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; os,vector&lt;Ty&gt;&amp; V)&#123;os&lt;&lt;<span class="string">&quot;[&quot;</span>;<span class="keyword">for</span>(<span class="keyword">auto</span>&amp; vv:V) os&lt;&lt;vv&lt;&lt;<span class="string">&quot;,&quot;</span>;os&lt;&lt;<span class="string">&quot;]&quot;</span>;<span class="keyword">return</span> os;&#125;</span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> gdb(...) _debug((char*)#__VA_ARGS__,__VA_ARGS__)</span></span><br><span class="line">&#125;<span class="keyword">using</span> <span class="keyword">namespace</span> Debug;</span><br><span class="line"><span class="type">int</span> n,a[maxn],l[maxn],r[maxn],t[maxn];</span><br><span class="line"><span class="type">int</span> ans;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">calc</span><span class="params">(<span class="type">int</span> L,<span class="type">int</span> R)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> i,j;</span><br><span class="line">	<span class="keyword">if</span> (L&gt;=R) <span class="keyword">return</span> ;</span><br><span class="line">	<span class="type">int</span> flag=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (i=L,j=R;i&lt;=j&amp;&amp;!flag;i++,j--) &#123;</span><br><span class="line">		<span class="keyword">if</span> (l[i]&lt;L&amp;&amp;r[i]&gt;R) &#123;</span><br><span class="line">			<span class="built_in">calc</span>(L,i<span class="number">-1</span>),<span class="built_in">calc</span>(i+<span class="number">1</span>,R);</span><br><span class="line">			flag=<span class="number">1</span>; </span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (flag) <span class="keyword">break</span>; </span><br><span class="line">		<span class="keyword">if</span> (l[j]&lt;L&amp;&amp;r[j]&gt;R) &#123;</span><br><span class="line">			<span class="built_in">calc</span>(L,j<span class="number">-1</span>),<span class="built_in">calc</span>(j+<span class="number">1</span>,R);</span><br><span class="line">			flag=<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (!flag) ans=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> g[maxn],tot;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">solve</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="built_in">read</span>(n);ans=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) t[i]=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">read</span>(a[i]),g[i]=a[i];</span><br><span class="line">	<span class="built_in">sort</span>(g+<span class="number">1</span>,g+<span class="number">1</span>+n);tot=<span class="built_in">unique</span>(g+<span class="number">1</span>,g+<span class="number">1</span>+n)-g<span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) a[i]=<span class="built_in">lower_bound</span>(g+<span class="number">1</span>,g+<span class="number">1</span>+n,a[i])-g;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) l[i]=t[a[i]],t[a[i]]=i;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) t[i]=n+<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (i=n;i&gt;=<span class="number">1</span>;i--) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!t[a[i]]) r[i]=n+<span class="number">1</span>;<span class="keyword">else</span> r[i]=t[a[i]];</span><br><span class="line">		t[a[i]]=i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">calc</span>(<span class="number">1</span>,n);</span><br><span class="line">	<span class="built_in">puts</span>(ans?<span class="string">&quot;non-boring&quot;</span>:<span class="string">&quot;boring&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">  <span class="built_in">freopen</span>(<span class="string">&quot;1.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">	<span class="type">int</span> T;</span><br><span class="line">	<span class="built_in">read</span>(T);</span><br><span class="line">	<span class="keyword">while</span> (T--) <span class="built_in">solve</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>分治</tag>
        <tag>启发式合并</tag>
      </tags>
  </entry>
  <entry>
    <title>WC2021</title>
    <url>/2021/02/15/WC2021/</url>
    <content><![CDATA[<h2 id="DAY-不知道多少天"><a href="#DAY-不知道多少天" class="headerlink" title="DAY -不知道多少天"></a>DAY -不知道多少天</h2><p>老师说今年是线上的，就把我们机房几个还能打的人报了上去。因为众所周知的原因，我连菜到蓝勾都没有。感觉不太能过。</p>
<h2 id="2020-12-31"><a href="#2020-12-31" class="headerlink" title="2020.12.31"></a>2020.12.31</h2><p>好像报上去了？</p>
<p>话说今年WC是不是报了就能进啊。</p>
<h2 id="2020-01-12"><a href="#2020-01-12" class="headerlink" title="2020.01.12"></a>2020.01.12</h2><p>到现在还没搞清楚是线上机试还是线下。</p>
<p>陈指导为代表的第四机房说是线上比赛，但是官网上是线下而且一部分省是要根据WC进行省选的。CCF 这样子也不是一次两次了。</p>
<p><strong>不   愧   是   C   C   F</strong></p>
<h2 id="2020-02-01"><a href="#2020-02-01" class="headerlink" title="2020.02.01"></a>2020.02.01</h2><h4 id="杜子德金句（官方吐槽）："><a href="#杜子德金句（官方吐槽）：" class="headerlink" title="杜子德金句（官方吐槽）："></a>杜子德金句（官方吐槽）：</h4><p>“虽然这次冬令营依然在线上举办，但是<strong>好在</strong>在冬天举办，不像在去年在夏天举办。”</p>
<h4 id="周雨扬金句："><a href="#周雨扬金句：" class="headerlink" title="周雨扬金句："></a>周雨扬金句：</h4><p>“随机化算法非常没有前途。”（上午听了个寂寞）</p>
<p>“打表其实我觉得没什么不好的，但是要被我骂。”</p>
<h4 id="周祖松金句"><a href="#周祖松金句" class="headerlink" title="周祖松金句:"></a>周祖松金句:</h4><p>“休息到 6：20。”（原定 5:30 下课）</p>
<h2 id="2020-02-02-04"><a href="#2020-02-02-04" class="headerlink" title="2020.02.02~04"></a>2020.02.02~04</h2><p>简单的不想听，难的听不懂。</p>
<p>好退役了。</p>
<h2 id="2020-02-05"><a href="#2020-02-05" class="headerlink" title="2020.02.05"></a>2020.02.05</h2><p>cnm落枕了。</p>
<p>要死了&#x2F;dk</p>
<h2 id="2020-02-06"><a href="#2020-02-06" class="headerlink" title="2020.02.06"></a>2020.02.06</h2><p>陈指导和 jxc Au。</p>
<p>FXT Ag。</p>
<p>我打铁了。</p>
<p>我们都有光明的未来。</p>
<h2 id="2020-02-15"><a href="#2020-02-15" class="headerlink" title="2020.02.15"></a>2020.02.15</h2><p>没事干查了下成绩：</p>
<p>$64 &#x3D; 24+20+20$。</p>
<p>mdT2的 $50$ 暴力挂了，本来还有个牌子的 &#x2F;dk。</p>
]]></content>
      <tags>
        <tag>游记</tag>
      </tags>
  </entry>
  <entry>
    <title>WC2022</title>
    <url>/2022/06/29/WC2022/</url>
    <content><![CDATA[<p>课程基本都在摆，不太想听。</p>
<p>至于考试的时候，T1直接跳过，T3写了个70上下的分，T2 写了个正解。</p>
<p>最后 T2 被卡常了，T3 脑瘫开了 freopen 保龄了，痛失 Au。</p>
<p>就这样。没什么好讲的。</p>
]]></content>
      <tags>
        <tag>游记</tag>
      </tags>
  </entry>
  <entry>
    <title>ZJOI2023游记</title>
    <url>/2023/08/28/ZJOI2023%E6%B8%B8%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="NOIP"><a href="#NOIP" class="headerlink" title="NOIP"></a>NOIP</h2><p>NOIP 爆炸，压线省一。省选无望，抱着杭州两日游的心态去玩。</p>
<h2 id="Day-inf"><a href="#Day-inf" class="headerlink" title="Day -inf"></a>Day -inf</h2><p>假装停课。实则足球比赛，好玩！</p>
<p>勇夺市联赛季军！</p>
<h2 id="Day-2"><a href="#Day-2" class="headerlink" title="Day -2"></a>Day -2</h2><p>尝试申请停课。成功。</p>
<p>发现必须用 NOI Linux ，难过。</p>
<p>想起来两年前单挑 NOI Linux 1.0 ，恐惧。</p>
<p>发现 NOI Linux 更新到 2.0 了，并且内置了 Vscode。玩了半个小时就上手了，体验还不错。好玩！</p>
<h2 id="Day-1"><a href="#Day-1" class="headerlink" title="Day -1"></a>Day -1</h2><p>查找杭师大附近娱乐场所ing</p>
<h2 id="Day-0"><a href="#Day-0" class="headerlink" title="Day 0"></a>Day 0</h2><p>第一次省选。老叶地铁做反。</p>
<p>试机没什么意思，键盘还不错。屏幕很小。搓了个 FHQ-Treap 赶快跑路。</p>
<p>吃完晚饭和 qy 骑自行车。骑到一个叫五常湿地的地方，以为跟西溪湿地差不多，实则是一片未开发的农田。</p>
<p>骑到西溪湿地西边，观察到有一片<strong>不可逾越的柏林墙</strong>。打车回去。</p>
<h2 id="Day-1-1"><a href="#Day-1-1" class="headerlink" title="Day 1"></a>Day 1</h2><p>感谢 @Listensnow 早上 6 点的免费叫醒服务。</p>
<p>匆匆吃完早饭去杭师大。坐在我考场左边的左边是 zhoukangyang 。感谢我父母给我取的名字，这可能是我离国家队最近的一次了。</p>
<h3 id="比赛"><a href="#比赛" class="headerlink" title="比赛"></a>比赛</h3><p>T1 一眼签到。</p>
<p>T2 分析了一波可能和割边有关。</p>
<p>T3 数据结构，感觉像是网络流。加入和删除又感觉像是个线段树分治。</p>
<p>T2 dp 了两个小时，我感受到我可能不适合 dp 。过了前两个样例跑路。说不定能骗点分&#x2F;shl</p>
<p>开始搓 T3 暴力。半个小时后模拟了一遍样例二才发现题目看错。改回来后感觉可以启发式合并。感觉有 $36$ 分，跑路。</p>
<p>最后十分钟分析了一波，T3 可能有 $48$。</p>
<p><strong>最好</strong>得分：100+10+48</p>
<h3 id="西溪湿地"><a href="#西溪湿地" class="headerlink" title="西溪湿地"></a>西溪湿地</h3><p>考完以后，跟老叶随便汇报了一下我已经寄掉了。我是究极现充，不想呆在酒店里浪费摆烂，所以打算和 qy 出去玩一圈。</p>
<p>西溪湿地是不错的。不太远，没去过。西湖是有点距离的，而且之前去过几次。</p>
<p>考虑到人生地不熟，还是打车好了，还可以咨询一下司机。半路想起来身份证还在老叶那里。还好西溪湿地不用门票。</p>
<p>里面很大，景色很好。规划的很好，走在里面，感觉很久没有碰见这么多的植物了。</p>
<p><img src="https://s2.loli.net/2023/08/28/9OIoxJuar6FZS7N.jpg" alt="IMG20230401145812"></p>
<p><img src="https://s2.loli.net/2023/08/28/BdxqQswGhjlXuTI.jpg" alt="IMG20230401150235"></p>
<p><img src="https://s2.loli.net/2023/08/28/VQaOxRqWeyp5ALj.jpg" alt="IMG20230401150455"></p>
<p><img src="https://s2.loli.net/2023/08/28/X8E9CrKTawxJbPB.jpg" alt="IMG20230401150936"></p>
<p><img src="https://s2.loli.net/2023/08/28/eFQzgL4ihREd2tD.jpg" alt="IMG20230401151025"></p>
<p><img src="https://s2.loli.net/2023/08/28/X1nTa5c7vQHl8DU.jpg" alt="IMG20230401151443"></p>
<p>初春的植物很绿。里面还有一个小庙。趁着没人，偷偷去敲了两下钟。小庙旁边有垂柳，第一次看见这么多的柳絮，很漂亮。</p>
<p><img src="https://s2.loli.net/2023/08/28/deD247anjts9xVy.jpg" alt="IMG20230401151852"></p>
<p><img src="https://s2.loli.net/2023/08/28/sEepWtyY4Z1chlK.jpg" alt="IMG20230401152124"></p>
<p><img src="https://s2.loli.net/2023/08/28/U5NLGdKCuO1Slbh.jpg" alt="IMG20230401152248"></p>
<p><img src="https://s2.loli.net/2023/08/28/fEyq6JU3gnlSXoK.jpg" alt="IMG20230401152345"></p>
<p><img src="https://s2.loli.net/2023/08/28/S4jlnYyAtJPEraz.jpg" alt="IMG20230401154148"></p>
<p><img src="https://s2.loli.net/2023/08/28/DvYXnS6taLeMq49.jpg" alt="IMG20230401155042"></p>
<p>湿地的一个角落几分钟就有游船游过去。喜欢看船。</p>
<p><img src="https://s2.loli.net/2023/08/28/ciUaeOnD7Mftudh.jpg" alt="IMG20230401171044"></p>
<p>最后去杭州西站看了一眼。有点机场的感觉。</p>
<p>回来的时候地铁差点坐反了，即使全力跑了，还是迟到了几分钟，被老叶骂了。</p>
<h3 id="晚上摆烂"><a href="#晚上摆烂" class="headerlink" title="晚上摆烂"></a>晚上摆烂</h3><p>看球，曼城踢的是真好。</p>
<p>王者，Listensnow 强强！</p>
<p>汉堡王好吃。</p>
<h2 id="Day-2-1"><a href="#Day-2-1" class="headerlink" title="Day 2"></a>Day 2</h2><p>开考前 qy 告诉我小图灵数据出了，分数也出了。在感叹小图灵工作效率的同时，发现我 T1 挂没了，T3 挂了一半。</p>
<p>心态有些小崩。好在 NOIP 爆炸，知道进省队无望，于是改变策略。</p>
<p><strong>这也许就是没有长衫的孔乙己，心甘情愿的去搬砖。</strong></p>
<h3 id="比赛-1"><a href="#比赛-1" class="headerlink" title="比赛"></a>比赛</h3><p>T1 一眼博弈论+大模拟。不是很想写。</p>
<p>发现部分分很多，改变心态。</p>
<p>T2 一眼基环树&#x2F;树形dp，不是很想写。</p>
<p>发现部分分很多，改变心态。</p>
<p>T3 一眼不可做题，思考了 10 分钟感觉可以拿两分。</p>
<p>先搓 T2 。先把枚举的分写了。然后写 A，B。感觉都是很 Common 的。</p>
<p>口胡了 C，D 两个部分以后，不好写，搓 T1。</p>
<p>T1 正当我写一条链的时候，感觉步数小于等于 9 而且下一部分的包是包含这链的部分的。大喊一声血赚。</p>
<p>发现 5，6 不太会写。区区 $10$ 分，不要也罢。于是摆烂。</p>
<p><strong>最好</strong>得分：55+40+2</p>
<h3 id="回家"><a href="#回家" class="headerlink" title="回家"></a>回家</h3><p>地铁回去。比来的时候快得多了。</p>
<p>回去的路上，本来就 2 个小时的高铁一路上停了三次，总计时间差不多 3 个多小时。</p>
<p>累。</p>
<p>但是 FXT 会进队！</p>
]]></content>
      <tags>
        <tag>游记</tag>
      </tags>
  </entry>
  <entry>
    <title>Bitset的相关用法</title>
    <url>/2022/11/18/bitset%E7%9A%84%E7%9B%B8%E5%85%B3%E7%94%A8%E6%B3%95/</url>
    <content><![CDATA[<p>今天碰到了 bitset 题，基本操作想了好久，索性记录一下。</p>
<h4 id="内置函数"><a href="#内置函数" class="headerlink" title="内置函数"></a>内置函数</h4><ul>
<li><code>s.set()</code> $s$ 中的所有都赋值为 $1$</li>
<li><code>s.reset()</code> $s$ 中的所有都复制为 $0$</li>
<li><code>s.count()</code> $s$ 中 $1$ 的个数</li>
</ul>
<h4 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h4><p>截取出 $s$ 的 $[l,r]$ 这一段。</p>
<p><code>A=(s&gt;&gt;(r+1))&lt;&lt;(r+1);</code></p>
<p>A 表示 $s$ 的 $[r+1,+\infty)$ 。</p>
<p><code>B=(s&gt;&gt;l)&lt;&lt;l;</code></p>
<p>B 表示 $s$ 的 $[l,+\infty)$</p>
<p><code>C=A^B;</code></p>
<p>C 即为截取出来的这一段。</p>
<p>bitset 中的很多操作都是在一基础上完成的。</p>
]]></content>
      <tags>
        <tag>学习笔记</tag>
        <tag>bitset</tag>
      </tags>
  </entry>
  <entry>
    <title>Bzoj1181</title>
    <url>/2022/11/15/bzoj1181/</url>
    <content><![CDATA[<h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><p>分最大最小两种情况考虑</p>
<h4 id="最大"><a href="#最大" class="headerlink" title="最大"></a>最大</h4><p>直接加满，然后模拟</p>
<h4 id="最小"><a href="#最小" class="headerlink" title="最小"></a>最小</h4><p>肯定是把别人的加满。</p>
<p>好像直接求比较困难，考虑二分转化为判定性问题。</p>
<p>假设判定第 $x$ 个政党有 $t$ 个席位时是否可以。</p>
<p>令 $f[i][j]$ 表示前 $i$ 个政党控制 $j$ 个席位最少<strong>再</strong>使用多少选票。然后有两个限制条件：</p>
<ul>
<li>至少有 5% 的票。（同时也告诉我们最多只有 $20$ 个政党）</li>
<li>$\dfrac{v_i}{k}&gt;(or \ge )\dfrac{a_x}{t+1}$</li>
</ul>
<p>然后转移一下就好。</p>
<p>另外，记得开够数组&#x2F;ll</p>
<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 205</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> put() putchar(<span class="string">&#x27;\n&#x27;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Tp template<span class="string">&lt;typename Ty&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Ts template<span class="string">&lt;typename Ty,typename... Ar&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(<span class="type">int</span> &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> f=<span class="number">1</span>;x=<span class="number">0</span>;<span class="type">char</span> c=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (c&lt;<span class="string">&#x27;0&#x27;</span>||c&gt;<span class="string">&#x27;9&#x27;</span>) &#123;<span class="keyword">if</span> (c==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">-1</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span> (c&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;c&lt;=<span class="string">&#x27;9&#x27;</span>) &#123;x=x*<span class="number">10</span>+c-<span class="string">&#x27;0&#x27;</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> Debug&#123;</span><br><span class="line">	Tp <span class="type">void</span> _debug(<span class="type">char</span>* f,Ty t)&#123;cerr&lt;&lt;f&lt;&lt;<span class="string">&#x27;=&#x27;</span>&lt;&lt;t&lt;&lt;endl;&#125;</span><br><span class="line">	Ts <span class="type">void</span> _debug(<span class="type">char</span>* f,Ty x,Ar... y)&#123;<span class="keyword">while</span>(*f!=<span class="string">&#x27;,&#x27;</span>) cerr&lt;&lt;*f++;cerr&lt;&lt;<span class="string">&#x27;=&#x27;</span>&lt;&lt;x&lt;&lt;<span class="string">&quot;,&quot;</span>;_debug(f+<span class="number">1</span>,y...);&#125;</span><br><span class="line">	Tp ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; os,vector&lt;Ty&gt;&amp; V)&#123;os&lt;&lt;<span class="string">&quot;[&quot;</span>;<span class="keyword">for</span>(<span class="keyword">auto</span>&amp; vv:V) os&lt;&lt;vv&lt;&lt;<span class="string">&quot;,&quot;</span>;os&lt;&lt;<span class="string">&quot;]&quot;</span>;<span class="keyword">return</span> os;&#125;</span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> gdb(...) _debug((char*)#__VA_ARGS__,__VA_ARGS__)</span></span><br><span class="line">&#125;<span class="keyword">using</span> <span class="keyword">namespace</span> Debug;</span><br><span class="line"><span class="type">int</span> v,n,m,rest;</span><br><span class="line"><span class="type">int</span> a[maxn],b[maxn];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">	<span class="type">int</span> id,b,num;</span><br><span class="line">	<span class="built_in">node</span>(<span class="type">int</span> a=<span class="number">0</span>,<span class="type">int</span> c=<span class="number">0</span>,<span class="type">int</span> d=<span class="number">0</span>) &#123;id=a;b=c;num=d;&#125;</span><br><span class="line">	<span class="type">bool</span> <span class="keyword">operator</span> &lt;(<span class="type">const</span> node &amp;x) <span class="type">const</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (b*x.num!=num*x.b) <span class="keyword">return</span> b*x.num&lt;x.b*num;</span><br><span class="line">		<span class="keyword">return</span> id&gt;x.id;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;tr[<span class="number">205</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">cmp</span><span class="params">(node x,node y)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (y.b*x.num!=y.num*x.b) <span class="keyword">return</span> y.b*x.num&lt;x.b*y.num;</span><br><span class="line">	<span class="keyword">return</span> y.id&gt;x.id;</span><br><span class="line">&#125;</span><br><span class="line">priority_queue&lt;node&gt;q;</span><br><span class="line"><span class="type">int</span> d[maxn],f[<span class="number">25</span>][<span class="number">205</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> id,<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> i,j,k,tot=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) <span class="keyword">if</span> (i^id) tr[++tot]=(node)&#123;i,b[i],<span class="number">1</span>&#125;;</span><br><span class="line">	<span class="built_in">sort</span>(tr+<span class="number">1</span>,tr+<span class="number">1</span>+tot,cmp);tot=<span class="built_in">min</span>(tot,<span class="number">19ll</span>);</span><br><span class="line">	<span class="built_in">memset</span>(f,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(f));</span><br><span class="line">	f[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=tot;i++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (j=<span class="number">0</span>;j&lt;=m-val;j++) &#123;</span><br><span class="line">			f[i][j]=f[i<span class="number">-1</span>][j];</span><br><span class="line">			<span class="keyword">for</span> (k=<span class="number">1</span>;k&lt;=j;k++) &#123;</span><br><span class="line">				f[i][j]=<span class="built_in">min</span>(f[i][j],f[i<span class="number">-1</span>][j-k]+<span class="built_in">max</span>(<span class="number">0ll</span>,<span class="built_in">max</span>((k*a[id]-(tr[i].id&lt;id))/(val+<span class="number">1</span>)+<span class="number">1</span>,(v+<span class="number">19</span>)/<span class="number">20</span>)-tr[i].b));</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> f[tot][m-val]&lt;=rest;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> i,j,k;</span><br><span class="line">	<span class="built_in">read</span>(v);<span class="built_in">read</span>(n);<span class="built_in">read</span>(m);rest=v;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">read</span>(a[i]),rest-=a[i];</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (j=<span class="number">1</span>;j&lt;=n;j++) b[j]=a[j],d[j]=<span class="number">0</span>;b[i]+=rest;</span><br><span class="line">		<span class="keyword">for</span> (j=<span class="number">1</span>;j&lt;=n;j++) <span class="keyword">if</span> (b[j]*<span class="number">20</span>&lt;v) b[j]=<span class="number">0</span>;<span class="keyword">else</span> q.<span class="built_in">push</span>(<span class="built_in">node</span>(j,b[j],<span class="number">1</span>)); </span><br><span class="line">		<span class="keyword">for</span> (j=<span class="number">1</span>;j&lt;=m;j++) &#123;</span><br><span class="line">			<span class="keyword">auto</span> tmp=q.<span class="built_in">top</span>();q.<span class="built_in">pop</span>();</span><br><span class="line">			d[tmp.id]++;q.<span class="built_in">push</span>(<span class="built_in">node</span>(tmp.id,tmp.b,tmp.num+<span class="number">1</span>));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%lld &quot;</span>,d[i]);</span><br><span class="line">		<span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) q.<span class="built_in">pop</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">put</span>();</span><br><span class="line"><span class="comment">//	for (j=1;j&lt;=n;j++) b[j]=a[j];cerr&lt;&lt;check(6,40);return 0;</span></span><br><span class="line"><span class="comment">//	printf(&quot;%lld %lld\n&quot;,check(8,2),check(8,1));</span></span><br><span class="line">	<span class="keyword">for</span> (j=<span class="number">1</span>;j&lt;=n;j++) b[j]=a[j];</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (a[i]*<span class="number">20</span>&lt;v) &#123;<span class="built_in">printf</span>(<span class="string">&quot;0 &quot;</span>);<span class="keyword">continue</span>;&#125;</span><br><span class="line">		<span class="type">int</span> l=<span class="number">-1</span>,r=m+<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">while</span> (l+<span class="number">1</span>&lt;r) &#123;</span><br><span class="line">			<span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">			<span class="keyword">if</span> (<span class="built_in">check</span>(i,mid)) r=mid;</span><br><span class="line">			<span class="keyword">else</span> l=mid;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%lld &quot;</span>,r);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">13 16 17 14 19 23 23 14 14 15 15 15 14 16</span></span><br><span class="line"><span class="comment">0 2 3 0 4 7 7 0 0 0 0 0 0 2</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>dp</tag>
        <tag>bzoj</tag>
      </tags>
  </entry>
  <entry>
    <title>Bzoj1041</title>
    <url>/2022/11/16/bzoj1041/</url>
    <content><![CDATA[<h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><p>求 $x^2+y^2&#x3D;r^2$ 的个数。</p>
<p>移项，$y^2&#x3D;(r-x)(r+x)$</p>
<p>令 $(r-x,r+x)&#x3D;d$ ，即 $r-x&#x3D;du,r+x&#x3D;dv,(u,v)&#x3D;1$</p>
<p>所以 $y^2&#x3D;d^2\cdot uv$</p>
<p>而 $(u,v)&#x3D;1$ ，所以 $u,v$ 分别都为完全平方数。</p>
<p>令 $u&#x3D;s^2,v&#x3D;t^2$</p>
<p>所以 $x&#x3D;\dfrac{t^2-s^2}{2}\cdot d,t&#x3D;dst,r&#x3D;\dfrac{t^2+s^2}{2}\cdot d$</p>
<p>枚举 $2r$ 的因数 $d$，再枚举 $s$ 或者 $t$，就可以了。</p>
<p>复杂度应该和杜教筛差不多，大约 $O(n^\frac{3}{4})$</p>
<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> put() putchar(<span class="string">&#x27;\n&#x27;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Tp template<span class="string">&lt;typename Ty&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Ts template<span class="string">&lt;typename Ty,typename... Ar&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(<span class="type">int</span> &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> f=<span class="number">1</span>;x=<span class="number">0</span>;<span class="type">char</span> c=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (c&lt;<span class="string">&#x27;0&#x27;</span>||c&gt;<span class="string">&#x27;9&#x27;</span>) &#123;<span class="keyword">if</span> (c==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">-1</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span> (c&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;c&lt;=<span class="string">&#x27;9&#x27;</span>) &#123;x=x*<span class="number">10</span>+c-<span class="string">&#x27;0&#x27;</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> Debug&#123;</span><br><span class="line">	Tp <span class="type">void</span> _debug(<span class="type">char</span>* f,Ty t)&#123;cerr&lt;&lt;f&lt;&lt;<span class="string">&#x27;=&#x27;</span>&lt;&lt;t&lt;&lt;endl;&#125;</span><br><span class="line">	Ts <span class="type">void</span> _debug(<span class="type">char</span>* f,Ty x,Ar... y)&#123;<span class="keyword">while</span>(*f!=<span class="string">&#x27;,&#x27;</span>) cerr&lt;&lt;*f++;cerr&lt;&lt;<span class="string">&#x27;=&#x27;</span>&lt;&lt;x&lt;&lt;<span class="string">&quot;,&quot;</span>;_debug(f+<span class="number">1</span>,y...);&#125;</span><br><span class="line">	Tp ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; os,vector&lt;Ty&gt;&amp; V)&#123;os&lt;&lt;<span class="string">&quot;[&quot;</span>;<span class="keyword">for</span>(<span class="keyword">auto</span>&amp; vv:V) os&lt;&lt;vv&lt;&lt;<span class="string">&quot;,&quot;</span>;os&lt;&lt;<span class="string">&quot;]&quot;</span>;<span class="keyword">return</span> os;&#125;</span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> gdb(...) _debug((char*)#__VA_ARGS__,__VA_ARGS__)</span></span><br><span class="line">&#125;<span class="keyword">using</span> <span class="keyword">namespace</span> Debug;</span><br><span class="line"><span class="type">int</span> R,n,ans; </span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> d)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> now=n/d,i;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i*i&lt;=now;i++) &#123;</span><br><span class="line">		<span class="type">int</span> sqt=<span class="built_in">sqrt</span>(now-i*i);</span><br><span class="line">		<span class="keyword">if</span> (sqt*sqt+i*i==now&amp;&amp;__gcd(i,sqt)==<span class="number">1</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> ((sqt*sqt-i*i)%<span class="number">2</span>) <span class="keyword">continue</span>;<span class="comment">//必须是2的倍数</span></span><br><span class="line">			<span class="type">int</span> x=(sqt*sqt-i*i)/<span class="number">2</span>*d;</span><br><span class="line">			<span class="type">int</span> y=d*i*sqt;</span><br><span class="line">			<span class="keyword">if</span> (x&gt;<span class="number">0</span>&amp;&amp;y&gt;<span class="number">0</span>&amp;&amp;x*x+y*y==R*R) ans+=<span class="number">2</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> i,j,k;</span><br><span class="line">	<span class="built_in">read</span>(R);n=<span class="number">2</span>*R;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i*i&lt;n;i++)</span><br><span class="line">		<span class="keyword">if</span> (n%i==<span class="number">0</span>) &#123;</span><br><span class="line">			<span class="built_in">solve</span>(i);<span class="built_in">solve</span>(n/i);</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">if</span> (i*i==n) <span class="built_in">solve</span>(i);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,(ans+<span class="number">1</span>)*<span class="number">4</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



]]></content>
      <tags>
        <tag>数学</tag>
        <tag>bzoj</tag>
      </tags>
  </entry>
  <entry>
    <title>Bzoj1183  [COI2008] UMNOZAK</title>
    <url>/2023/09/21/bzoj1183-COI2008-UMNOZAK-1/</url>
    <content><![CDATA[<h1 id="COI2008-UMNOZAK"><a href="#COI2008-UMNOZAK" class="headerlink" title="[COI2008] UMNOZAK"></a>[COI2008] UMNOZAK</h1><p><a href="https://www.luogu.com.cn/problem/P6400">https://www.luogu.com.cn/problem/P6400</a></p>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>首先发现一个性质，一个数的位数积$\le $自身。所以位数积 $\le \sqrt R&#x3D;10^9$</p>
<p>可以枚举到的数位积（质因子只有 $2,3,5,7$）的个数是很少的，大约五千个，设为 $m$。考虑枚举这个 $p$，然后就转化为了数位 dp，数位积为 $p$ 且小于等于 $r$ 的个数。</p>
<p>数位dp是平凡的，记忆化搜索。</p>
<p>复杂度 $O(m\log n)$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> put() putchar(<span class="string">&#x27;\n&#x27;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Tp template<span class="string">&lt;typename Ty&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Ts template<span class="string">&lt;typename Ty,typename... Ar&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">(<span class="type">int</span> &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> f=<span class="number">1</span>;x=<span class="number">0</span>;<span class="type">char</span> c=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (c&lt;<span class="string">&#x27;0&#x27;</span>||c&gt;<span class="string">&#x27;9&#x27;</span>) &#123;<span class="keyword">if</span> (c==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">-1</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span> (c&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;c&lt;=<span class="string">&#x27;9&#x27;</span>) &#123;x=x*<span class="number">10</span>+c-<span class="string">&#x27;0&#x27;</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> Debug&#123;</span><br><span class="line">	Tp <span class="type">void</span> _debug(<span class="type">char</span>* f,Ty t)&#123;cerr&lt;&lt;f&lt;&lt;<span class="string">&#x27;=&#x27;</span>&lt;&lt;t&lt;&lt;endl;&#125;</span><br><span class="line">	Ts <span class="type">void</span> _debug(<span class="type">char</span>* f,Ty x,Ar... y)&#123;<span class="keyword">while</span>(*f!=<span class="string">&#x27;,&#x27;</span>) cerr&lt;&lt;*f++;cerr&lt;&lt;<span class="string">&#x27;=&#x27;</span>&lt;&lt;x&lt;&lt;<span class="string">&quot;,&quot;</span>;_debug(f+<span class="number">1</span>,y...);&#125;</span><br><span class="line">	Tp ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; os,vector&lt;Ty&gt;&amp; V)&#123;os&lt;&lt;<span class="string">&quot;[&quot;</span>;<span class="keyword">for</span>(<span class="keyword">auto</span>&amp; vv:V) os&lt;&lt;vv&lt;&lt;<span class="string">&quot;,&quot;</span>;os&lt;&lt;<span class="string">&quot;]&quot;</span>;<span class="keyword">return</span> os;&#125;</span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> gdb(...) _debug((char*)#__VA_ARGS__,__VA_ARGS__)</span></span><br><span class="line">&#125;<span class="keyword">using</span> <span class="keyword">namespace</span> Debug;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mk make_pair</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">power</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y=mod<span class="number">-2</span>)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> sum=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (y) &#123;</span><br><span class="line">		<span class="keyword">if</span> (y&amp;<span class="number">1</span>) sum=sum*x%mod;</span><br><span class="line">		x=x*x%mod;y&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">popcount</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (x) x/=<span class="number">10</span>,sum++;</span><br><span class="line">	<span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> base=<span class="number">1e9</span>;</span><br><span class="line">map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; f[<span class="number">19</span>],vis[<span class="number">19</span>];</span><br><span class="line"><span class="type">int</span> L,R,prime[<span class="number">5</span>]=&#123;<span class="number">0</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>&#125;;</span><br><span class="line"><span class="type">int</span> pw[<span class="number">20</span>],ans;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> now,<span class="type">int</span> sum,<span class="type">int</span> r,<span class="type">int</span> lim)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (now==<span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (sum==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (!lim&amp;&amp;vis[now][sum]) <span class="keyword">return</span> f[now][sum];</span><br><span class="line">	<span class="type">int</span> res=<span class="number">0</span>,i;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=(lim?r/pw[now<span class="number">-1</span>]%<span class="number">10</span>:<span class="number">9</span>);i++) <span class="keyword">if</span> (sum%i==<span class="number">0</span>) &#123;</span><br><span class="line">		res+=<span class="built_in">solve</span>(now<span class="number">-1</span>,sum/i,r,lim&amp;(i==r/pw[now<span class="number">-1</span>]%<span class="number">10</span>));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (!lim) f[now][sum]=res,vis[now][sum]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> total;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">calc</span><span class="params">(<span class="type">int</span> sum)</span> </span>&#123;</span><br><span class="line">	++total;</span><br><span class="line">	<span class="type">int</span> l=(L+sum<span class="number">-1</span>)/sum,r=R/sum,i;</span><br><span class="line">	<span class="keyword">if</span> (r==<span class="number">0</span>) <span class="keyword">return</span> ;</span><br><span class="line">	<span class="type">int</span> tmp=<span class="built_in">popcount</span>(r);</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;tmp;i++) ans+=<span class="built_in">solve</span>(i,sum,r,<span class="number">0</span>);</span><br><span class="line">	ans+=<span class="built_in">solve</span>(tmp,sum,r,<span class="number">1</span>);</span><br><span class="line">	</span><br><span class="line">	l=<span class="built_in">max</span>(l<span class="number">-1</span>,<span class="number">0ll</span>);</span><br><span class="line">	<span class="keyword">if</span> (!l) <span class="keyword">return</span> ;</span><br><span class="line">	tmp=<span class="built_in">popcount</span>(l);</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;tmp;i++) ans-=<span class="built_in">solve</span>(i,sum,l,<span class="number">0</span>);</span><br><span class="line">	ans-=<span class="built_in">solve</span>(tmp,sum,l,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> now,<span class="type">int</span> sum)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (sum&gt;base) <span class="keyword">return</span> ;</span><br><span class="line">	<span class="keyword">if</span> (now==<span class="number">5</span>) <span class="keyword">return</span> <span class="built_in">calc</span>(sum),<span class="built_in">void</span>();</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">30</span>;i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (sum&lt;base) <span class="built_in">dfs</span>(now+<span class="number">1</span>,sum);</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">return</span> ;</span><br><span class="line">		sum=sum*prime[now];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="built_in">read</span>(L),<span class="built_in">read</span>(R);</span><br><span class="line">	<span class="keyword">for</span> (pw[<span class="number">0</span>]=<span class="number">1</span>,i=<span class="number">1</span>;i&lt;=<span class="number">18</span>;i++) pw[i]=pw[i<span class="number">-1</span>]*<span class="number">10</span>;</span><br><span class="line">	<span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



]]></content>
      <tags>
        <tag>数位dp</tag>
        <tag>bzoj</tag>
      </tags>
  </entry>
  <entry>
    <title>Bzoj1444  [JSOI2009] 有趣的游戏</title>
    <url>/2023/09/22/bzoj1444-JSOI2009-%E6%9C%89%E8%B6%A3%E7%9A%84%E6%B8%B8%E6%88%8F/</url>
    <content><![CDATA[<h1 id="JSOI2009-有趣的游戏"><a href="#JSOI2009-有趣的游戏" class="headerlink" title="[JSOI2009] 有趣的游戏"></a>[JSOI2009] 有趣的游戏</h1><p><a href="https://www.luogu.com.cn/problem/P6125">https://www.luogu.com.cn/problem/P6125</a></p>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>首先，问题等价于建出 AC 自动机之后，从 $0$ 开始随机走，如果走到一个字符串的末节点则停止。求每个末节点为停止节点的概率。</p>
<p>一种天真的想法是求到每个节点的概率。但是由根节点的概率一定是 $1$，但是其他节点可以转移到根节点而矛盾。（实际上这样定义的问题很多）。</p>
<p>对于末节点，<strong>如果经过那么只会经过一次。经过的期望次数就是以其为末节点的概率。</strong></p>
<p>考虑求出到经过每个节点的期望次数，这是好做的。高斯消元一下即可。</p>
<p>复杂度 $O(n^3l^3)$。好像有更高妙的生成函数做法，准备 NOIP 之后（如果还有之后）再搞。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 105</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> put() putchar(<span class="string">&#x27;\n&#x27;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Tp template<span class="string">&lt;typename Ty&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Ts template<span class="string">&lt;typename Ty,typename... Ar&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">(<span class="type">int</span> &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> f=<span class="number">1</span>;x=<span class="number">0</span>;<span class="type">char</span> c=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (c&lt;<span class="string">&#x27;0&#x27;</span>||c&gt;<span class="string">&#x27;9&#x27;</span>) &#123;<span class="keyword">if</span> (c==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">-1</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span> (c&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;c&lt;=<span class="string">&#x27;9&#x27;</span>) &#123;x=x*<span class="number">10</span>+c-<span class="string">&#x27;0&#x27;</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> Debug&#123;</span><br><span class="line">	Tp <span class="type">void</span> _debug(<span class="type">char</span>* f,Ty t)&#123;cerr&lt;&lt;f&lt;&lt;<span class="string">&#x27;=&#x27;</span>&lt;&lt;t&lt;&lt;endl;&#125;</span><br><span class="line">	Ts <span class="type">void</span> _debug(<span class="type">char</span>* f,Ty x,Ar... y)&#123;<span class="keyword">while</span>(*f!=<span class="string">&#x27;,&#x27;</span>) cerr&lt;&lt;*f++;cerr&lt;&lt;<span class="string">&#x27;=&#x27;</span>&lt;&lt;x&lt;&lt;<span class="string">&quot;,&quot;</span>;_debug(f+<span class="number">1</span>,y...);&#125;</span><br><span class="line">	Tp ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; os,vector&lt;Ty&gt;&amp; V)&#123;os&lt;&lt;<span class="string">&quot;[&quot;</span>;<span class="keyword">for</span>(<span class="keyword">auto</span>&amp; vv:V) os&lt;&lt;vv&lt;&lt;<span class="string">&quot;,&quot;</span>;os&lt;&lt;<span class="string">&quot;]&quot;</span>;<span class="keyword">return</span> os;&#125;</span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> gdb(...) _debug((char*)#__VA_ARGS__,__VA_ARGS__)</span></span><br><span class="line">&#125;<span class="keyword">using</span> <span class="keyword">namespace</span> Debug;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mk make_pair</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">power</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y=mod<span class="number">-2</span>)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> sum=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (y) &#123;</span><br><span class="line">		<span class="keyword">if</span> (y&amp;<span class="number">1</span>) sum=sum*x%mod;</span><br><span class="line">		x=x*x%mod;y&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,l,m;</span><br><span class="line"><span class="type">double</span> w[<span class="number">27</span>];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">yyy</span> &#123;</span><br><span class="line">	<span class="type">int</span> flag,fail;</span><br><span class="line">	<span class="type">int</span> nex[<span class="number">11</span>];</span><br><span class="line">&#125;a[<span class="number">1005</span>];</span><br><span class="line"><span class="type">int</span> cnt,endpos[maxn];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> id,string s)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> now=<span class="number">0</span>,i;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;l;i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!a[now].nex[s[i]-<span class="string">&#x27;A&#x27;</span>]) a[now].nex[s[i]-<span class="string">&#x27;A&#x27;</span>]=++cnt;</span><br><span class="line">		now=a[now].nex[s[i]-<span class="string">&#x27;A&#x27;</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	a[now].flag=<span class="number">1</span>;</span><br><span class="line">	endpos[id]=now;</span><br><span class="line">&#125;</span><br><span class="line">queue&lt;<span class="type">int</span>&gt;q;</span><br><span class="line"><span class="type">double</span> b[maxn][maxn],ans[maxn];</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> eps=<span class="number">1e-7</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">guess</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> i,j,k;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="type">int</span> id=i;</span><br><span class="line">		<span class="keyword">for</span> (j=i;j&lt;=n;j++) <span class="keyword">if</span> (<span class="built_in">abs</span>(b[j][i])&gt;<span class="built_in">abs</span>(b[id][i])) id=j;</span><br><span class="line">		<span class="keyword">for</span> (j=i;j&lt;=n+<span class="number">1</span>;j++) <span class="built_in">swap</span>(b[i][j],b[id][j]);</span><br><span class="line">		<span class="keyword">for</span> (j=i+<span class="number">1</span>;j&lt;=n;j++) &#123;</span><br><span class="line">			<span class="type">double</span> r=b[j][i]/b[i][i];</span><br><span class="line">			<span class="keyword">for</span> (k=i;k&lt;=n+<span class="number">1</span>;k++) b[j][k]-=b[i][k]*r; </span><br><span class="line">		&#125;</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">for</span> (i=n;i&gt;=<span class="number">0</span>;i--) &#123;</span><br><span class="line">		<span class="keyword">for</span> (j=i+<span class="number">1</span>;j&lt;=n;j++) b[i][cnt+<span class="number">1</span>]-=ans[j]*b[i][j];</span><br><span class="line">		ans[i]=b[i][n+<span class="number">1</span>]/b[i][i];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">built</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> i,j,x;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;m;i++) <span class="keyword">if</span> (a[<span class="number">0</span>].nex[i]) q.<span class="built_in">push</span>(a[<span class="number">0</span>].nex[i]);</span><br><span class="line">	<span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">		x=q.<span class="built_in">front</span>();q.<span class="built_in">pop</span>();</span><br><span class="line">		<span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;m;i++) </span><br><span class="line">			<span class="keyword">if</span> (a[x].nex[i]) q.<span class="built_in">push</span>(a[x].nex[i]),a[a[x].nex[i]].fail=a[a[x].fail].nex[i]; </span><br><span class="line">			<span class="keyword">else</span> a[x].nex[i]=a[a[x].fail].nex[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;=cnt;i++) <span class="keyword">if</span> (!a[i].flag) &#123;</span><br><span class="line">		<span class="keyword">for</span> (j=<span class="number">0</span>;j&lt;m;j++)</span><br><span class="line">			b[a[i].nex[j]][i]+=w[j];<span class="comment">//,gdb(a[i].nex[j],i,w[j]);</span></span><br><span class="line">	&#125;   </span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;=cnt;i++) b[i][i]-=<span class="number">1</span>;</span><br><span class="line">	b[<span class="number">0</span>][cnt+<span class="number">1</span>]=<span class="number">-1</span>;</span><br><span class="line">	<span class="built_in">guess</span>(cnt);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> i,j,x,y;string s;</span><br><span class="line">	<span class="built_in">read</span>(n);<span class="built_in">read</span>(l);<span class="built_in">read</span>(m);</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;m;i++) <span class="built_in">read</span>(x),<span class="built_in">read</span>(y),w[i]=<span class="number">1.0</span>*<span class="built_in">max</span>(x*<span class="number">1.0</span>,eps)/y;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		cin&gt;&gt;s;</span><br><span class="line">		<span class="built_in">insert</span>(i,s);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">built</span>();</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">printf</span>(<span class="string">&quot;%.2lf\n&quot;</span>,<span class="built_in">max</span>(<span class="number">0.0</span>,ans[endpos[i]]));</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>期望</tag>
        <tag>bzoj</tag>
        <tag>高斯消元</tag>
        <tag>AC自动机</tag>
      </tags>
  </entry>
  <entry>
    <title>Bzoj1513</title>
    <url>/2022/06/29/bzoj1513/</url>
    <content><![CDATA[<h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><p>线段树套线段树，标记永久化。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 1005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> put() putchar(<span class="string">&#x27;\n&#x27;</span>)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(<span class="type">int</span> &amp;x)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> f=<span class="number">1</span>;x=<span class="number">0</span>;<span class="type">char</span> c=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span> (c&lt;<span class="string">&#x27;0&#x27;</span>||c&gt;<span class="string">&#x27;9&#x27;</span>) &#123;<span class="keyword">if</span> (c==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">-1</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">while</span> (c&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;c&lt;=<span class="string">&#x27;9&#x27;</span>) &#123;x=x*<span class="number">10</span>+c-<span class="string">&#x27;0&#x27;</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,m,k;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">sy</span>&#123;</span><br><span class="line">	<span class="type">int</span> f[maxn&lt;&lt;<span class="number">2</span>],lazy[maxn&lt;&lt;<span class="number">2</span>];</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Pushup</span><span class="params">(<span class="type">int</span> rt)</span> </span>&#123;f[rt]=<span class="built_in">max</span>(f[rt&lt;&lt;<span class="number">1</span>],f[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]);&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Update</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> rt,<span class="type">int</span> head,<span class="type">int</span> tail,<span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">		f[rt]=<span class="built_in">max</span>(f[rt],k);</span><br><span class="line">		<span class="keyword">if</span> (head&lt;=l&amp;&amp;r&lt;=tail) <span class="keyword">return</span> lazy[rt]=<span class="built_in">max</span>(lazy[rt],k),<span class="built_in">void</span>();</span><br><span class="line">		<span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span> (head&lt;=mid) <span class="built_in">Update</span>(l,mid,rt&lt;&lt;<span class="number">1</span>,head,tail,k);</span><br><span class="line">		<span class="keyword">if</span> (tail&gt;mid)  <span class="built_in">Update</span>(mid+<span class="number">1</span>,r,rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,head,tail,k);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">Query</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> rt,<span class="type">int</span> head,<span class="type">int</span> tail)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (head&lt;=l&amp;&amp;r&lt;=tail) <span class="keyword">return</span> f[rt];</span><br><span class="line">	    <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>,tmp1=<span class="number">0</span>,tmp2=<span class="number">0</span>,tmp3=lazy[rt];</span><br><span class="line">	    <span class="keyword">if</span> (head&lt;=mid) tmp1=<span class="built_in">Query</span>(l,mid,rt&lt;&lt;<span class="number">1</span>,head,tail);</span><br><span class="line">	    <span class="keyword">if</span> (tail&gt;mid)  tmp2=<span class="built_in">Query</span>(mid+<span class="number">1</span>,r,rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,head,tail);</span><br><span class="line">	    <span class="keyword">return</span> <span class="built_in">max</span>(tmp1,<span class="built_in">max</span>(tmp2,tmp3));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">sx</span>&#123;</span><br><span class="line">	sy f[maxn&lt;&lt;<span class="number">2</span>],lazy[maxn&lt;&lt;<span class="number">2</span>];</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Update</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> rt,<span class="type">int</span> head,<span class="type">int</span> tail,<span class="type">int</span> heady,<span class="type">int</span> taily,<span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">		f[rt].<span class="built_in">Update</span>(<span class="number">1</span>,m,<span class="number">1</span>,heady,taily,k);</span><br><span class="line">		<span class="keyword">if</span> (head&lt;=l&amp;&amp;r&lt;=tail) <span class="keyword">return</span> lazy[rt].<span class="built_in">Update</span>(<span class="number">1</span>,m,<span class="number">1</span>,heady,taily,k),<span class="built_in">void</span>();</span><br><span class="line">		<span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span> (head&lt;=mid) <span class="built_in">Update</span>(l,mid,rt&lt;&lt;<span class="number">1</span>,head,tail,heady,taily,k);</span><br><span class="line">		<span class="keyword">if</span> (tail&gt;mid)  <span class="built_in">Update</span>(mid+<span class="number">1</span>,r,rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,head,tail,heady,taily,k); </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">Query</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> rt,<span class="type">int</span> head,<span class="type">int</span> tail,<span class="type">int</span> heady,<span class="type">int</span> taily)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (head&lt;=l&amp;&amp;r&lt;=tail) <span class="keyword">return</span> f[rt].<span class="built_in">Query</span>(<span class="number">1</span>,m,<span class="number">1</span>,heady,taily);</span><br><span class="line">		<span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>,tmp1=<span class="number">0</span>,tmp2=<span class="number">0</span>,tmp3=lazy[rt].<span class="built_in">Query</span>(<span class="number">1</span>,m,<span class="number">1</span>,heady,taily);</span><br><span class="line">		<span class="keyword">if</span> (head&lt;=mid) tmp1=<span class="built_in">Query</span>(l,mid,rt&lt;&lt;<span class="number">1</span>,head,tail,heady,taily);</span><br><span class="line">		<span class="keyword">if</span> (tail&gt;mid)  tmp2=<span class="built_in">Query</span>(mid+<span class="number">1</span>,r,rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,head,tail,heady,taily);</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">max</span>(tmp1,<span class="built_in">max</span>(tmp2,tmp3));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;t;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> a,b,c,d,e,i,tmp;</span><br><span class="line">	<span class="built_in">read</span>(n);<span class="built_in">read</span>(m);<span class="built_in">read</span>(k);n++;m++;</span><br><span class="line">	<span class="keyword">while</span> (k--) &#123;</span><br><span class="line">		<span class="built_in">read</span>(a);<span class="built_in">read</span>(b);<span class="built_in">read</span>(c);<span class="built_in">read</span>(d);<span class="built_in">read</span>(e);++d;++e;</span><br><span class="line">		tmp=t.<span class="built_in">Query</span>(<span class="number">1</span>,n,<span class="number">1</span>,d,a+d<span class="number">-1</span>,e,b+e<span class="number">-1</span>)+c;</span><br><span class="line">		t.<span class="built_in">Update</span>(<span class="number">1</span>,n,<span class="number">1</span>,d,a+d<span class="number">-1</span>,e,b+e<span class="number">-1</span>,tmp);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,t.<span class="built_in">Query</span>(<span class="number">1</span>,n,<span class="number">1</span>,<span class="number">1</span>,n,<span class="number">1</span>,m));</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title>Bzoj1562</title>
    <url>/2022/06/29/bzoj1562/</url>
    <content><![CDATA[<h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><p>先建出二分图。</p>
<p>考虑字典序最小。从后向前跑匈牙利即可。因为 $i$ 小的会覆盖到 $i$ 大的。</p>
<p>然后就好了。</p>
<h3 id="code"><a href="#code" class="headerlink" title="code"></a>code</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned long long </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 20005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> put() putchar(<span class="string">&#x27;\n&#x27;</span>)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(<span class="type">int</span> &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> f=<span class="number">1</span>;x=<span class="number">0</span>;<span class="type">char</span> c=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (c&lt;<span class="string">&#x27;0&#x27;</span>||c&gt;<span class="string">&#x27;9&#x27;</span>) &#123;<span class="keyword">if</span> (c==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">-1</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span> (c&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;c&lt;=<span class="string">&#x27;9&#x27;</span>) &#123;x=x*<span class="number">10</span>+c-<span class="string">&#x27;0&#x27;</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,cnt,ans,vis[maxn],match[maxn];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;to[maxn];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> y:to[x])</span><br><span class="line">	    <span class="keyword">if</span> (vis[y]!=cnt) &#123;</span><br><span class="line">	    	vis[y]=cnt;</span><br><span class="line">	    	<span class="keyword">if</span> (!match[y]||<span class="built_in">dfs</span>(match[y])) &#123;</span><br><span class="line">	    		<span class="keyword">return</span> match[y]=x,match[x]=y,<span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">id</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (x&lt;<span class="number">0</span>) <span class="keyword">return</span> x+n;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (x&gt;=n) <span class="keyword">return</span> x-n;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">ins</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> z)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (y&gt;z) <span class="built_in">swap</span>(y,z);</span><br><span class="line">	to[x].<span class="built_in">push_back</span>(y);</span><br><span class="line">	to[x].<span class="built_in">push_back</span>(z);</span><br><span class="line"><span class="comment">//	printf(&quot;%d %d %d\n&quot;,x,y-n,z-n);</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> i,x,j;</span><br><span class="line">    <span class="built_in">read</span>(n);</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;n;i++) <span class="built_in">read</span>(x),<span class="built_in">ins</span>(i,<span class="built_in">id</span>(i-x)+n,<span class="built_in">id</span>(i+x)+n);</span><br><span class="line">    <span class="keyword">for</span> (i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--) &#123;</span><br><span class="line">    	++cnt;ans+=<span class="built_in">dfs</span>(i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (ans&lt;n) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;No Answer&quot;</span>),<span class="number">0</span>; </span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;n;i++) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,match[i]-n);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>二分图</tag>
        <tag>bzoj</tag>
      </tags>
  </entry>
  <entry>
    <title>Bzoj1566 [NOI2009] 管道取珠</title>
    <url>/2023/09/24/bzoj1566-NOI2009-%E7%AE%A1%E9%81%93%E5%8F%96%E7%8F%A0/</url>
    <content><![CDATA[<h1 id="NOI2009-管道取珠"><a href="#NOI2009-管道取珠" class="headerlink" title="[NOI2009] 管道取珠"></a>[NOI2009] 管道取珠</h1><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>开题时什么都不知道，难以下手。</p>
<p>fls 说 $\sum a^2$ 其实也有组合意义。</p>
<p>其实就是每种序列与他情况相同的数的和。</p>
<p>这样就可以 dp 了。记 $f_{i,j,k}$ 表示第一个序列的上管道到 $i$，第一个序列的下管道到 $j$，第二个序列的上下管道到 $k,i+j-k$，相同的方案数。直接转移就好了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 505</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> put() putchar(<span class="string">&#x27;\n&#x27;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Tp template<span class="string">&lt;typename Ty&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Ts template<span class="string">&lt;typename Ty,typename... Ar&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(<span class="type">int</span> &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> f=<span class="number">1</span>;x=<span class="number">0</span>;<span class="type">char</span> c=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (c&lt;<span class="string">&#x27;0&#x27;</span>||c&gt;<span class="string">&#x27;9&#x27;</span>) &#123;<span class="keyword">if</span> (c==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">-1</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span> (c&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;c&lt;=<span class="string">&#x27;9&#x27;</span>) &#123;x=x*<span class="number">10</span>+c-<span class="string">&#x27;0&#x27;</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> Debug&#123;</span><br><span class="line">	Tp <span class="type">void</span> _debug(<span class="type">char</span>* f,Ty t)&#123;cerr&lt;&lt;f&lt;&lt;<span class="string">&#x27;=&#x27;</span>&lt;&lt;t&lt;&lt;endl;&#125;</span><br><span class="line">	Ts <span class="type">void</span> _debug(<span class="type">char</span>* f,Ty x,Ar... y)&#123;<span class="keyword">while</span>(*f!=<span class="string">&#x27;,&#x27;</span>) cerr&lt;&lt;*f++;cerr&lt;&lt;<span class="string">&#x27;=&#x27;</span>&lt;&lt;x&lt;&lt;<span class="string">&quot;,&quot;</span>;_debug(f+<span class="number">1</span>,y...);&#125;</span><br><span class="line">	Tp ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; os,vector&lt;Ty&gt;&amp; V)&#123;os&lt;&lt;<span class="string">&quot;[&quot;</span>;<span class="keyword">for</span>(<span class="keyword">auto</span>&amp; vv:V) os&lt;&lt;vv&lt;&lt;<span class="string">&quot;,&quot;</span>;os&lt;&lt;<span class="string">&quot;]&quot;</span>;<span class="keyword">return</span> os;&#125;</span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> gdb(...) _debug((char*)#__VA_ARGS__,__VA_ARGS__)</span></span><br><span class="line">&#125;<span class="keyword">using</span> <span class="keyword">namespace</span> Debug;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">1024523</span>;</span><br><span class="line"><span class="type">int</span> a[maxn],b[maxn];</span><br><span class="line"><span class="type">int</span> f[<span class="number">2</span>][maxn][maxn],n,m;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> &amp;x,<span class="type">int</span> y)</span> </span>&#123;x=(x+y)%mod;&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> i,j,k,l,now,pre;<span class="type">char</span> ch;</span><br><span class="line">	<span class="built_in">read</span>(n);<span class="built_in">read</span>(m);</span><br><span class="line">	<span class="keyword">for</span> (cin&gt;&gt;ch,i=<span class="number">1</span>;i&lt;=n;i++) a[i]=(ch==<span class="string">&#x27;A&#x27;</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">for</span> (cin&gt;&gt;ch,i=<span class="number">1</span>;i&lt;=m;i++) b[i]=(ch==<span class="string">&#x27;A&#x27;</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">	f[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="type">int</span> now=i&amp;<span class="number">1</span>,pre=now^<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span> (i) &#123;</span><br><span class="line">			<span class="built_in">memset</span>(f[now],<span class="number">0</span>,<span class="built_in">sizeof</span>(f[now]));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (j=<span class="number">0</span>;j&lt;=m;j++) &#123;</span><br><span class="line">			<span class="keyword">for</span> (k=<span class="number">0</span>;k&lt;=<span class="built_in">min</span>(n,i+j);k++) &#123;</span><br><span class="line">				l=i+j-k;</span><br><span class="line">				<span class="keyword">if</span> (l&gt;m) <span class="keyword">continue</span>;</span><br><span class="line">				<span class="keyword">if</span> (i&amp;&amp;k&amp;&amp;a[i]==a[k]) <span class="built_in">add</span>(f[now][j][k],f[pre][j][k<span class="number">-1</span>]); </span><br><span class="line">				<span class="keyword">if</span> (i&amp;&amp;l&amp;&amp;a[i]==b[l]) <span class="built_in">add</span>(f[now][j][k],f[pre][j][k]);</span><br><span class="line">				<span class="keyword">if</span> (j&amp;&amp;k&amp;&amp;b[j]==a[k]) <span class="built_in">add</span>(f[now][j][k],f[now][j<span class="number">-1</span>][k<span class="number">-1</span>]);</span><br><span class="line">				<span class="keyword">if</span> (j&amp;&amp;l&amp;&amp;b[j]==b[l]) <span class="built_in">add</span>(f[now][j][k],f[now][j<span class="number">-1</span>][k]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,f[n&amp;<span class="number">1</span>][m][n]);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>dp</tag>
        <tag>组合</tag>
        <tag>bzoj</tag>
      </tags>
  </entry>
  <entry>
    <title>Bzoj1797</title>
    <url>/2022/11/17/bzoj1797/</url>
    <content><![CDATA[<h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><p>先跑一边 Dinic，搞出残余网络。</p>
<h4 id="可行边"><a href="#可行边" class="headerlink" title="可行边"></a>可行边</h4><p>一条边 $(x,y)$ 是可行边的充要条件为：</p>
<ul>
<li>满流</li>
<li>在残余网络中找不到 $x-&gt;y$ 的路径</li>
</ul>
<p>在代码中表现为 $x$ 和 $y$ 不在同一个强连通分量中。</p>
<h4 id="必经边"><a href="#必经边" class="headerlink" title="必经边"></a>必经边</h4><p>在可行边的基础上，其多加的充要条件为</p>
<ul>
<li>$x$ 和原点在一个强连通分量中，$y$ 和汇点在一个强连通分量中。</li>
</ul>
<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 100005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> put() putchar(<span class="string">&#x27;\n&#x27;</span>)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(<span class="type">int</span> &amp;x)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> f=<span class="number">1</span>;x=<span class="number">0</span>;<span class="type">char</span> c=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span> (c&lt;<span class="string">&#x27;0&#x27;</span>||c&gt;<span class="string">&#x27;9&#x27;</span>) &#123;<span class="keyword">if</span> (c==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">-1</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">while</span> (c&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;c&lt;=<span class="string">&#x27;9&#x27;</span>) &#123;x=x*<span class="number">10</span>+c-<span class="string">&#x27;0&#x27;</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf=<span class="number">1e18</span>;</span><br><span class="line"><span class="type">int</span> n,m,s,t;</span><br><span class="line"><span class="type">int</span> head=<span class="number">1</span>,h[maxn];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">yyy</span>&#123;</span><br><span class="line">	<span class="type">int</span> to,z,w,u;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> val)</span></span>&#123;</span><br><span class="line">	    to=y;z=h[x];w=val;h[x]=head;u=x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;a[maxn*<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">ins</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> z)</span></span>&#123;</span><br><span class="line">	a[++head].<span class="built_in">add</span>(x,y,z);</span><br><span class="line">	a[++head].<span class="built_in">add</span>(y,x,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> Dinic&#123;</span><br><span class="line">	queue&lt;<span class="type">int</span>&gt;q;</span><br><span class="line">	<span class="type">int</span> deep[<span class="number">10005</span>],now[maxn];</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">bfs</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">		<span class="type">int</span> i,x;</span><br><span class="line">		<span class="built_in">memset</span>(deep,<span class="number">-1</span>,<span class="built_in">sizeof</span>(deep));</span><br><span class="line">		<span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) q.<span class="built_in">pop</span>();</span><br><span class="line">		q.<span class="built_in">push</span>(s);deep[s]=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">			x=q.<span class="built_in">front</span>();q.<span class="built_in">pop</span>();now[x]=h[x];</span><br><span class="line">			<span class="keyword">for</span> (i=h[x];i;i=a[i].z)</span><br><span class="line">			    <span class="keyword">if</span> (deep[a[i].to]==<span class="number">-1</span>&amp;&amp;a[i].w) &#123;</span><br><span class="line">			    	deep[a[i].to]=deep[x]+<span class="number">1</span>;</span><br><span class="line">			    	q.<span class="built_in">push</span>(a[i].to);</span><br><span class="line">				&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> deep[t]!=<span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> in)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (x==t||!in) <span class="keyword">return</span> in;</span><br><span class="line">		<span class="type">int</span> i,rest=in,sum;</span><br><span class="line">		<span class="keyword">for</span> (i=now[x];i&amp;&amp;rest;i=a[i].z)&#123;</span><br><span class="line">			now[x]=i;</span><br><span class="line">			<span class="keyword">if</span> (deep[a[i].to]==deep[x]+<span class="number">1</span>&amp;&amp;a[i].w) &#123;</span><br><span class="line">				sum=<span class="built_in">dfs</span>(a[i].to,<span class="built_in">min</span>(rest,a[i].w));</span><br><span class="line">				rest-=sum;a[i].w-=sum;a[i^<span class="number">1</span>].w+=sum;</span><br><span class="line">				<span class="keyword">if</span> (!sum) deep[a[i].to]=<span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> in-rest;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">Dinic</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">		<span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span> (<span class="built_in">bfs</span>()) ans+=<span class="built_in">dfs</span>(s,inf);</span><br><span class="line">		<span class="keyword">return</span> ans;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> dfn[maxn],low[maxn],stac[maxn],tot,vis[maxn],scc[maxn],sccnum,times;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">tarjan</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	dfn[x]=low[x]=++times;vis[x]=<span class="number">1</span>;stac[++tot]=x;</span><br><span class="line">	<span class="keyword">for</span> (i=h[x];i;i=a[i].z) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!a[i].w) <span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">if</span> (!dfn[a[i].to]) <span class="built_in">tarjan</span>(a[i].to),low[x]=<span class="built_in">min</span>(low[x],low[a[i].to]);</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (vis[a[i].to]) low[x]=<span class="built_in">min</span>(low[x],dfn[a[i].to]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (dfn[x]==low[x]) &#123;</span><br><span class="line">		++sccnum;</span><br><span class="line">		<span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">			vis[stac[tot]]=<span class="number">0</span>;</span><br><span class="line">			scc[stac[tot]]=sccnum;</span><br><span class="line">			<span class="keyword">if</span> (stac[tot--]==x) <span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> i,x,y,z,j;</span><br><span class="line">    <span class="built_in">read</span>(n);<span class="built_in">read</span>(m);<span class="built_in">read</span>(s);<span class="built_in">read</span>(t);</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=m;i++) &#123;</span><br><span class="line">    	<span class="built_in">read</span>(x);<span class="built_in">read</span>(y);<span class="built_in">read</span>(z);</span><br><span class="line">    	<span class="built_in">ins</span>(x,y,z);</span><br><span class="line">	&#125;</span><br><span class="line">	Dinic::<span class="built_in">Dinic</span>();</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) <span class="keyword">if</span> (!dfn[i]) <span class="built_in">tarjan</span>(i);</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">2</span>;i&lt;=m*<span class="number">2</span>;i+=<span class="number">2</span>) &#123;</span><br><span class="line">		x=a[i].u;y=a[i].to;</span><br><span class="line">		<span class="keyword">if</span> (a[i].w==<span class="number">0</span>&amp;&amp;scc[x]!=scc[y]) &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;1 &quot;</span>);</span><br><span class="line">			<span class="keyword">if</span> (scc[x]==scc[s]&amp;&amp;scc[y]==scc[t]) <span class="built_in">printf</span>(<span class="string">&quot;1\n&quot;</span>);</span><br><span class="line">			<span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;0\n&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;0 0\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>bzoj</tag>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title>Bzoj2079 [Poi2010] Guilds</title>
    <url>/2022/11/18/bzoj2079-Poi2010-Guilds/</url>
    <content><![CDATA[<h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><p>显然黑点或者白点的<strong>适用范围</strong>是多于灰点的，所以没有必要使用灰点。然后直接染色即可。</p>
<p>无解的充要条件应该是至少有一个孤立的点。</p>
<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 200005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> put() putchar(<span class="string">&#x27;\n&#x27;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Tp template<span class="string">&lt;typename Ty&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Ts template<span class="string">&lt;typename Ty,typename... Ar&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(<span class="type">int</span> &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> f=<span class="number">1</span>;x=<span class="number">0</span>;<span class="type">char</span> c=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (c&lt;<span class="string">&#x27;0&#x27;</span>||c&gt;<span class="string">&#x27;9&#x27;</span>) &#123;<span class="keyword">if</span> (c==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">-1</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span> (c&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;c&lt;=<span class="string">&#x27;9&#x27;</span>) &#123;x=x*<span class="number">10</span>+c-<span class="string">&#x27;0&#x27;</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> Debug&#123;</span><br><span class="line">	Tp <span class="type">void</span> _debug(<span class="type">char</span>* f,Ty t)&#123;cerr&lt;&lt;f&lt;&lt;<span class="string">&#x27;=&#x27;</span>&lt;&lt;t&lt;&lt;endl;&#125;</span><br><span class="line">	Ts <span class="type">void</span> _debug(<span class="type">char</span>* f,Ty x,Ar... y)&#123;<span class="keyword">while</span>(*f!=<span class="string">&#x27;,&#x27;</span>) cerr&lt;&lt;*f++;cerr&lt;&lt;<span class="string">&#x27;=&#x27;</span>&lt;&lt;x&lt;&lt;<span class="string">&quot;,&quot;</span>;_debug(f+<span class="number">1</span>,y...);&#125;</span><br><span class="line">	Tp ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; os,vector&lt;Ty&gt;&amp; V)&#123;os&lt;&lt;<span class="string">&quot;[&quot;</span>;<span class="keyword">for</span>(<span class="keyword">auto</span>&amp; vv:V) os&lt;&lt;vv&lt;&lt;<span class="string">&quot;,&quot;</span>;os&lt;&lt;<span class="string">&quot;]&quot;</span>;<span class="keyword">return</span> os;&#125;</span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> gdb(...) _debug((char*)#__VA_ARGS__,__VA_ARGS__)</span></span><br><span class="line">&#125;<span class="keyword">using</span> <span class="keyword">namespace</span> Debug;</span><br><span class="line"><span class="type">int</span> n,tot;</span><br><span class="line"><span class="type">int</span> Ans[maxn];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;to[maxn];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> c)</span> </span>&#123;</span><br><span class="line">	Ans[x]=c;++tot;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> y:to[x]) <span class="keyword">if</span> (!Ans[y]) <span class="built_in">dfs</span>(y,<span class="number">3</span>-c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line"><span class="comment">//  freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);</span></span><br><span class="line">	<span class="type">int</span> i,x,y,m;</span><br><span class="line">	<span class="built_in">read</span>(n);<span class="built_in">read</span>(m);</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=m;i++) <span class="built_in">read</span>(x),<span class="built_in">read</span>(y),to[x].<span class="built_in">push_back</span>(y),to[y].<span class="built_in">push_back</span>(x);</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) <span class="keyword">if</span> (!Ans[i]) &#123;</span><br><span class="line">		<span class="type">int</span> now=tot;</span><br><span class="line">		<span class="built_in">dfs</span>(i,<span class="number">1</span>);</span><br><span class="line">		<span class="keyword">if</span> (now+<span class="number">1</span>==tot) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;NIE&quot;</span>),<span class="number">0</span>;</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;TAK&quot;</span>);</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">puts</span>(Ans[i]==<span class="number">1</span>?<span class="string">&quot;K&quot;</span>:<span class="string">&quot;S&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>构造</tag>
        <tag>贪心</tag>
        <tag>bzoj</tag>
      </tags>
  </entry>
  <entry>
    <title>Bzoj2084</title>
    <url>/2022/06/30/bzoj2084/</url>
    <content><![CDATA[<p>浅浅地改一下 manacher 就好了。</p>
<p>注意只有长度为偶数的字串才可以被统计。</p>
<p>code：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 1000005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> put() putchar(<span class="string">&#x27;\n&#x27;</span>)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(<span class="type">int</span> &amp;x)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> f=<span class="number">1</span>;x=<span class="number">0</span>;<span class="type">char</span> c=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span> (c&lt;<span class="string">&#x27;0&#x27;</span>||c&gt;<span class="string">&#x27;9&#x27;</span>) &#123;<span class="keyword">if</span> (c==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">-1</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">while</span> (c&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;c&lt;=<span class="string">&#x27;9&#x27;</span>) &#123;x=x*<span class="number">10</span>+c-<span class="string">&#x27;0&#x27;</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> a[maxn],d[maxn];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">manacher</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> i,mx,mid;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i+=<span class="number">2</span>) d[i]=<span class="number">1</span>; </span><br><span class="line">	<span class="keyword">for</span> (mx=mid=<span class="number">0</span>,i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (i&lt;=mx) d[i]=<span class="built_in">min</span>(d[mid*<span class="number">2</span>-i],mx-i+<span class="number">1</span>);</span><br><span class="line">		<span class="keyword">while</span> (a[i-d[i]]+a[i+d[i]]==<span class="number">1</span>||(a[i-d[i]]==<span class="number">2</span>&amp;&amp;a[i+d[i]]==<span class="number">2</span>)) d[i]++;</span><br><span class="line">		<span class="keyword">if</span> (mx&lt;i+d[i]) mx=i+d[i]<span class="number">-1</span>,mid=i;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;1.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">	<span class="type">int</span> i,m;ll ans=<span class="number">0</span>;<span class="type">char</span> ch;</span><br><span class="line">	<span class="built_in">read</span>(n);a[<span class="number">0</span>]=<span class="number">-1e8</span>;a[++m]=<span class="number">2</span>;cin&gt;&gt;ch;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) a[++m]=ch-<span class="string">&#x27;0&#x27;</span>,ch=<span class="built_in">getchar</span>(),a[++m]=<span class="number">2</span>;a[++m]=<span class="number">1e9</span>;</span><br><span class="line">	<span class="built_in">manacher</span>(m);</span><br><span class="line"><span class="comment">//	for (i=1;i&lt;=m;i++) printf(&quot;%d &quot;,a[i]);</span></span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=m;i++) <span class="keyword">if</span> (i%<span class="number">2</span>==<span class="number">1</span>) ans+=(d[i]<span class="number">-1</span>)/<span class="number">2</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,ans); </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>manacher</tag>
        <tag>bzoj</tag>
      </tags>
  </entry>
  <entry>
    <title>Bzoj2287</title>
    <url>/2022/07/01/bzoj2287/</url>
    <content><![CDATA[<p>如果联想到 <a href="https://www.luogu.com.cn/problem/P4095">https://www.luogu.com.cn/problem/P4095</a> ，只有 $O(n^3)$ 的复杂度，即使加了卷积也只有 $O(n^2\log n)$ 。</p>
<p>考虑 01 背包，$f[i][j]&#x3D;f[i-1][j]+f[i-1][j-v[i]]$</p>
<p>令 $g_j$ 表示除了 $i$ 以外的装满容积为 $j$ 的方案。</p>
<p>01 背包无所谓物品的顺序，所以 $g[j]&#x3D;f[n][j]-g[j-v[i]]$ </p>
<p>输出 $g[j]\bmod 10$ 即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 2005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> put() putchar(<span class="string">&#x27;\n&#x27;</span>)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(<span class="type">int</span> &amp;x)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> f=<span class="number">1</span>;x=<span class="number">0</span>;<span class="type">char</span> c=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span> (c&lt;<span class="string">&#x27;0&#x27;</span>||c&gt;<span class="string">&#x27;9&#x27;</span>) &#123;<span class="keyword">if</span> (c==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">-1</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">while</span> (c&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;c&lt;=<span class="string">&#x27;9&#x27;</span>) &#123;x=x*<span class="number">10</span>+c-<span class="string">&#x27;0&#x27;</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> f[maxn],g[maxn];</span><br><span class="line"><span class="type">int</span> v[maxn],n,m;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;1.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">	<span class="type">int</span> i,j;</span><br><span class="line">	<span class="built_in">read</span>(n);<span class="built_in">read</span>(m);</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">read</span>(v[i]);</span><br><span class="line">	f[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (j=m;j&gt;=v[i];j--) f[j]+=f[j-v[i]],f[j]%=mod;</span><br><span class="line">	<span class="comment">//	for (j=0;j&lt;=m;j++) printf(&quot;%d &quot;,f[j]);put();</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (j=<span class="number">0</span>;j&lt;=m;j++) g[j]=f[j];</span><br><span class="line">		<span class="keyword">for</span> (j=v[i];j&lt;=m;j++) g[j]=(g[j]-g[j-v[i]]+mod)%mod;</span><br><span class="line">	    <span class="keyword">for</span> (j=<span class="number">1</span>;j&lt;=m;j++) <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,g[j]);<span class="built_in">put</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>dp</tag>
        <tag>bzoj</tag>
      </tags>
  </entry>
  <entry>
    <title>Bzoj2165</title>
    <url>/2022/11/16/bzoj2165/</url>
    <content><![CDATA[<h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><p>倍增 Floyd。算是加深了理解。</p>
<p>但是一般的 Floyd 只能解决恰好走了 $k$ 步的情况，而我们需要解决 $\le k$ 步时从 $1$ 开始最远的距离。</p>
<p>其实很简单，只需要令 $w(i,i)&#x3D;\max(w((i,i,0))$，就可以求 $\le k$ 的步数了。然后倍增就很简单了。</p>
<p>也可能只是我太傻逼了&#x2F;kk</p>
<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 105</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> put() putchar(<span class="string">&#x27;\n&#x27;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Tp template<span class="string">&lt;typename Ty&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Ts template<span class="string">&lt;typename Ty,typename... Ar&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(<span class="type">int</span> &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> f=<span class="number">1</span>;x=<span class="number">0</span>;<span class="type">char</span> c=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (c&lt;<span class="string">&#x27;0&#x27;</span>||c&gt;<span class="string">&#x27;9&#x27;</span>) &#123;<span class="keyword">if</span> (c==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">-1</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span> (c&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;c&lt;=<span class="string">&#x27;9&#x27;</span>) &#123;x=x*<span class="number">10</span>+c-<span class="string">&#x27;0&#x27;</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> Debug&#123;</span><br><span class="line">	Tp <span class="type">void</span> _debug(<span class="type">char</span>* f,Ty t)&#123;cerr&lt;&lt;f&lt;&lt;<span class="string">&#x27;=&#x27;</span>&lt;&lt;t&lt;&lt;endl;&#125;</span><br><span class="line">	Ts <span class="type">void</span> _debug(<span class="type">char</span>* f,Ty x,Ar... y)&#123;<span class="keyword">while</span>(*f!=<span class="string">&#x27;,&#x27;</span>) cerr&lt;&lt;*f++;cerr&lt;&lt;<span class="string">&#x27;=&#x27;</span>&lt;&lt;x&lt;&lt;<span class="string">&quot;,&quot;</span>;_debug(f+<span class="number">1</span>,y...);&#125;</span><br><span class="line">	Tp ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; os,vector&lt;Ty&gt;&amp; V)&#123;os&lt;&lt;<span class="string">&quot;[&quot;</span>;<span class="keyword">for</span>(<span class="keyword">auto</span>&amp; vv:V) os&lt;&lt;vv&lt;&lt;<span class="string">&quot;,&quot;</span>;os&lt;&lt;<span class="string">&quot;]&quot;</span>;<span class="keyword">return</span> os;&#125;</span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> gdb(...) _debug((char*)#__VA_ARGS__,__VA_ARGS__)</span></span><br><span class="line">&#125;<span class="keyword">using</span> <span class="keyword">namespace</span> Debug;</span><br><span class="line"><span class="type">int</span> w[maxn][maxn],n,m,f[<span class="number">65</span>][maxn][maxn],t[maxn][maxn],s[maxn][maxn];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">solve</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> i,j,k,l,Ans=<span class="number">0</span>,p=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">read</span>(n);<span class="built_in">read</span>(m);</span><br><span class="line">	<span class="built_in">memset</span>(f,<span class="number">-1</span>,<span class="built_in">sizeof</span>(f));</span><br><span class="line">	<span class="built_in">memset</span>(t,<span class="number">-1</span>,<span class="built_in">sizeof</span>(t));</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) <span class="keyword">for</span> (j=<span class="number">1</span>;j&lt;=n;j++) <span class="built_in">read</span>(w[i][j]),w[i][j]=(w[i][j]==<span class="number">0</span>?<span class="number">-1</span>:w[i][j]),f[<span class="number">0</span>][i][j]=w[i][j];</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) t[i][i]=<span class="number">0</span>,f[<span class="number">0</span>][i][i]=<span class="built_in">max</span>(w[i][i],<span class="number">0ll</span>);</span><br><span class="line">	<span class="keyword">for</span> (l=<span class="number">1</span>;l&lt;=<span class="number">61</span>;l++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) f[l][i][i]=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (k=<span class="number">1</span>;k&lt;=n;k++) </span><br><span class="line">			<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">				<span class="keyword">for</span> (j=<span class="number">1</span>;j&lt;=n;j++) </span><br><span class="line">					<span class="keyword">if</span> (f[l<span class="number">-1</span>][k][j]!=<span class="number">-1</span>&amp;&amp;f[l<span class="number">-1</span>][i][k]!=<span class="number">-1</span>&amp;&amp;f[l<span class="number">-1</span>][i][k]+f[l<span class="number">-1</span>][k][j]&gt;f[l][i][j]) &#123;</span><br><span class="line">						f[l][i][j]=f[l<span class="number">-1</span>][i][k]+f[l<span class="number">-1</span>][k][j];</span><br><span class="line">						<span class="keyword">if</span> (f[l][<span class="number">1</span>][j]&gt;=m) &#123;p=l;&#125;</span><br><span class="line">					&#125;</span><br><span class="line">		<span class="keyword">if</span> (p) <span class="keyword">break</span>;<span class="comment">//防止爆ll</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (l=p;l&gt;=<span class="number">0</span>;l--) &#123;<span class="type">int</span> flag=<span class="number">0</span>;</span><br><span class="line">		<span class="built_in">memset</span>(s,<span class="number">-1</span>,<span class="built_in">sizeof</span>(s));</span><br><span class="line">		<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) s[i][i]=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (k=<span class="number">1</span>;k&lt;=n;k++) </span><br><span class="line">			<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) </span><br><span class="line">				<span class="keyword">for</span> (j=<span class="number">1</span>;j&lt;=n;j++) </span><br><span class="line">					<span class="keyword">if</span> (t[i][k]!=<span class="number">-1</span>&amp;&amp;f[l][k][j]!=<span class="number">-1</span>&amp;&amp;t[i][k]+f[l][k][j]&gt;s[i][j]) s[i][j]=t[i][k]+f[l][k][j];</span><br><span class="line">		<span class="keyword">for</span> (j=<span class="number">1</span>;j&lt;=n;j++) <span class="keyword">if</span> (s[<span class="number">1</span>][j]&gt;=m) &#123;flag=<span class="number">1</span>;<span class="keyword">break</span>;&#125;</span><br><span class="line">		<span class="keyword">if</span> (flag) <span class="keyword">continue</span>;</span><br><span class="line">		<span class="built_in">memcpy</span>(t,s,<span class="built_in">sizeof</span>(t)); </span><br><span class="line">		Ans+=(<span class="number">1ll</span>&lt;&lt;l);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,Ans+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> T;<span class="built_in">read</span>(T);</span><br><span class="line">	<span class="keyword">while</span> (T--) <span class="built_in">solve</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>   所以有几个常见的手段而且我老是想不到的：</p>
<ul>
<li>倍增</li>
<li>哈希</li>
<li>二分</li>
</ul>
]]></content>
      <tags>
        <tag>倍增</tag>
        <tag>Floyd</tag>
        <tag>bzoj</tag>
      </tags>
  </entry>
  <entry>
    <title>Bzoj2085</title>
    <url>/2022/11/18/bzoj2085/</url>
    <content><![CDATA[<h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><p>令 $f[i][j]$ 表示包含了 $i$ 个字符串且最后一个时第 $j$ 个字符串时，所需要的最少字符数。</p>
<p>容易转移 $f[i][j]&#x3D;\min f[i-1][k]+w(k,j)$</p>
<p>然后我们用矩阵乘法优化一下即可。</p>
<p>现在考虑求出 $w(k,j)$。因为 $n$ 比较小，考虑直接枚举 $i,j$。</p>
<p>然后用 $kmp$ 或者哈希直接枚举求就好了。</p>
<p>$O(\sum\sum \min(len_i,len_j)\le O(\sum\sum len_i+len_j)&#x3D;O(n\sum len_i)$</p>
<p>左边第一个是 哈希 的复杂度，第二个是 kmp 的复杂度。</p>
<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 205</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxm 100005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug() return puts(<span class="string">&quot;1&quot;</span>),0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> put() putchar(<span class="string">&#x27;\n&#x27;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Tp template<span class="string">&lt;typename Ty&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Ts template<span class="string">&lt;typename Ty,typename... Ar&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(<span class="type">int</span> &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> f=<span class="number">1</span>;x=<span class="number">0</span>;<span class="type">char</span> c=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (c&lt;<span class="string">&#x27;0&#x27;</span>||c&gt;<span class="string">&#x27;9&#x27;</span>) &#123;<span class="keyword">if</span> (c==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">-1</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span> (c&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;c&lt;=<span class="string">&#x27;9&#x27;</span>) &#123;x=x*<span class="number">10</span>+c-<span class="string">&#x27;0&#x27;</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> Debug&#123;</span><br><span class="line">	Tp <span class="type">void</span> _debug(<span class="type">char</span>* f,Ty t)&#123;cerr&lt;&lt;f&lt;&lt;<span class="string">&#x27;=&#x27;</span>&lt;&lt;t&lt;&lt;endl;&#125;</span><br><span class="line">	Ts <span class="type">void</span> _debug(<span class="type">char</span>* f,Ty x,Ar... y)&#123;<span class="keyword">while</span>(*f!=<span class="string">&#x27;,&#x27;</span>) cerr&lt;&lt;*f++;cerr&lt;&lt;<span class="string">&#x27;=&#x27;</span>&lt;&lt;x&lt;&lt;<span class="string">&quot;,&quot;</span>;_debug(f+<span class="number">1</span>,y...);&#125;</span><br><span class="line">	Tp ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; os,vector&lt;Ty&gt;&amp; V)&#123;os&lt;&lt;<span class="string">&quot;[&quot;</span>;<span class="keyword">for</span>(<span class="keyword">auto</span>&amp; vv:V) os&lt;&lt;vv&lt;&lt;<span class="string">&quot;,&quot;</span>;os&lt;&lt;<span class="string">&quot;]&quot;</span>;<span class="keyword">return</span> os;&#125;</span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> gdb(...) _debug((char*)#__VA_ARGS__,__VA_ARGS__)</span></span><br><span class="line">&#125;<span class="keyword">using</span> <span class="keyword">namespace</span> Debug;</span><br><span class="line"><span class="type">int</span> pw[maxm],ipw[maxm];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;suf[maxn],pre[maxn];</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> base=<span class="number">131</span>,mod=<span class="number">1e9</span>+<span class="number">7</span>,MAXLEN=<span class="number">1e5</span>,inf=<span class="number">1e18</span>;</span><br><span class="line"><span class="type">int</span> n,m,len[maxn],Ans=inf;</span><br><span class="line">string s[maxn];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Mat</span> &#123;</span><br><span class="line">	<span class="type">int</span> a[maxn][maxn];</span><br><span class="line">	<span class="built_in">Mat</span> (<span class="type">void</span>) &#123;<span class="built_in">memset</span>(a,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(a));&#125;	</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">clear</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) a[i][i]=<span class="number">0</span>;&#125;</span><br><span class="line">	Mat <span class="keyword">operator</span> *(<span class="type">const</span> Mat &amp;x) <span class="type">const</span> &#123;</span><br><span class="line">		<span class="type">int</span> i,j,k;Mat ans;</span><br><span class="line">		<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">			<span class="keyword">for</span> (j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">			 	<span class="keyword">for</span> (k=<span class="number">1</span>;k&lt;=n;k++)</span><br><span class="line">			 	 	ans.a[i][j]=<span class="built_in">min</span>(ans.a[i][j],a[i][k]+x.a[k][j]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> ans;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;tmp;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">power</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> ans=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (y) &#123;</span><br><span class="line">		<span class="keyword">if</span> (y&amp;<span class="number">1</span>) ans=ans*x%mod;</span><br><span class="line">		y&gt;&gt;=<span class="number">1</span>;x=x*x%mod;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">W</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> l,<span class="type">int</span> r)</span> </span>&#123;<span class="keyword">return</span> (suf[i][r]-suf[i][l<span class="number">-1</span>]+mod)*ipw[l]%mod;&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line"><span class="comment">//  freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);</span></span><br><span class="line">	<span class="type">int</span> i,j,k;</span><br><span class="line">	<span class="built_in">read</span>(n);<span class="built_in">read</span>(m);</span><br><span class="line">	<span class="keyword">for</span> (pw[<span class="number">0</span>]=<span class="number">1</span>,i=<span class="number">1</span>;i&lt;=MAXLEN;i++) pw[i]=pw[i<span class="number">-1</span>]*base%mod;</span><br><span class="line">	<span class="keyword">for</span> (ipw[MAXLEN]=<span class="built_in">power</span>(pw[MAXLEN],mod<span class="number">-2</span>),i=MAXLEN;i&gt;=<span class="number">1</span>;i--) ipw[i<span class="number">-1</span>]=ipw[i]*base%mod;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		cin&gt;&gt;s[i];len[i]=s[i].<span class="built_in">size</span>();s[i]=<span class="string">&#x27;_&#x27;</span>+s[i];</span><br><span class="line">		suf[i].<span class="built_in">resize</span>(len[i]+<span class="number">5</span>);pre[i].<span class="built_in">resize</span>(len[i]+<span class="number">5</span>);</span><br><span class="line">		<span class="keyword">for</span> (j=<span class="number">1</span>;j&lt;=len[i];j++) suf[i][j]=(suf[i][j<span class="number">-1</span>]+pw[j]*(s[i][j]-<span class="string">&#x27;a&#x27;</span>+<span class="number">1</span>))%mod;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) </span><br><span class="line">		<span class="keyword">for</span> (j=<span class="number">1</span>;j&lt;=n;j++) &#123;</span><br><span class="line">			tmp.a[i][j]=len[j];</span><br><span class="line">			<span class="keyword">for</span> (k=<span class="built_in">min</span>(len[j],len[i])<span class="number">-1</span>;k&gt;=<span class="number">1</span>;k--) </span><br><span class="line">				<span class="keyword">if</span> (<span class="built_in">W</span>(i,len[i]-k+<span class="number">1</span>,len[i])==<span class="built_in">W</span>(j,<span class="number">1</span>,k)) &#123;tmp.a[i][j]-=k;<span class="keyword">break</span>;&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	m--;Mat ans;ans.<span class="built_in">clear</span>();</span><br><span class="line">	<span class="keyword">while</span> (m) &#123;</span><br><span class="line">		<span class="keyword">if</span> (m&amp;<span class="number">1</span>) ans=ans*tmp;</span><br><span class="line">		tmp=tmp*tmp;m&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">		 	Ans=<span class="built_in">min</span>(Ans,ans.a[i][j]+len[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,Ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>dp</tag>
        <tag>bzoj</tag>
        <tag>哈希</tag>
      </tags>
  </entry>
  <entry>
    <title>Bzoj2863</title>
    <url>/2022/11/13/bzoj2863/</url>
    <content><![CDATA[<h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><p>令有 $i$ 个点的满足要求的图（不连通DAG）的个数为 $F_i$。</p>
<p>考虑容斥，至少有 $i$ 个入度为 $0$ 的点的图的个数为<br>$$<br>F_{n-i}\times C_n^i\times 2^{i(n-i)}<br>$$<br>则入度为 $0$ 的点有 $0$ 个的图的个数为<br>$$<br>\sum\limits_{i&#x3D;0}^n(-1)^iF_{n-i}\times C_n^i\times 2^{i(n-i)}<br>$$<br>又知道，这个数$&#x3D;0$</p>
<p>于是把 $F_n$ 单独提出来，就有<br>$$<br>\sum\limits_{i&#x3D;1}^n(-1)^{i+1}F_{n-i}\times C_n^i\times 2^{i(n-i)}&#x3D;F_n<br>$$</p>
<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 3005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> put() putchar(<span class="string">&#x27;\n&#x27;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Tp template<span class="string">&lt;typename Ty&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Ts template<span class="string">&lt;typename Ty,typename... Ar&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(<span class="type">int</span> &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> f=<span class="number">1</span>;x=<span class="number">0</span>;<span class="type">char</span> c=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (c&lt;<span class="string">&#x27;0&#x27;</span>||c&gt;<span class="string">&#x27;9&#x27;</span>) &#123;<span class="keyword">if</span> (c==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">-1</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span> (c&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;c&lt;=<span class="string">&#x27;9&#x27;</span>) &#123;x=x*<span class="number">10</span>+c-<span class="string">&#x27;0&#x27;</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> Debug&#123;</span><br><span class="line">	Tp <span class="type">void</span> _debug(<span class="type">char</span>* f,Ty t)&#123;cerr&lt;&lt;f&lt;&lt;<span class="string">&#x27;=&#x27;</span>&lt;&lt;t&lt;&lt;endl;&#125;</span><br><span class="line">	Ts <span class="type">void</span> _debug(<span class="type">char</span>* f,Ty x,Ar... y)&#123;<span class="keyword">while</span>(*f!=<span class="string">&#x27;,&#x27;</span>) cerr&lt;&lt;*f++;cerr&lt;&lt;<span class="string">&#x27;=&#x27;</span>&lt;&lt;x&lt;&lt;<span class="string">&quot;,&quot;</span>;_debug(f+<span class="number">1</span>,y...);&#125;</span><br><span class="line">	Tp ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; os,vector&lt;Ty&gt;&amp; V)&#123;os&lt;&lt;<span class="string">&quot;[&quot;</span>;<span class="keyword">for</span>(<span class="keyword">auto</span>&amp; vv:V) os&lt;&lt;vv&lt;&lt;<span class="string">&quot;,&quot;</span>;os&lt;&lt;<span class="string">&quot;]&quot;</span>;<span class="keyword">return</span> os;&#125;</span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> gdb(...) _debug((char*)#__VA_ARGS__,__VA_ARGS__)</span></span><br><span class="line">&#125;<span class="keyword">using</span> <span class="keyword">namespace</span> Debug;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">int</span> f[maxn],suf[maxn],isuf[maxn],pw[maxn*maxn];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">power</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> sum=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (y) &#123;</span><br><span class="line">		<span class="keyword">if</span> (y&amp;<span class="number">1</span>) sum=sum*x%mod;</span><br><span class="line">		x=x*x%mod;y&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">C</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> m)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> suf[n]*isuf[m]%mod*isuf[n-m]%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line"><span class="comment">//  freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);</span></span><br><span class="line">	<span class="type">int</span> n,i,j;</span><br><span class="line">	<span class="built_in">read</span>(n);</span><br><span class="line">	f[<span class="number">0</span>]=<span class="number">1</span>;f[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (suf[<span class="number">0</span>]=<span class="number">1</span>,i=<span class="number">1</span>;i&lt;=n;i++) suf[i]=suf[i<span class="number">-1</span>]*i%mod;</span><br><span class="line">	<span class="keyword">for</span> (isuf[n]=<span class="built_in">power</span>(suf[n],mod<span class="number">-2</span>),i=n;i&gt;=<span class="number">1</span>;i--) isuf[i<span class="number">-1</span>]=isuf[i]*i%mod;</span><br><span class="line">	<span class="keyword">for</span> (pw[<span class="number">0</span>]=<span class="number">1</span>,i=<span class="number">1</span>;i&lt;=n*n;i++) pw[i]=pw[i<span class="number">-1</span>]*<span class="number">2</span>%mod;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">2</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (j=<span class="number">1</span>;j&lt;=i;j++)</span><br><span class="line">			<span class="keyword">if</span> (j&amp;<span class="number">1</span>) f[i]=(f[i]+f[i-j]*<span class="built_in">C</span>(i,j)%mod*pw[j*(i-j)]%mod+mod)%mod;</span><br><span class="line">			<span class="keyword">else</span> f[i]=(f[i]-f[i-j]*<span class="built_in">C</span>(i,j)%mod*pw[j*(i-j)]%mod+mod)%mod;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,f[n]);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>dp</tag>
        <tag>容斥</tag>
        <tag>bzoj</tag>
      </tags>
  </entry>
  <entry>
    <title>Bzoj2628 JZPSTR</title>
    <url>/2022/11/19/bzoj2628-JZPSTR/</url>
    <content><![CDATA[<h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><p><strong><a href="http://wgyhm.cf/2022/11/18/Shift-And-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D/#%E6%A8%A1%E5%BC%8F%E4%B8%B2%E5%8C%B9%E9%85%8D%E6%96%87%E6%9C%AC%E4%B8%B2">Shift-And算法学习笔记</a></strong></p>
<p>查询复杂度只与<strong>模式串</strong>相关的字符串匹配算法，考虑 Shift-And 算法。</p>
<p>然后维护每个字符在文本串的出现情况。</p>
<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> put() putchar(<span class="string">&#x27;\n&#x27;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Tp template<span class="string">&lt;typename Ty&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Ts template<span class="string">&lt;typename Ty,typename... Ar&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(<span class="type">int</span> &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> f=<span class="number">1</span>;x=<span class="number">0</span>;<span class="type">char</span> c=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (c&lt;<span class="string">&#x27;0&#x27;</span>||c&gt;<span class="string">&#x27;9&#x27;</span>) &#123;<span class="keyword">if</span> (c==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">-1</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span> (c&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;c&lt;=<span class="string">&#x27;9&#x27;</span>) &#123;x=x*<span class="number">10</span>+c-<span class="string">&#x27;0&#x27;</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> Debug&#123;</span><br><span class="line">	Tp <span class="type">void</span> _debug(<span class="type">char</span>* f,Ty t)&#123;cerr&lt;&lt;f&lt;&lt;<span class="string">&#x27;=&#x27;</span>&lt;&lt;t&lt;&lt;endl;&#125;</span><br><span class="line">	Ts <span class="type">void</span> _debug(<span class="type">char</span>* f,Ty x,Ar... y)&#123;<span class="keyword">while</span>(*f!=<span class="string">&#x27;,&#x27;</span>) cerr&lt;&lt;*f++;cerr&lt;&lt;<span class="string">&#x27;=&#x27;</span>&lt;&lt;x&lt;&lt;<span class="string">&quot;,&quot;</span>;_debug(f+<span class="number">1</span>,y...);&#125;</span><br><span class="line">	Tp ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; os,vector&lt;Ty&gt;&amp; V)&#123;os&lt;&lt;<span class="string">&quot;[&quot;</span>;<span class="keyword">for</span>(<span class="keyword">auto</span>&amp; vv:V) os&lt;&lt;vv&lt;&lt;<span class="string">&quot;,&quot;</span>;os&lt;&lt;<span class="string">&quot;]&quot;</span>;<span class="keyword">return</span> os;&#125;</span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> gdb(...) _debug((char*)#__VA_ARGS__,__VA_ARGS__)</span></span><br><span class="line">&#125;<span class="keyword">using</span> <span class="keyword">namespace</span> Debug;</span><br><span class="line">bitset&lt;1000005&gt;B[<span class="number">10</span>],tmp,cl;</span><br><span class="line"><span class="type">char</span> s[<span class="number">1000005</span>];</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> T,op,l,r,i,len;</span><br><span class="line">	<span class="built_in">read</span>(T);</span><br><span class="line">	<span class="keyword">while</span> (T--) &#123;</span><br><span class="line">		<span class="built_in">read</span>(op);<span class="built_in">read</span>(l);</span><br><span class="line">		<span class="keyword">if</span> (op==<span class="number">0</span>) &#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s);<span class="keyword">for</span> (len=<span class="number">0</span>;s[len];len++) ;</span><br><span class="line">			<span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++) &#123;</span><br><span class="line">				tmp=((B[i]&gt;&gt;l)&lt;&lt;l),B[i]=(tmp&lt;&lt;len)^(tmp^B[i]);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;len;i++) B[s[i]-<span class="string">&#x27;0&#x27;</span>][i+l]=<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (op==<span class="number">1</span>)&#123;</span><br><span class="line">			<span class="built_in">read</span>(r);</span><br><span class="line">			<span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++) &#123;</span><br><span class="line">				tmp=(B[i]&gt;&gt;r)&lt;&lt;r;</span><br><span class="line">				B[i]=(B[i]^((B[i]&gt;&gt;l)&lt;&lt;l))^(tmp&gt;&gt;(r-l));</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (op==<span class="number">2</span>) &#123;</span><br><span class="line">			<span class="built_in">read</span>(r);<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s);<span class="keyword">for</span> (len=<span class="number">0</span>;s[len];len++) ;</span><br><span class="line">			<span class="keyword">if</span> (r-l&lt;len) &#123;<span class="built_in">puts</span>(<span class="string">&quot;0&quot;</span>);<span class="keyword">continue</span>;&#125;</span><br><span class="line">			tmp=(((~cl)&gt;&gt;l)&lt;&lt;l)^(((~cl)&gt;&gt;(r-len+<span class="number">1</span>))&lt;&lt;(r-len+<span class="number">1</span>));</span><br><span class="line">			<span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;len;i++) &#123;</span><br><span class="line">				tmp=tmp&amp;B[s[i]-<span class="string">&#x27;0&#x27;</span>];</span><br><span class="line">				tmp&lt;&lt;=<span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,(<span class="type">int</span>)tmp.<span class="built_in">count</span>());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>bzoj</tag>
        <tag>字符串</tag>
        <tag>Shift-And算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Bzoj3163</title>
    <url>/2022/07/01/bzoj3163/</url>
    <content><![CDATA[<p>多重背包单调队列优化正反跑一遍 $O(nm)$</p>
<p>查询时，合并 $f_{d-1,e}+g_{d+1,e}$。</p>
<p>不一定要全取完，所以做一个前缀最大。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 1005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> put() putchar(<span class="string">&#x27;\n&#x27;</span>)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(<span class="type">int</span> &amp;x)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> f=<span class="number">1</span>;x=<span class="number">0</span>;<span class="type">char</span> c=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span> (c&lt;<span class="string">&#x27;0&#x27;</span>||c&gt;<span class="string">&#x27;9&#x27;</span>) &#123;<span class="keyword">if</span> (c==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">-1</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">while</span> (c&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;c&lt;=<span class="string">&#x27;9&#x27;</span>) &#123;x=x*<span class="number">10</span>+c-<span class="string">&#x27;0&#x27;</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">yyy</span>&#123;</span><br><span class="line">	<span class="type">int</span> v,w,k;</span><br><span class="line">&#125;a[<span class="number">1005</span>];</span><br><span class="line"><span class="type">int</span> f[<span class="number">1005</span>][<span class="number">1005</span>],g[<span class="number">1005</span>][<span class="number">1005</span>];</span><br><span class="line"><span class="type">int</span> head,tail,q[<span class="number">1005</span>],m=<span class="number">1000</span>;</span><br><span class="line"><span class="type">int</span> suf[maxn],suff[maxn];</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;1.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">	<span class="type">int</span> i,j,k,T,x,y;</span><br><span class="line">	<span class="built_in">read</span>(n);</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">read</span>(a[i].v),<span class="built_in">read</span>(a[i].w),<span class="built_in">read</span>(a[i].k);</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (j=<span class="number">0</span>;j&lt;a[i].v;j++) &#123;</span><br><span class="line">			q[head=tail=<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">			f[i][j]=f[i<span class="number">-1</span>][j];</span><br><span class="line">			<span class="keyword">for</span> (k=<span class="number">1</span>;k*a[i].v+j&lt;=m;k++) &#123;</span><br><span class="line">				<span class="keyword">while</span> (head&lt;=tail&amp;&amp;q[head]+a[i].k&lt;k) head++;</span><br><span class="line">				<span class="keyword">while</span> (head&lt;=tail&amp;&amp;f[i<span class="number">-1</span>][j+q[tail]*a[i].v]-q[tail]*a[i].w&lt;=f[i<span class="number">-1</span>][j+k*a[i].v]-k*a[i].w) tail--;</span><br><span class="line">				q[++tail]=k;</span><br><span class="line">				f[i][j+k*a[i].v]=f[i<span class="number">-1</span>][j+q[head]*a[i].v]+(k-q[head])*a[i].w;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; </span><br><span class="line">	<span class="comment">//	for (j=0;j&lt;=8;j++) printf(&quot;%d &quot;,f[i][j]);put();</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (i=n;i&gt;=<span class="number">1</span>;i--) &#123;</span><br><span class="line">		<span class="keyword">for</span> (j=<span class="number">0</span>;j&lt;a[i].v;j++) &#123;</span><br><span class="line">			q[head=tail=<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">			g[i][j]=g[i+<span class="number">1</span>][j];</span><br><span class="line">			<span class="keyword">for</span> (k=<span class="number">1</span>;k*a[i].v+j&lt;=m;k++) &#123;</span><br><span class="line">				<span class="keyword">while</span> (head&lt;=tail&amp;&amp;q[head]+a[i].k&lt;k) head++;</span><br><span class="line">				<span class="keyword">while</span> (head&lt;=tail&amp;&amp;g[i+<span class="number">1</span>][j+q[tail]*a[i].v]-q[tail]*a[i].w&lt;=g[i+<span class="number">1</span>][j+k*a[i].v]-k*a[i].w) tail--;</span><br><span class="line">				q[++tail]=k;</span><br><span class="line">				g[i][j+k*a[i].v]=g[i+<span class="number">1</span>][j+q[head]*a[i].v]+(k-q[head])*a[i].w;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">read</span>(T);</span><br><span class="line">	<span class="keyword">while</span> (T--)&#123;</span><br><span class="line">		<span class="built_in">read</span>(x);<span class="built_in">read</span>(y);x++;</span><br><span class="line">		<span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;=y;i++) suf[i]=<span class="built_in">max</span>(suf[i<span class="number">-1</span>],f[x<span class="number">-1</span>][i]),suff[i]=<span class="built_in">max</span>(suff[i<span class="number">-1</span>],g[x+<span class="number">1</span>][i]);</span><br><span class="line">		<span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;=y;i++) ans=<span class="built_in">max</span>(ans,suf[i]+suff[y-i]);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>dp</tag>
        <tag>bzoj</tag>
        <tag>单调队列</tag>
      </tags>
  </entry>
  <entry>
    <title>Bzoj3167  [HEOI2013] Sao</title>
    <url>/2023/05/07/bzoj3167-HEOI2013-Sao/</url>
    <content><![CDATA[<p>不考虑边的方向，图是棵树。考虑树形 dp。</p>
<p>令 $f[i][j]$ 表示<strong>在 $i$ 的子树中</strong>拓扑序为 $j$ 的方案树。</p>
<p>考虑子树按顺序向父亲合并。设父亲为 $u$，儿子为 $v$。</p>
<p>钦定 $u$ 的拓扑序要在 $v$ 之后。则 $f[u][i]&#x3D;\sum\limits _{i\ge j}g[j]\times f[v][k]\times C$。</p>
<p>考虑计算 $C$。合并的本质就相当于 $g$ 和 $f[v]$ 合并。$f[v]$ 中有 $i-j$ 个插在 $u$ 之前，有 $(siz_u-j)$ 个插在 $u$ 后面。只要保证每个子树内的相对顺序一致。所以 $C&#x3D;\dbinom{i-1}{i-j}\dbinom{siz_u+siz_v-i}{siz_u-j}$</p>
<p>$u$ 的拓扑序在 $v$ 之后同理。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 2005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> put() putchar(<span class="string">&#x27;\n&#x27;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Tp template<span class="string">&lt;typename Ty&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Ts template<span class="string">&lt;typename Ty,typename... Ar&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(<span class="type">int</span> &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> f=<span class="number">1</span>;x=<span class="number">0</span>;<span class="type">char</span> c=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (c&lt;<span class="string">&#x27;0&#x27;</span>||c&gt;<span class="string">&#x27;9&#x27;</span>) &#123;<span class="keyword">if</span> (c==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">-1</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span> (c&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;c&lt;=<span class="string">&#x27;9&#x27;</span>) &#123;x=x*<span class="number">10</span>+c-<span class="string">&#x27;0&#x27;</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> Debug&#123;</span><br><span class="line">	Tp <span class="type">void</span> _debug(<span class="type">char</span>* f,Ty t)&#123;cerr&lt;&lt;f&lt;&lt;<span class="string">&#x27;=&#x27;</span>&lt;&lt;t&lt;&lt;endl;&#125;</span><br><span class="line">	Ts <span class="type">void</span> _debug(<span class="type">char</span>* f,Ty x,Ar... y)&#123;<span class="keyword">while</span>(*f!=<span class="string">&#x27;,&#x27;</span>) cerr&lt;&lt;*f++;cerr&lt;&lt;<span class="string">&#x27;=&#x27;</span>&lt;&lt;x&lt;&lt;<span class="string">&quot;,&quot;</span>;_debug(f+<span class="number">1</span>,y...);&#125;</span><br><span class="line">	Tp ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; os,vector&lt;Ty&gt;&amp; V)&#123;os&lt;&lt;<span class="string">&quot;[&quot;</span>;<span class="keyword">for</span>(<span class="keyword">auto</span>&amp; vv:V) os&lt;&lt;vv&lt;&lt;<span class="string">&quot;,&quot;</span>;os&lt;&lt;<span class="string">&quot;]&quot;</span>;<span class="keyword">return</span> os;&#125;</span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> gdb(...) _debug((char*)#__VA_ARGS__,__VA_ARGS__)</span></span><br><span class="line">&#125;<span class="keyword">using</span> <span class="keyword">namespace</span> Debug;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">int</span> head=<span class="number">1</span>,h[maxn];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">yyy</span>&#123;</span><br><span class="line">	<span class="type">int</span> to,z,flag;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">		to=y;z=h[x];h[x]=head;flag=val;</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;a[maxn*<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> f[maxn][maxn],siz[maxn],c[maxn][maxn],g[maxn];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> &amp;x,<span class="type">int</span> y)</span> </span>&#123;x=(x+y)%mod;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> pre)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> i,j,k,l,y;</span><br><span class="line">	siz[x]=<span class="number">1</span>;f[x][<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (l=h[x];l;l=a[l].z) <span class="keyword">if</span> (a[l].to^pre) &#123;</span><br><span class="line">		<span class="built_in">dfs</span>(a[l].to,x);y=a[l].to;</span><br><span class="line">		<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=siz[x];i++) g[i]=f[x][i],f[x][i]=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=siz[x]+siz[y];i++) &#123;</span><br><span class="line">			<span class="keyword">for</span> (j=<span class="number">1</span>;j&lt;=<span class="built_in">min</span>(i,siz[x]);j++) &#123;</span><br><span class="line">				<span class="keyword">if</span> (a[l].flag==<span class="number">1</span>) <span class="built_in">add</span>(f[x][i],g[j]*c[i<span class="number">-1</span>][i-j]%mod*c[siz[x]+siz[y]-i][siz[x]-j]%mod*f[y][<span class="built_in">min</span>(siz[y],i-j)]%mod);</span><br><span class="line">				<span class="keyword">else</span> <span class="built_in">add</span>(f[x][i],g[j]*c[i<span class="number">-1</span>][i-j]%mod*c[siz[x]+siz[y]-i][siz[x]-j]%mod*(f[y][siz[y]]-f[y][<span class="built_in">min</span>(siz[y],i-j)]+mod)%mod);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		siz[x]+=siz[y];</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">//	printf(&quot;case %lld\n&quot;,x);</span></span><br><span class="line"><span class="comment">//	for (i=1;i&lt;=siz[x];i++) printf(&quot;%lld : %lld\n&quot;,i,f[x][i]);</span></span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=siz[x];i++) <span class="built_in">add</span>(f[x][i],f[x][i<span class="number">-1</span>]);</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">solve</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> i,j,x,y;<span class="type">char</span> ch;</span><br><span class="line">	<span class="built_in">read</span>(n);head=<span class="number">1</span>;</span><br><span class="line"><span class="comment">//	gdb(n);</span></span><br><span class="line">	<span class="built_in">memset</span>(h,<span class="number">0</span>,<span class="built_in">sizeof</span>(h));</span><br><span class="line">	<span class="built_in">memset</span>(f,<span class="number">0</span>,<span class="built_in">sizeof</span>(f));</span><br><span class="line">	<span class="built_in">memset</span>(siz,<span class="number">0</span>,<span class="built_in">sizeof</span>(siz)); </span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;n;i++) &#123;</span><br><span class="line">		<span class="built_in">read</span>(x);ch=<span class="built_in">getchar</span>();</span><br><span class="line">		<span class="keyword">while</span> (ch!=<span class="string">&#x27;&lt;&#x27;</span>&amp;&amp;ch!=<span class="string">&#x27;&gt;&#x27;</span>) ch=<span class="built_in">getchar</span>();</span><br><span class="line">		<span class="built_in">read</span>(y);x++,y++;</span><br><span class="line">		<span class="keyword">if</span> (ch==<span class="string">&#x27;&gt;&#x27;</span>) <span class="built_in">swap</span>(x,y);</span><br><span class="line">		a[++head].<span class="built_in">add</span>(x,y,<span class="number">-1</span>),a[++head].<span class="built_in">add</span>(y,x,<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,f[<span class="number">1</span>][n]);<span class="built_in">put</span>();</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> T,i,j;</span><br><span class="line">	<span class="built_in">read</span>(T);</span><br><span class="line">	<span class="type">int</span> n=<span class="number">1000</span>;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		c[i][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span> (j=<span class="number">1</span>;j&lt;=i;j++) c[i][j]=(c[i<span class="number">-1</span>][j<span class="number">-1</span>]+c[i<span class="number">-1</span>][j])%mod;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (T--) <span class="built_in">solve</span>(); </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>dp</tag>
        <tag>计数</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>Bzoj3574</title>
    <url>/2022/07/01/bzoj3574/</url>
    <content><![CDATA[<p>每两个点之间的比值都是定的。</p>
<p>多个数乘起来可能会爆 ll。</p>
<p>所以一般有两种解决办法：</p>
<ul>
<li>哈希</li>
<li>转 $\log$ ，加起来</li>
</ul>
<p><del>因为机房最近全在卡hash，所以我第一时间想到的也是hash</del></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 500005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> put() putchar(<span class="string">&#x27;\n&#x27;</span>)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(<span class="type">int</span> &amp;x)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> f=<span class="number">1</span>;x=<span class="number">0</span>;<span class="type">char</span> c=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span> (c&lt;<span class="string">&#x27;0&#x27;</span>||c&gt;<span class="string">&#x27;9&#x27;</span>) &#123;<span class="keyword">if</span> (c==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">-1</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">while</span> (c&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;c&lt;=<span class="string">&#x27;9&#x27;</span>) &#123;x=x*<span class="number">10</span>+c-<span class="string">&#x27;0&#x27;</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">998244353</span>,mod2=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">	<span class="type">int</span> x,y;ull z;</span><br><span class="line">	<span class="built_in">node</span>(<span class="type">int</span> a=<span class="number">0</span>,<span class="type">int</span> b=<span class="number">0</span>,ull c=<span class="number">0</span>) &#123;x=a;y=b;z=c;&#125;</span><br><span class="line">	<span class="type">bool</span> <span class="keyword">operator</span> &lt;(<span class="type">const</span> node &amp;a) <span class="type">const</span>&#123;<span class="keyword">return</span> x==a.x?(y==a.y?z&lt;a.z:y&lt;a.y):x&lt;a.x;&#125;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span> ==(<span class="type">const</span> node &amp;a) <span class="type">const</span>&#123;<span class="keyword">return</span> x==a.x&amp;&amp;y==a.y&amp;&amp;z==a.z;&#125;</span><br><span class="line">&#125;id[maxn];</span><br><span class="line">map&lt;node,<span class="type">int</span>&gt;mp;</span><br><span class="line"><span class="type">int</span> n,w[maxn],out[maxn],g[maxn][<span class="number">2</span>];</span><br><span class="line">ull f[maxn];</span><br><span class="line"><span class="type">int</span> h[maxn],head=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">yyy</span>&#123;</span><br><span class="line">	<span class="type">int</span> to,z;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">		to=y;z=h[x];h[x]=head;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;a[maxn*<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> ans,sum;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> eps=<span class="number">1e-1</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> pre)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	id[x]=<span class="built_in">node</span>(w[x]*g[x][<span class="number">0</span>]%mod,w[x]*g[x][<span class="number">1</span>]%mod2,f[x]*w[x]);</span><br><span class="line">	<span class="keyword">for</span> (i=h[x];i;i=a[i].z) </span><br><span class="line">		<span class="keyword">if</span> (a[i].to^pre) &#123;</span><br><span class="line">			g[a[i].to][<span class="number">0</span>]=g[x][<span class="number">0</span>]*out[x]%mod;</span><br><span class="line">			g[a[i].to][<span class="number">1</span>]=g[x][<span class="number">1</span>]*out[x]%mod2;</span><br><span class="line">			f[a[i].to]=f[x]*out[x];</span><br><span class="line">			<span class="built_in">dfs</span>(a[i].to,x);</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> i,x,y;</span><br><span class="line">	<span class="built_in">read</span>(n);</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">read</span>(w[i]),out[i]=<span class="number">-1</span>;out[<span class="number">1</span>]++;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;n;i++) &#123;</span><br><span class="line">		<span class="built_in">read</span>(x);<span class="built_in">read</span>(y);</span><br><span class="line">		out[x]++;a[++head].<span class="built_in">add</span>(x,y);</span><br><span class="line">		out[y]++;a[++head].<span class="built_in">add</span>(y,x);</span><br><span class="line">	&#125;</span><br><span class="line">	g[<span class="number">1</span>][<span class="number">0</span>]=g[<span class="number">1</span>][<span class="number">1</span>]=<span class="number">1</span>;f[<span class="number">1</span>]=<span class="number">1</span>;<span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">sort</span>(id+<span class="number">1</span>,id+<span class="number">1</span>+n);</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) <span class="keyword">if</span> (id[i]==id[i<span class="number">-1</span>]) sum++;<span class="keyword">else</span> ans=<span class="built_in">max</span>(ans,sum),sum=<span class="number">1</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,n-<span class="built_in">max</span>(ans,sum)); </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>dp</tag>
        <tag>bzoj</tag>
        <tag>hash</tag>
      </tags>
  </entry>
  <entry>
    <title>Bzoj4011 [HNOI2015]落忆枫音</title>
    <url>/2023/10/05/bzoj4011-HNOI2015-%E8%90%BD%E5%BF%86%E6%9E%AB%E9%9F%B3/</url>
    <content><![CDATA[<h1 id="HNOI2015-落忆枫音"><a href="#HNOI2015-落忆枫音" class="headerlink" title="[HNOI2015]落忆枫音"></a>[HNOI2015]落忆枫音</h1><p><strong><a href="https://www.luogu.com.cn/problem/P3244">https://www.luogu.com.cn/problem/P3244</a></strong></p>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>很喵喵啊。</p>
<p>如果没有 DAG 另外加的 $(s,t)$，答案为 $\prod_{i&gt;1} in_i$，相当于随便选父亲。</p>
<p>但是现在有了，我们还是这么算，但是为了求出答案需要减掉包含环的数量。令 $in_i$ 表示在 DAG 上的节点的入度（即不包含 $(s,t)$）。令环上的点为 $a_1,a_2,..,a_k$，要减去的方案即为 $\prod_{x\not \in a} in_x$。即必选 $(s,t)$，然后除这个环以外的父亲随便选。</p>
<p>令 $f_x$ 表示从 $t$ 出发到 $x$ 上面的值。转移 $f_x&#x3D;\dfrac{1}{in_x}\sum_{(x,y)\in E} f_y$。</p>
<p>对原图记忆化搜索，或者叫 dfs 版本的拓扑。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 200005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> put() putchar(<span class="string">&#x27;\n&#x27;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Tp template<span class="string">&lt;typename Ty&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Ts template<span class="string">&lt;typename Ty,typename... Ar&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">(<span class="type">int</span> &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> f=<span class="number">1</span>;x=<span class="number">0</span>;<span class="type">char</span> c=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (c&lt;<span class="string">&#x27;0&#x27;</span>||c&gt;<span class="string">&#x27;9&#x27;</span>) &#123;<span class="keyword">if</span> (c==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">-1</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span> (c&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;c&lt;=<span class="string">&#x27;9&#x27;</span>) &#123;x=x*<span class="number">10</span>+c-<span class="string">&#x27;0&#x27;</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> Debug&#123;</span><br><span class="line">	Tp <span class="type">void</span> _debug(<span class="type">char</span>* f,Ty t)&#123;cerr&lt;&lt;f&lt;&lt;<span class="string">&#x27;=&#x27;</span>&lt;&lt;t&lt;&lt;endl;&#125;</span><br><span class="line">	Ts <span class="type">void</span> _debug(<span class="type">char</span>* f,Ty x,Ar... y)&#123;<span class="keyword">while</span>(*f!=<span class="string">&#x27;,&#x27;</span>) cerr&lt;&lt;*f++;cerr&lt;&lt;<span class="string">&#x27;=&#x27;</span>&lt;&lt;x&lt;&lt;<span class="string">&quot;,&quot;</span>;_debug(f+<span class="number">1</span>,y...);&#125;</span><br><span class="line">	Tp ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; os,vector&lt;Ty&gt;&amp; V)&#123;os&lt;&lt;<span class="string">&quot;[&quot;</span>;<span class="keyword">for</span>(<span class="keyword">auto</span>&amp; vv:V) os&lt;&lt;vv&lt;&lt;<span class="string">&quot;,&quot;</span>;os&lt;&lt;<span class="string">&quot;]&quot;</span>;<span class="keyword">return</span> os;&#125;</span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> gdb(...) _debug((char*)#__VA_ARGS__,__VA_ARGS__)</span></span><br><span class="line">&#125;<span class="keyword">using</span> <span class="keyword">namespace</span> Debug;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mk make_pair</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">power</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y=mod<span class="number">-2</span>)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> sum=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (y) &#123;</span><br><span class="line">		<span class="keyword">if</span> (y&amp;<span class="number">1</span>) sum=sum*x%mod;</span><br><span class="line">		x=x*x%mod;y&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> in[maxn],f[maxn];</span><br><span class="line"><span class="type">int</span> n,m,s,t,ans=<span class="number">1</span>,res=<span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> &amp;x,<span class="type">int</span> y)</span> </span>&#123;x=(x+y)%mod;&#125;</span><br><span class="line">pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;e[maxn];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;to[maxn];</span><br><span class="line"><span class="type">int</span> vis[maxn];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (vis[x]) <span class="keyword">return</span> ;</span><br><span class="line">	vis[x]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span> (x==s) &#123;f[x]=res*<span class="built_in">power</span>(in[x])%mod;<span class="keyword">return</span> ;&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> y:to[x]) &#123;</span><br><span class="line">		<span class="built_in">dfs</span>(y);</span><br><span class="line">		<span class="built_in">add</span>(f[x],f[y]);</span><br><span class="line">	&#125;</span><br><span class="line">	f[x]=f[x]*<span class="built_in">power</span>(in[x])%mod;</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> i,x,y;</span><br><span class="line">	<span class="built_in">read</span>(n);<span class="built_in">read</span>(m);<span class="built_in">read</span>(s);<span class="built_in">read</span>(t);</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=m;i++) <span class="built_in">read</span>(e[i].fi),<span class="built_in">read</span>(e[i].se),to[e[i].fi].<span class="built_in">push_back</span>(e[i].se),in[e[i].se]++;</span><br><span class="line">	in[<span class="number">1</span>]++;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (i==t) ans=ans*(in[i]+<span class="number">1</span>)%mod;</span><br><span class="line">		<span class="keyword">else</span> ans=ans*in[i]%mod;</span><br><span class="line">		res=res*in[i]%mod;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">dfs</span>(t);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,(ans-f[t]+mod)%mod);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>dp</tag>
        <tag>容斥</tag>
        <tag>组合</tag>
      </tags>
  </entry>
  <entry>
    <title>Bzoj4012</title>
    <url>/2022/06/29/bzoj4012/</url>
    <content><![CDATA[<p>点分树两个关键的性质：</p>
<ul>
<li><p>点分树最大深度是 $\log$ 级别的</p>
</li>
<li><p>点分树上两点的 $lca$ 在原树上两点之间的路径上</p>
</li>
</ul>
<h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><p>前情提要：那个每个点的度数小于等于三是用来卡常的。</p>
<p>首先假设没有 $l,r$ 的限制，询问某个点到其他所有点的距离之和，我们用点分树去做该如何做。</p>
<p>$sum[x][0]$ 表示点分树上$x$子树的所有点到 $x$ 的距离和</p>
<p>$sum[x][1]$ 表示点分树上 $x$ 子树的所有点到 $x$ 点分树上父亲的距离和</p>
<p>$size_x$ 表示点分树上 $x$ 子树大小</p>
<p>显然对于询问的点 $x$，我们跳点分树上的父亲即可，初始时 $ans$ 设为也就 $sum[x][0]$ 是点分树 $x$ 子树下方的贡献和。</p>
<p>跳点分树父亲时，当前跳到点 $i$（点 $i$ 要有父亲），$ans +&#x3D; sum[fa_i][0] - sum[i][1] + (siz_{fa_i} - siz_i) * Dis(x, fa_i)$</p>
<p>其中的减法是减去多算的。</p>
<p>加上 $l,r$ 的限制，只要把每个节点的在点分树上子树的点全存在一个 $vector$ 里，排个序然后前缀和+二分即可。</p>
<p><strong>解决路径相关而与树的形态不想关的题目，考虑点分治或者点分树。</strong></p>
<h3 id="code"><a href="#code" class="headerlink" title="code"></a>code</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#define ll long long </span><br><span class="line">#define maxn 200005</span><br><span class="line">#define put() putchar(&#x27;\n&#x27;)</span><br><span class="line">using namespace std;</span><br><span class="line">struct FastIO&#123;</span><br><span class="line">	static const int S=1048576;</span><br><span class="line">	char buf[S],*L,*R;int stk[20],Top;~FastIO()&#123;clear();&#125;</span><br><span class="line">	inline char nc()&#123;return L==R&amp;&amp;(R=(L=buf)+fread(buf,1,S,stdin),L==R)?EOF:*L++;&#125;inline void clear()&#123;fwrite(buf,1,Top,stdout);Top=0;&#125;</span><br><span class="line">	inline void pc(char ch)&#123;Top==S&amp;&amp;(clear(),0);buf[Top++]=ch;&#125;inline void endl()&#123;pc(&#x27;\n&#x27;);&#125;</span><br><span class="line">	FastIO&amp; operator &gt;&gt; (char&amp;ch)&#123;while(ch=nc(),ch==&#x27; &#x27;||ch==&#x27;\n&#x27;);return *this;&#125;</span><br><span class="line">	template&lt;typename T&gt;FastIO&amp; operator &gt;&gt; (T&amp;ret)&#123;</span><br><span class="line">		ret=0;int f=1;char ch=nc();while(ch&lt;&#x27;0&#x27;||ch&gt;&#x27;9&#x27;)&#123;if(ch==&#x27;-&#x27;)f=-f;ch=nc();&#125;</span><br><span class="line">		while(ch&gt;=&#x27;0&#x27;&amp;&amp;ch&lt;=&#x27;9&#x27;)&#123;ret=ret*10+ch-&#x27;0&#x27;;ch=nc();&#125;ret*=f;return *this;</span><br><span class="line">	&#125;</span><br><span class="line">	FastIO&amp; operator &gt;&gt; (char* s)&#123;int Len=0;char ch=nc();while(ch!=&#x27;\n&#x27;)&#123;*(s+Len)=ch;Len++;ch=nc();&#125;&#125;</span><br><span class="line">	template&lt;typename T&gt;FastIO&amp; operator &lt;&lt; (T x)&#123;</span><br><span class="line">		if(x&lt;0)&#123;pc(&#x27;-&#x27;);x=-x;&#125;do&#123;stk[++stk[0]]=x%10;x/=10;&#125;while(x);</span><br><span class="line">		while(stk[0]) pc(&#x27;0&#x27;+stk[stk[0]--]);return *this;</span><br><span class="line">	&#125;</span><br><span class="line">	FastIO&amp; operator &lt;&lt; (char ch)&#123;pc(ch);return *this;&#125;</span><br><span class="line">	FastIO&amp; operator &lt;&lt; (string str)&#123;int Len=str.size()-1;for(stk[0]=0;Len&gt;=0;Len--) stk[++stk[0]]=str[Len];while(stk[0]) pc(stk[stk[0]--]);return *this;&#125;</span><br><span class="line">&#125;fin,fout;</span><br><span class="line">const int inf=1e9;</span><br><span class="line">int h[maxn],head=1,lg[maxn],n,m;</span><br><span class="line">int w[maxn],fa[maxn],size[maxn],Max[maxn];</span><br><span class="line">ll dis[maxn];</span><br><span class="line">struct yyy&#123;</span><br><span class="line">	ll sum;int id;</span><br><span class="line">	yyy(int a=0,ll b=0) &#123;id=a;sum=b;&#125;</span><br><span class="line">	bool operator &lt;(const yyy &amp;x) const &#123;return id&lt;x.id;&#125; </span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;yyy&gt;t[maxn][2];</span><br><span class="line">bitset&lt;maxn&gt; vis;</span><br><span class="line">struct node&#123;</span><br><span class="line">	int to,z,w;</span><br><span class="line">	inline void add(int x,int y,int val)&#123;</span><br><span class="line">		to=y;z=h[x];h[x]=head;w=val;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;a[maxn*2];</span><br><span class="line">namespace lca&#123;</span><br><span class="line">	int fa[maxn][21],deep[maxn];</span><br><span class="line">	inline void dfs(int x,int pre)&#123;</span><br><span class="line">		int i;deep[x]=deep[pre]+1;fa[x][0]=pre;</span><br><span class="line">		for (i=1;i&lt;=lg[deep[x]];i++) fa[x][i]=fa[fa[x][i-1]][i-1];</span><br><span class="line">		for (i=h[x];i;i=a[i].z) if (a[i].to^pre) dis[a[i].to]=dis[x]+a[i].w,dfs(a[i].to,x);</span><br><span class="line">	&#125;</span><br><span class="line">	inline int query(int x,int y)&#123;</span><br><span class="line">		int i;</span><br><span class="line">		if (deep[x]&lt;deep[y]) swap(x,y);</span><br><span class="line">		while (deep[x]&gt;deep[y]) x=fa[x][lg[deep[x]-deep[y]]];</span><br><span class="line">		if (x==y) return x;</span><br><span class="line">		for (i=lg[deep[x]];i&gt;=0;i--) if (fa[x][i]!=fa[y][i]) x=fa[x][i],y=fa[y][i];</span><br><span class="line">		return fa[x][0];</span><br><span class="line">	&#125;</span><br><span class="line">	inline ll d(int x,int y)&#123;</span><br><span class="line">		return dis[x]+dis[y]-2*dis[query(x,y)];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">int root,Size,maxroot;</span><br><span class="line">inline void dfs(int x,int pre)&#123;</span><br><span class="line">	int i;size[x]=1;</span><br><span class="line">//	t[root][0].push_back(yyy(w[x],lca::d(x,root)));</span><br><span class="line">//	if (fa[root]) t[root][1].push_back(yyy(w[x],lca::d(x,fa[root])));</span><br><span class="line">	for (i=h[x];i;i=a[i].z) </span><br><span class="line">	    if (a[i].to!=pre&amp;&amp;!vis[a[i].to]) </span><br><span class="line">		    dfs(a[i].to,x),size[x]+=size[a[i].to];</span><br><span class="line">&#125;</span><br><span class="line">inline void getroot(int x,int pre) &#123;</span><br><span class="line">	int i,maxs=0;size[x]=1;</span><br><span class="line">	for (i=h[x];i;i=a[i].z)</span><br><span class="line">	    if (a[i].to!=pre&amp;&amp;!vis[a[i].to]) &#123;</span><br><span class="line">	    	getroot(a[i].to,x);</span><br><span class="line">	        size[x]+=size[a[i].to];</span><br><span class="line">	        maxs=max(maxs,size[a[i].to]);</span><br><span class="line">		&#125;</span><br><span class="line">	maxs=max(maxs,Size-size[x]);</span><br><span class="line">	if (maxroot&gt;maxs) root=x,maxroot=maxs;</span><br><span class="line">&#125;</span><br><span class="line">inline void solve(int x,int pre) &#123;</span><br><span class="line">	int i;</span><br><span class="line">	vis[x]=1;dfs(x,0);</span><br><span class="line">	for (i=h[x];i;i=a[i].z)</span><br><span class="line">	    if (!vis[a[i].to]) &#123;</span><br><span class="line">	    	maxroot=inf;Size=size[a[i].to];getroot(a[i].to,x);</span><br><span class="line">	    	fa[root]=x;solve(root,x);</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br><span class="line">inline ll query(int op,int x,int l,int r,ll &amp;size) &#123;</span><br><span class="line">	int lef=lower_bound(t[x][op].begin(),t[x][op].end(),yyy(l,0))-t[x][op].begin()-1;</span><br><span class="line">	int rig=upper_bound(t[x][op].begin(),t[x][op].end(),yyy(r,0))-t[x][op].begin()-1;</span><br><span class="line">	size=rig-lef;</span><br><span class="line">	ll ans=0;</span><br><span class="line">	if (rig&gt;=0&amp;&amp;rig&lt;t[x][op].size()) ans+=t[x][op][rig].sum;</span><br><span class="line">	if (lef&gt;=0&amp;&amp;lef&lt;t[x][op].size()) ans-=t[x][op][lef].sum;</span><br><span class="line">	return ans;</span><br><span class="line">&#125;</span><br><span class="line">ll lastans;</span><br><span class="line">signed main()&#123;</span><br><span class="line">    int i,x,y,z,j,A,len;</span><br><span class="line">    int l,r;</span><br><span class="line">    fin&gt;&gt;n&gt;&gt;m&gt;&gt;A;</span><br><span class="line">    for (i=1;i&lt;=n;i++) fin&gt;&gt;w[i];</span><br><span class="line">    for (i=1;i&lt;n;i++) &#123;</span><br><span class="line">    	fin&gt;&gt;x&gt;&gt;y&gt;&gt;z;</span><br><span class="line">    	a[++head].add(x,y,z);</span><br><span class="line">    	a[++head].add(y,x,z);</span><br><span class="line">	&#125;</span><br><span class="line">	for (i=2;i&lt;=n;i++) lg[i]=lg[i/2]+1;</span><br><span class="line">	lca::dfs(1,0);</span><br><span class="line">	Size=n;maxroot=inf;</span><br><span class="line">	getroot(1,0);</span><br><span class="line">	solve(root,0);</span><br><span class="line">	for (i=1;i&lt;=n;i++) &#123;</span><br><span class="line">		for (j=i;j;j=fa[j]) &#123;</span><br><span class="line">			t[j][0].push_back(yyy(w[i],lca::d(i,j)));</span><br><span class="line">			if (fa[j]) t[j][1].push_back(yyy(w[i],lca::d(i,fa[j])));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	for (i=1;i&lt;=n;i++) &#123;</span><br><span class="line">		sort(t[i][0].begin(),t[i][0].end());</span><br><span class="line">		sort(t[i][1].begin(),t[i][1].end());</span><br><span class="line">		len=t[i][0].size();for (j=1;j&lt;len;j++) t[i][0][j].sum+=t[i][0][j-1].sum;</span><br><span class="line">		len=t[i][1].size();for (j=1;j&lt;len;j++) t[i][1][j].sum+=t[i][1][j-1].sum;</span><br><span class="line">	&#125;</span><br><span class="line">	while (m--)&#123;</span><br><span class="line">		fin&gt;&gt;x&gt;&gt;l&gt;&gt;r;</span><br><span class="line">		l=(lastans+l)%A;r=(lastans+r)%A;</span><br><span class="line">		if (l&gt;r) swap(l,r);</span><br><span class="line">		ll sum1=0,sum2=0;</span><br><span class="line">		lastans=query(0,x,l,r,sum1);</span><br><span class="line">		for (i=x;fa[i];i=fa[i]) &#123;</span><br><span class="line">			lastans+=query(0,fa[i],l,r,sum2)-query(1,i,l,r,sum1);</span><br><span class="line">			lastans+=(sum2-sum1)*lca::d(x,fa[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		printf(&quot;%lld\n&quot;,lastans);</span><br><span class="line">	&#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>点分树</tag>
        <tag>bzoj</tag>
        <tag>点分治</tag>
      </tags>
  </entry>
  <entry>
    <title>Bzoj4036</title>
    <url>/2022/06/29/bzoj4036/</url>
    <content><![CDATA[<h4 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h4><p>设 JOI 三个字母的前缀个数分别为 $(a,b,c)$。</p>
<p>若要三个字母个数相同，则有 $(b_i-a_i,c_i-a_i)&#x3D;(b_j-a_i,c_j-a_i)$ 。</p>
<p>map 统计即可。</p>
<p>code:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> put() putchar(<span class="string">&#x27;\n&#x27;</span>)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(<span class="type">int</span> &amp;x)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> f=<span class="number">1</span>;x=<span class="number">0</span>;<span class="type">char</span> c=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span> (c&lt;<span class="string">&#x27;0&#x27;</span>||c&gt;<span class="string">&#x27;9&#x27;</span>) &#123;<span class="keyword">if</span> (c==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">-1</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">while</span> (c&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;c&lt;=<span class="string">&#x27;9&#x27;</span>) &#123;x=x*<span class="number">10</span>+c-<span class="string">&#x27;0&#x27;</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">	<span class="type">int</span> x,y;</span><br><span class="line">	<span class="built_in">node</span>(<span class="type">int</span> a=<span class="number">0</span>,<span class="type">int</span> b=<span class="number">0</span>) &#123;x=a;y=b;&#125;</span><br><span class="line">	<span class="type">bool</span> <span class="keyword">operator</span> &lt;(<span class="type">const</span> node &amp;a) <span class="type">const</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (x^a.x) <span class="keyword">return</span> x&lt;a.x;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">return</span> y&lt;a.y; </span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">map&lt;node,<span class="type">int</span> &gt;mp;</span><br><span class="line"><span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line"><span class="comment">//	freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);</span></span><br><span class="line">	<span class="type">int</span> i,sum1=<span class="number">0</span>,sum2=<span class="number">0</span>;string s;</span><br><span class="line">	<span class="built_in">read</span>(n);</span><br><span class="line">	cin&gt;&gt;s;</span><br><span class="line">	mp[<span class="built_in">node</span>(<span class="number">0</span>,<span class="number">0</span>)]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (s[i]==<span class="string">&#x27;J&#x27;</span>) sum1--,sum2--;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (s[i]==<span class="string">&#x27;O&#x27;</span>) sum1++;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (s[i]==<span class="string">&#x27;I&#x27;</span>) sum2++;</span><br><span class="line">		<span class="keyword">if</span> (!mp[<span class="built_in">node</span>(sum1,sum2)]) mp[<span class="built_in">node</span>(sum1,sum2)]=i+<span class="number">2</span>;</span><br><span class="line">		<span class="keyword">else</span> ans=<span class="built_in">max</span>(ans,i+<span class="number">1</span>-mp[<span class="built_in">node</span>(sum1,sum2)]+<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>bzoj</tag>
        <tag>暴力</tag>
      </tags>
  </entry>
  <entry>
    <title>Bzoj4238</title>
    <url>/2022/06/29/bzoj4238/</url>
    <content><![CDATA[<h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><p>基本与 <a href="http://www.wgyhm.cf/post/cfcf19eandcf1680f/">CF19E</a> 相同。</p>
<p>值得注意的是，如果这个图为二分图，那么在偶环里边也不可以选。具体上的原因是题目的差异。</p>
<h3 id="code"><a href="#code" class="headerlink" title="code"></a>code</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 2000005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> put() putchar(<span class="string">&#x27;\n&#x27;</span>)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(<span class="type">int</span> &amp;x)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> f=<span class="number">1</span>;x=<span class="number">0</span>;<span class="type">char</span> c=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span> (c&lt;<span class="string">&#x27;0&#x27;</span>||c&gt;<span class="string">&#x27;9&#x27;</span>) &#123;<span class="keyword">if</span> (c==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">-1</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">while</span> (c&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;c&lt;=<span class="string">&#x27;9&#x27;</span>) &#123;x=x*<span class="number">10</span>+c-<span class="string">&#x27;0&#x27;</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> head=<span class="number">1</span>,h[maxn];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">yyy</span>&#123;</span><br><span class="line">	<span class="type">int</span> to,z,flag;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">		to=y;z=h[x];h[x]=head;flag=<span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;a[maxn*<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> c[maxn],fa[maxn],cnt[<span class="number">2</span>][maxn];</span><br><span class="line"><span class="type">int</span> n,m,tot,times,dfn[maxn];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> pre,<span class="type">int</span> color)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> i;c[x]=color;dfn[x]=++times;</span><br><span class="line">	<span class="keyword">for</span> (i=h[x];i;i=a[i].z) </span><br><span class="line">	    <span class="keyword">if</span> ((i^<span class="number">1</span>)!=fa[x]) &#123;</span><br><span class="line">	    	<span class="keyword">if</span> (!c[a[i].to]) fa[a[i].to]=i,a[i].flag=a[i^<span class="number">1</span>].flag=<span class="number">1</span>,<span class="built_in">dfs</span>(a[i].to,x,<span class="number">3</span>-color);</span><br><span class="line">	    	<span class="keyword">else</span> <span class="keyword">if</span> (dfn[a[i].to]&lt;dfn[x])&#123;</span><br><span class="line">	    		<span class="keyword">if</span> (c[a[i].to]!=c[x]) cnt[<span class="number">0</span>][fa[x]]++,cnt[<span class="number">0</span>][fa[a[i].to]]--,cnt[<span class="number">0</span>][i]++;</span><br><span class="line">	    		<span class="keyword">else</span> cnt[<span class="number">1</span>][fa[x]]++,cnt[<span class="number">1</span>][fa[a[i].to]]--,cnt[<span class="number">1</span>][i]++,tot++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> vis[maxn];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> pre)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> i;vis[x]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (i=h[x];i;i=a[i].z)</span><br><span class="line">	    <span class="keyword">if</span> (a[i].to!=pre&amp;&amp;!vis[a[i].to]) &#123;</span><br><span class="line">	    	<span class="built_in">dfs2</span>(a[i].to,x);</span><br><span class="line">	    	cnt[<span class="number">0</span>][fa[x]]+=cnt[<span class="number">0</span>][i];</span><br><span class="line">	    	cnt[<span class="number">1</span>][fa[x]]+=cnt[<span class="number">1</span>][i];</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">dfs3</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> pre,<span class="type">int</span> color)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> i,tmp=<span class="number">0</span>;c[x]=color;</span><br><span class="line">	<span class="keyword">for</span> (i=h[x];i;i=a[i].z)</span><br><span class="line">	    <span class="keyword">if</span> (a[i].to!=pre&amp;&amp;a[i].flag==<span class="number">0</span>) &#123;</span><br><span class="line">	    	<span class="keyword">if</span> (!c[a[i].to]) tmp|=<span class="built_in">dfs3</span>(a[i].to,x,<span class="number">3</span>-color);</span><br><span class="line">	    	<span class="keyword">else</span> <span class="keyword">if</span> (c[a[i].to]==c[x]) tmp=<span class="number">1</span>; </span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">solve</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> i,x,y,ans=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">read</span>(n);<span class="built_in">read</span>(m);</span><br><span class="line">	head=<span class="number">1</span>,tot=<span class="number">0</span>;times=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) h[i]=vis[i]=c[i]=fa[i]=dfn[i]=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=<span class="number">2</span>*m+<span class="number">1</span>;i++) cnt[<span class="number">0</span>][i]=cnt[<span class="number">1</span>][i]=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=m;i++) &#123;</span><br><span class="line">		<span class="built_in">read</span>(x);<span class="built_in">read</span>(y);</span><br><span class="line">		a[++head].<span class="built_in">add</span>(x,y);</span><br><span class="line">		a[++head].<span class="built_in">add</span>(y,x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) <span class="keyword">if</span> (!dfn[i]) <span class="built_in">dfs</span>(i,<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) <span class="keyword">if</span> (!vis[i]) <span class="built_in">dfs2</span>(i,<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) c[i]=<span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> flag=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">2</span>;i&lt;=head;i+=<span class="number">2</span>) cnt[<span class="number">0</span>][i]+=cnt[<span class="number">0</span>][i^<span class="number">1</span>],cnt[<span class="number">1</span>][i]+=cnt[<span class="number">1</span>][i^<span class="number">1</span>];</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">2</span>;i&lt;=head;i+=<span class="number">2</span>) <span class="keyword">if</span> (!cnt[<span class="number">0</span>][i]&amp;&amp;cnt[<span class="number">1</span>][i]==tot) ans++;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">	<span class="built_in">solve</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>二分图</tag>
        <tag>构造</tag>
        <tag>bzoj</tag>
      </tags>
  </entry>
  <entry>
    <title>Bzoj4381</title>
    <url>/2022/06/29/bzoj4381/</url>
    <content><![CDATA[<h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><p>看到 $n\le 50000$ ，考虑根号分治。我们设定一个阈值 $K$。</p>
<ul>
<li><p>对于 $c_i\le K$ 的，前缀和预处理出每个 $sum_{i,j}$ 表示点 $j$ ，每次向上跳 $i$ 步，到根的权值。</p>
<p>复杂度是 $O(Kn)-O(q\log n)$</p>
</li>
<li><p>对于 $c_i&gt;K$ 的，暴力跳。复杂度是 $O(q\dfrac{n}{K}\log n)$ 或者 $O(q\dfrac{n}{K})$ 的如果你会长链剖分<del>反正我是不会</del></p>
</li>
</ul>
<p>这种情况一般 $K&#x3D;\sqrt{n}$ ，但是一般来说 $K$ 取更小一点效果更好。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 50005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> put() putchar(<span class="string">&#x27;\n&#x27;</span>)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(<span class="type">int</span> &amp;x)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> f=<span class="number">1</span>;x=<span class="number">0</span>;<span class="type">char</span> c=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span> (c&lt;<span class="string">&#x27;0&#x27;</span>||c&gt;<span class="string">&#x27;9&#x27;</span>) &#123;<span class="keyword">if</span> (c==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">-1</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">while</span> (c&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;c&lt;=<span class="string">&#x27;9&#x27;</span>) &#123;x=x*<span class="number">10</span>+c-<span class="string">&#x27;0&#x27;</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> b[maxn],c[maxn],w[maxn],g[<span class="number">505</span>][maxn],ff[maxn],tr[maxn];</span><br><span class="line"><span class="type">int</span> h[maxn],head=<span class="number">1</span>,fa[maxn][<span class="number">21</span>],deep[maxn],lg[maxn*<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">yyy</span>&#123;</span><br><span class="line">	<span class="type">int</span> to,z;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">		to=y;z=h[x];h[x]=head;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;a[maxn*<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">ins</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">	a[++head].<span class="built_in">add</span>(x,y);</span><br><span class="line">	a[++head].<span class="built_in">add</span>(y,x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> block;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> pre)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> i;deep[x]=deep[pre]+<span class="number">1</span>;fa[x][<span class="number">0</span>]=pre;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=lg[deep[x]];i++) fa[x][i]=fa[fa[x][i<span class="number">-1</span>]][i<span class="number">-1</span>];</span><br><span class="line">	<span class="keyword">for</span> (i=h[x];i;i=a[i].z) <span class="keyword">if</span> (a[i].to^pre) <span class="built_in">dfs1</span>(a[i].to,x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">lca</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> i;<span class="keyword">if</span> (deep[x]&lt;deep[y]) <span class="built_in">swap</span>(x,y);</span><br><span class="line">	<span class="keyword">while</span> (deep[x]&gt;deep[y]) x=fa[x][lg[deep[x]-deep[y]]];</span><br><span class="line">	<span class="keyword">if</span> (x==y) <span class="keyword">return</span> x;</span><br><span class="line">	<span class="keyword">for</span> (i=lg[deep[x]];i&gt;=<span class="number">0</span>;i--) <span class="keyword">if</span> (fa[x][i]^fa[y][i]) x=fa[x][i],y=fa[y][i];</span><br><span class="line">	<span class="keyword">return</span> fa[x][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> pre,<span class="type">int</span> j)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> i;g[j][x]=g[j][ff[x]]+w[x];</span><br><span class="line">	<span class="keyword">for</span> (i=h[x];i;i=a[i].z) <span class="keyword">if</span> (a[i].to^pre) <span class="built_in">dfs2</span>(a[i].to,x,j);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">getfa</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="keyword">for</span> (i=lg[k];i&gt;=<span class="number">0</span>;i--) <span class="keyword">if</span> ((k&gt;&gt;i)&amp;<span class="number">1</span>) x=fa[x][i];</span><br><span class="line">	<span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;1.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">	<span class="type">int</span> i,j,now,sum,z,x,y,tmp,pus;</span><br><span class="line">	<span class="built_in">read</span>(n);</span><br><span class="line">	block=<span class="built_in">sqrt</span>(n)/<span class="number">3</span>;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">2</span>;i&lt;=n*<span class="number">2</span>;i++) lg[i]=lg[i/<span class="number">2</span>]+<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">read</span>(w[i]);</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;n;i++) &#123;</span><br><span class="line">		<span class="built_in">read</span>(x);<span class="built_in">read</span>(y);</span><br><span class="line">		<span class="built_in">ins</span>(x,y);</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">read</span>(b[i]);</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;n;i++) <span class="built_in">read</span>(c[i]);</span><br><span class="line">	<span class="built_in">dfs1</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) ff[i]=i;</span><br><span class="line">	<span class="keyword">for</span> (j=<span class="number">1</span>;j&lt;=block;j++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) tr[i]=ff[i];</span><br><span class="line">		<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) ff[i]=fa[tr[i]][<span class="number">0</span>];</span><br><span class="line">	    <span class="built_in">dfs2</span>(<span class="number">1</span>,<span class="number">0</span>,j);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;n;i++) &#123;</span><br><span class="line">		x=b[i],y=b[i+<span class="number">1</span>];</span><br><span class="line">		<span class="keyword">if</span> (c[i]&lt;=block) &#123;</span><br><span class="line">			z=<span class="built_in">lca</span>(x,y);sum=<span class="number">0</span>;</span><br><span class="line">			<span class="keyword">if</span> (deep[x]&lt;deep[y]) <span class="built_in">swap</span>(x,y);</span><br><span class="line">			tmp=(deep[x]-deep[z]+c[i])/c[i]*c[i];sum+=g[c[i]][x]-g[c[i]][pus=<span class="built_in">getfa</span>(x,tmp)];<span class="comment">//printf(&quot;%d %d %d %d\n&quot;,c[i],x,pus,tmp);</span></span><br><span class="line">			<span class="keyword">if</span> (y^z) tmp=(deep[y]-deep[z]<span class="number">-1</span>+c[i])/c[i]*c[i],sum+=g[c[i]][y]-g[c[i]][pus=<span class="built_in">getfa</span>(y,tmp)];<span class="comment">//printf(&quot;%d %d %d %d\n&quot;,c[i],y,pus,tmp);</span></span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,sum);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			sum=<span class="number">0</span>;z=<span class="built_in">lca</span>(x,y);</span><br><span class="line">			now=x;<span class="keyword">while</span> (deep[now]&gt;=deep[z]) &#123;</span><br><span class="line">			    sum+=w[now];</span><br><span class="line">				<span class="keyword">if</span> (deep[now]&gt;c[i]) now=<span class="built_in">getfa</span>(now,c[i]);</span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			now=y;<span class="keyword">while</span> (deep[now]&gt;deep[z])  &#123;</span><br><span class="line">			    sum+=w[now];</span><br><span class="line">				<span class="keyword">if</span> (deep[now]&gt;c[i]) now=<span class="built_in">getfa</span>(now,c[i]);</span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		<span class="comment">//	if (y==z) sum-=w[z]; </span></span><br><span class="line">		    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,sum);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>bzoj</tag>
        <tag>树</tag>
        <tag>根号分治</tag>
      </tags>
  </entry>
  <entry>
    <title>Bzoj4435 [CERC2015]Juice Junctions</title>
    <url>/2022/11/18/bzoj4435-CERC2015-Juice-Junctions/</url>
    <content><![CDATA[<h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><p><del>在最小割的方向上想了一个小时</del></p>
<p>显然 $i$ 到 $j$ 的最小割只有 $0,1,2,3$ 三种情况，考虑每种答案的条件。</p>
<ul>
<li>$w(i,j)&#x3D;0$ 时，$i$ 和 $j$ 不连通。</li>
<li>$w(i,j)&#x3D;1$ 时，$i$ 和 $j$ 不在一个边双内。</li>
<li>$w(i,j)\ge 2$ 时，$i$ 和 $j$ 在一个边双内。<ul>
<li>考虑 $w(i,j)&#x3D;3$ 时，一定是整张图删除任意一条边都在同一个边双中。预处理出删除每一条边时，每个点在哪个边双中。对于判断两个集合是否相同，使用哈希判断。</li>
<li>否则 $w(i,j)&#x3D;2$</li>
</ul>
</li>
</ul>
<p><strong>如果时间充裕，请不要使用单模哈希</strong></p>
<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 5005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> put() putchar(<span class="string">&#x27;\n&#x27;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Tp template<span class="string">&lt;typename Ty&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Ts template<span class="string">&lt;typename Ty,typename... Ar&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(<span class="type">int</span> &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> f=<span class="number">1</span>;x=<span class="number">0</span>;<span class="type">char</span> c=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (c&lt;<span class="string">&#x27;0&#x27;</span>||c&gt;<span class="string">&#x27;9&#x27;</span>) &#123;<span class="keyword">if</span> (c==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">-1</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span> (c&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;c&lt;=<span class="string">&#x27;9&#x27;</span>) &#123;x=x*<span class="number">10</span>+c-<span class="string">&#x27;0&#x27;</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> Debug&#123;</span><br><span class="line">	Tp <span class="type">void</span> _debug(<span class="type">char</span>* f,Ty t)&#123;cerr&lt;&lt;f&lt;&lt;<span class="string">&#x27;=&#x27;</span>&lt;&lt;t&lt;&lt;endl;&#125;</span><br><span class="line">	Ts <span class="type">void</span> _debug(<span class="type">char</span>* f,Ty x,Ar... y)&#123;<span class="keyword">while</span>(*f!=<span class="string">&#x27;,&#x27;</span>) cerr&lt;&lt;*f++;cerr&lt;&lt;<span class="string">&#x27;=&#x27;</span>&lt;&lt;x&lt;&lt;<span class="string">&quot;,&quot;</span>;_debug(f+<span class="number">1</span>,y...);&#125;</span><br><span class="line">	Tp ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; os,vector&lt;Ty&gt;&amp; V)&#123;os&lt;&lt;<span class="string">&quot;[&quot;</span>;<span class="keyword">for</span>(<span class="keyword">auto</span>&amp; vv:V) os&lt;&lt;vv&lt;&lt;<span class="string">&quot;,&quot;</span>;os&lt;&lt;<span class="string">&quot;]&quot;</span>;<span class="keyword">return</span> os;&#125;</span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> gdb(...) _debug((char*)#__VA_ARGS__,__VA_ARGS__)</span></span><br><span class="line">&#125;<span class="keyword">using</span> <span class="keyword">namespace</span> Debug;</span><br><span class="line"><span class="type">int</span> n,m,h[maxn],head=<span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> dfn[maxn],low[maxn],stac[maxn],tot,times;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">yyy</span>&#123;</span><br><span class="line">	<span class="type">int</span> to,z,flag;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">		to=y;z=h[x];h[x]=head;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;a[maxn*<span class="number">3</span>];</span><br><span class="line">ull has1[maxn],has2[maxn];</span><br><span class="line"><span class="type">const</span> ull base1=<span class="number">131</span>,base2=<span class="number">171</span>,mod=<span class="number">998244353</span>;</span><br><span class="line"><span class="type">int</span> ecc[maxn],eccnum;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">tarjan</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> pre)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	low[x]=dfn[x]=++times;stac[++tot]=x;</span><br><span class="line">	<span class="keyword">for</span> (i=h[x];i;i=a[i].z) <span class="keyword">if</span> (a[i].flag!=<span class="number">1</span>&amp;&amp;i!=pre&amp;&amp;i!=(pre^<span class="number">1</span>)) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!dfn[a[i].to])&#123;</span><br><span class="line">			<span class="built_in">tarjan</span>(a[i].to,i);</span><br><span class="line">			low[x]=<span class="built_in">min</span>(low[x],low[a[i].to]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> low[x]=<span class="built_in">min</span>(dfn[a[i].to],low[x]);</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (low[x]==dfn[x]) &#123;</span><br><span class="line">		++eccnum;</span><br><span class="line">		<span class="keyword">while</span> (stac[tot+<span class="number">1</span>]!=x) &#123;</span><br><span class="line">			ecc[stac[tot]]=eccnum;</span><br><span class="line">			tot--;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> fa[maxn],ans;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">getfa</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;<span class="keyword">return</span> x==fa[x]?x:fa[x]=<span class="built_in">getfa</span>(fa[x]);&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> i,j,x,y;</span><br><span class="line">	<span class="built_in">read</span>(n);<span class="built_in">read</span>(m);</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) fa[i]=i;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=m;i++) &#123;</span><br><span class="line">		<span class="built_in">read</span>(x);<span class="built_in">read</span>(y);</span><br><span class="line">		a[++head].<span class="built_in">add</span>(x,y);</span><br><span class="line">		a[++head].<span class="built_in">add</span>(y,x);</span><br><span class="line">		<span class="built_in">assert</span>(x!=y);</span><br><span class="line">		x=<span class="built_in">getfa</span>(x),y=<span class="built_in">getfa</span>(y);<span class="keyword">if</span> (x^y) fa[x]=y;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=m+<span class="number">1</span>;i++) &#123;</span><br><span class="line">		a[<span class="number">2</span>*i].flag=a[<span class="number">2</span>*i+<span class="number">1</span>].flag=<span class="number">1</span>;</span><br><span class="line">		times=eccnum=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (j=<span class="number">1</span>;j&lt;=n;j++) dfn[j]=low[j]=ecc[j]=stac[j]=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (j=<span class="number">1</span>;j&lt;=n;j++) <span class="keyword">if</span> (!dfn[j]) <span class="built_in">tarjan</span>(j,<span class="number">0</span>);</span><br><span class="line">		<span class="keyword">for</span> (j=<span class="number">1</span>;j&lt;=n;j++) has1[j]=(<span class="number">1ull</span>*has1[j]*base1+(ecc[j]+<span class="number">1</span>)),has2[j]=(has2[j]*base2+ecc[j]+<span class="number">1</span>)%mod;</span><br><span class="line">		a[<span class="number">2</span>*i].flag=a[<span class="number">2</span>*i+<span class="number">1</span>].flag=<span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (j=<span class="number">1</span>;j&lt;i;j++) &#123;</span><br><span class="line">			<span class="type">int</span> now=ans;</span><br><span class="line">			<span class="keyword">if</span> (<span class="built_in">getfa</span>(i)!=<span class="built_in">getfa</span>(j)) ;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				ans++;</span><br><span class="line">				<span class="keyword">if</span> (ecc[i]==ecc[j]) &#123;</span><br><span class="line">					ans++;</span><br><span class="line">					<span class="keyword">if</span> (has1[i]==has1[j]&amp;&amp;has2[i]==has2[j]) ans++;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>记得把栈里的数也一同清空了（对于我这种写法）。</p>
]]></content>
      <tags>
        <tag>tarjan</tag>
        <tag>bzoj</tag>
        <tag>哈希</tag>
      </tags>
  </entry>
  <entry>
    <title>Bzoj4543</title>
    <url>/2022/06/29/bzoj4543/</url>
    <content><![CDATA[<p>不会做。</p>
<p>首先我们我们可以观察到这三个点 $(x,y,z)$ ，存在一个点 $o$，使得 $(x,o)&#x3D;(y,o)&#x3D;(z,o)$。</p>
<p>这启发我们有两种思路：</p>
<ul>
<li><p>对于一个点 $x$ ，求到 $x$ 距离相等的点的个数。对于子树内部还好，但是对于整棵树来说比较难做。</p>
</li>
<li><p>对于一个点 $x$，以 $x$ 的中继点，找到在其子树内部的 $o$，类似于：</p>
<p><img src="https://s2.loli.net/2022/06/29/msEtqA8c2iMugD9.png"></p>
</li>
</ul>
<p>设 $f_{i,j}$ 表示在 $i$ 的子树内深度为 $j$ 的节点个数，$g_{i,j}$ 表示在 $i$ 的子树内，$\forall x,y,x\not &#x3D; y,(x,lca(x,y))&#x3D;(y,lca(x,y))&#x3D;(i,lca(x,y))+j$</p>
<p>转移就比较简单了。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ans += f[i][j - 1] * g[to][j];</span><br><span class="line">ans += f[to][j] * g[i][j + 1];</span><br><span class="line"></span><br><span class="line">g[i][j + 1] += f[to][j] * f[i][j + 1];</span><br><span class="line">g[i][j - 1] += g[to][j];</span><br><span class="line"></span><br><span class="line">f[i][j + 1] += f[to][j];</span><br></pre></td></tr></table></figure>

<p>以深度为下标，用长链剖分优化：</p>
<p>code:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 200005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> put() putchar(<span class="string">&#x27;\n&#x27;</span>)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(<span class="type">int</span> &amp;x)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> f=<span class="number">1</span>;x=<span class="number">0</span>;<span class="type">char</span> c=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span> (c&lt;<span class="string">&#x27;0&#x27;</span>||c&gt;<span class="string">&#x27;9&#x27;</span>) &#123;<span class="keyword">if</span> (c==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">-1</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">while</span> (c&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;c&lt;=<span class="string">&#x27;9&#x27;</span>) &#123;x=x*<span class="number">10</span>+c-<span class="string">&#x27;0&#x27;</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> deep[maxn],son[maxn],n,h[maxn],head=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">yyy</span>&#123;</span><br><span class="line">	<span class="type">int</span> to,z;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">		to=y;z=h[x];h[x]=head;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;a[maxn*<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> *f[maxn*<span class="number">2</span>],*g[maxn*<span class="number">2</span>],stac[maxn*<span class="number">4</span>],*id=stac;</span><br><span class="line"><span class="type">int</span> ans;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> pre)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> i;deep[x]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (i=h[x];i;i=a[i].z)</span><br><span class="line">	    <span class="keyword">if</span> (a[i].to^pre) &#123;</span><br><span class="line">	    	<span class="built_in">dfs1</span>(a[i].to,x);</span><br><span class="line">	    	<span class="keyword">if</span> (deep[x]&lt;deep[a[i].to]+<span class="number">1</span>) deep[x]=deep[a[i].to]+<span class="number">1</span>,son[x]=a[i].to;</span><br><span class="line">		&#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> pre)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> i,j;</span><br><span class="line">	f[x][<span class="number">0</span>]=<span class="number">1</span>;g[x][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (son[x]) f[son[x]]=f[x]+<span class="number">1</span>,g[son[x]]=g[x]<span class="number">-1</span>,<span class="built_in">solve</span>(son[x],x);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> ;</span><br><span class="line">	ans+=g[x][<span class="number">0</span>];</span><br><span class="line">	<span class="keyword">for</span> (i=h[x];i;i=a[i].z)</span><br><span class="line">	    <span class="keyword">if</span> (a[i].to!=pre&amp;&amp;a[i].to!=son[x]) &#123;</span><br><span class="line">	    	f[a[i].to]=id;id+=deep[a[i].to]*<span class="number">2</span>+<span class="number">2</span>;g[a[i].to]=id;id+=deep[a[i].to]*<span class="number">2</span>+<span class="number">2</span>;<span class="built_in">solve</span>(a[i].to,x);</span><br><span class="line">	    	<span class="keyword">for</span> (j=<span class="number">0</span>;j&lt;=deep[a[i].to];j++) &#123;</span><br><span class="line">	    		<span class="keyword">if</span> (j) ans+=g[a[i].to][j]*f[x][j<span class="number">-1</span>];</span><br><span class="line">			    ans+=f[a[i].to][j]*g[x][j+<span class="number">1</span>];</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">for</span> (j=<span class="number">0</span>;j&lt;=deep[a[i].to];j++)&#123;</span><br><span class="line">				g[x][j+<span class="number">1</span>]+=f[a[i].to][j]*f[x][j+<span class="number">1</span>];</span><br><span class="line">				<span class="keyword">if</span> (j) g[x][j<span class="number">-1</span>]+=g[a[i].to][j];</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">for</span> (j=<span class="number">1</span>;j&lt;=deep[a[i].to];j++) f[x][j]+=f[a[i].to][j<span class="number">-1</span>];</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> i,x,y;</span><br><span class="line">	<span class="built_in">read</span>(n);</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;n;i++) &#123;</span><br><span class="line">		<span class="built_in">read</span>(x);<span class="built_in">read</span>(y);</span><br><span class="line">		a[++head].<span class="built_in">add</span>(x,y);</span><br><span class="line">		a[++head].<span class="built_in">add</span>(y,x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">dfs1</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    f[<span class="number">1</span>]=id;id+=deep[<span class="number">1</span>]*<span class="number">2</span>;g[<span class="number">1</span>]=id;id+=deep[<span class="number">1</span>]*<span class="number">2</span>;</span><br><span class="line">    <span class="built_in">solve</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>dp</tag>
        <tag>计数</tag>
        <tag>长链剖分</tag>
        <tag>bzoj</tag>
      </tags>
  </entry>
  <entry>
    <title>Qoj6354 4</title>
    <url>/2023/10/09/qoj6354-4/</url>
    <content><![CDATA[<h1 id="K-4"><a href="#K-4" class="headerlink" title="K. 4"></a>K. 4</h1><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>求 $n$ 个店 $m$ 条边的无向图的四元团个数。</p>
<p>$n,m\le 10^5$，1s 512MB</p>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>先考虑求出 $O(m\sqrt m)$ 求出三元团。根据三元团建图的性质，每个点的出度都是 $O(\sqrt m)$ 的。</p>
<p>如果直接将三个点的相邻点用 <code>bitset</code> 与起来，复杂度是 $O(\dfrac{m^{2.5}}{w})$ ，感觉不太可接受。</p>
<p>观察到每个点的出度很小。所以第四个点应该最多只有 $O(\sqrt m )$ 种标号。重新标号即可。复杂度 $O(\dfrac{m^2}{w})$。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 100005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> put() putchar(<span class="string">&#x27;\n&#x27;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Tp template<span class="string">&lt;typename Ty&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Ts template<span class="string">&lt;typename Ty,typename... Ar&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">(<span class="type">int</span> &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> f=<span class="number">1</span>;x=<span class="number">0</span>;<span class="type">char</span> c=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (c&lt;<span class="string">&#x27;0&#x27;</span>||c&gt;<span class="string">&#x27;9&#x27;</span>) &#123;<span class="keyword">if</span> (c==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">-1</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span> (c&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;c&lt;=<span class="string">&#x27;9&#x27;</span>) &#123;x=x*<span class="number">10</span>+c-<span class="string">&#x27;0&#x27;</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> Debug&#123;</span><br><span class="line">	Tp <span class="type">void</span> _debug(<span class="type">char</span>* f,Ty t)&#123;cerr&lt;&lt;f&lt;&lt;<span class="string">&#x27;=&#x27;</span>&lt;&lt;t&lt;&lt;endl;&#125;</span><br><span class="line">	Ts <span class="type">void</span> _debug(<span class="type">char</span>* f,Ty x,Ar... y)&#123;<span class="keyword">while</span>(*f!=<span class="string">&#x27;,&#x27;</span>) cerr&lt;&lt;*f++;cerr&lt;&lt;<span class="string">&#x27;=&#x27;</span>&lt;&lt;x&lt;&lt;<span class="string">&quot;,&quot;</span>;_debug(f+<span class="number">1</span>,y...);&#125;</span><br><span class="line">	Tp ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; os,vector&lt;Ty&gt;&amp; V)&#123;os&lt;&lt;<span class="string">&quot;[&quot;</span>;<span class="keyword">for</span>(<span class="keyword">auto</span>&amp; vv:V) os&lt;&lt;vv&lt;&lt;<span class="string">&quot;,&quot;</span>;os&lt;&lt;<span class="string">&quot;]&quot;</span>;<span class="keyword">return</span> os;&#125;</span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> gdb(...) _debug((char*)#__VA_ARGS__,__VA_ARGS__)</span></span><br><span class="line">&#125;<span class="keyword">using</span> <span class="keyword">namespace</span> Debug;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mk make_pair</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">power</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y=mod<span class="number">-2</span>)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> sum=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (y) &#123;</span><br><span class="line">		<span class="keyword">if</span> (y&amp;<span class="number">1</span>) sum=sum*x%mod;</span><br><span class="line">		x=x*x%mod;y&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> d[maxn],n,m,ans,in[maxn],vis[maxn];</span><br><span class="line">pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;e[maxn];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;to[maxn];</span><br><span class="line">bitset&lt;405&gt;t[maxn];</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;1.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">	<span class="type">int</span> i,x,y;</span><br><span class="line">	<span class="built_in">read</span>(n);<span class="built_in">read</span>(m);</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=m;i++) &#123;</span><br><span class="line">		<span class="built_in">read</span>(x),<span class="built_in">read</span>(y);</span><br><span class="line">		e[i]=<span class="built_in">mk</span>(x,y);</span><br><span class="line">		in[x]++,in[y]++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=m;i++) &#123;</span><br><span class="line">		x=e[i].fi,y=e[i].se;</span><br><span class="line">		<span class="keyword">if</span> (in[x]&gt;in[y]||(in[x]==in[y]&amp;&amp;x&gt;y)) <span class="built_in">swap</span>(x,y);</span><br><span class="line">		to[x].<span class="built_in">push_back</span>(y);</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="type">int</span> nums=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> j:to[i]) vis[j]=++nums;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> j:to[i]) &#123;</span><br><span class="line">			t[j].<span class="built_in">reset</span>();</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">auto</span> k:to[j]) <span class="keyword">if</span> (vis[k]) t[j][vis[k]]=<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> j:to[i]) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">auto</span> k:to[j]) <span class="keyword">if</span> (vis[k]) &#123;</span><br><span class="line">				ans+=(t[j]&amp;t[k]).<span class="built_in">count</span>();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> j:to[i]) vis[j]=<span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,ans);</span><br><span class="line"> 	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>bitset</tag>
        <tag>三元环计数</tag>
      </tags>
  </entry>
  <entry>
    <title>Wqs二分小结</title>
    <url>/2023/08/24/wqs%E4%BA%8C%E5%88%86%E5%B0%8F%E7%BB%93/</url>
    <content><![CDATA[<h1 id="wqs-二分小结"><a href="#wqs-二分小结" class="headerlink" title="wqs 二分小结"></a>wqs 二分小结</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>wqs二分 是神仙 王钦石 在 2012 年论文中提出的一类二分方式。<br>基本是用来处理一类带有限制的问题的。比较明显的标志就是 <code>恰好选 K 个</code> 等。<br>使用 wqs二分 有一个前提：<strong>原问题具有凹凸性</strong>。</p>
<p>举个例子，比如我们的函数是上凸的。</p>
<p>那么根据定义，它的斜率肯定单调递减。</p>
<p>于是，我们可以二分这个斜率，然后快速算出它切这个凸包会切在哪里。</p>
<p>对于点 $(x,F(x))$，其实际意义在于恰好选 $x$ 个，其最大价值为 $F(x)$。二分求的是斜率的截距最小的。令二分的斜率为 $k$。</p>
<p>截距 $b&#x3D;F(x)-x\times k$，由于恰好选 $x$ 个，$-k$ 可以减到所有点的权值上。那么二分这个斜率的实际意义为，每个权值减去 $-k$ 之后，找到这个斜率下在凸包上最优是哪个点，也就是恰好选几个。只需要在每次二分判断的时候记录最优的时候选了几个。</p>
<h2 id="一些小问题"><a href="#一些小问题" class="headerlink" title="一些小问题"></a>一些小问题</h2><p>考虑三点共线的情况。所以每次二分权值的时候，强制令相同优的情况下，选择最多&#x2F;最少的个数。我习惯于选择最多的个数，实现看代码。</p>
<p>其实我自己都不知道我在讲什么，还是 zj 哥哥手把手教的更好。</p>
<h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h3 id="1-国家集训队-Tree-I"><a href="#1-国家集训队-Tree-I" class="headerlink" title="1. [国家集训队] Tree I"></a>1. [国家集训队] Tree I</h3><p><a href="https://www.luogu.com.cn/problem/P2619">https://www.luogu.com.cn/problem/P2619</a></p>
<p>为了满足最多的情况，强制在权值相同时，优先选择白边。复杂度 $O(n\log^2 n)$。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 100005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> put() putchar(<span class="string">&#x27;\n&#x27;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Tp template<span class="string">&lt;typename Ty&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Ts template<span class="string">&lt;typename Ty,typename... Ar&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(<span class="type">int</span> &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> f=<span class="number">1</span>;x=<span class="number">0</span>;<span class="type">char</span> c=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (c&lt;<span class="string">&#x27;0&#x27;</span>||c&gt;<span class="string">&#x27;9&#x27;</span>) &#123;<span class="keyword">if</span> (c==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">-1</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span> (c&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;c&lt;=<span class="string">&#x27;9&#x27;</span>) &#123;x=x*<span class="number">10</span>+c-<span class="string">&#x27;0&#x27;</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> Debug&#123;</span><br><span class="line">	Tp <span class="type">void</span> _debug(<span class="type">char</span>* f,Ty t)&#123;cerr&lt;&lt;f&lt;&lt;<span class="string">&#x27;=&#x27;</span>&lt;&lt;t&lt;&lt;endl;&#125;</span><br><span class="line">	Ts <span class="type">void</span> _debug(<span class="type">char</span>* f,Ty x,Ar... y)&#123;<span class="keyword">while</span>(*f!=<span class="string">&#x27;,&#x27;</span>) cerr&lt;&lt;*f++;cerr&lt;&lt;<span class="string">&#x27;=&#x27;</span>&lt;&lt;x&lt;&lt;<span class="string">&quot;,&quot;</span>;_debug(f+<span class="number">1</span>,y...);&#125;</span><br><span class="line">	Tp ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; os,vector&lt;Ty&gt;&amp; V)&#123;os&lt;&lt;<span class="string">&quot;[&quot;</span>;<span class="keyword">for</span>(<span class="keyword">auto</span>&amp; vv:V) os&lt;&lt;vv&lt;&lt;<span class="string">&quot;,&quot;</span>;os&lt;&lt;<span class="string">&quot;]&quot;</span>;<span class="keyword">return</span> os;&#125;</span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> gdb(...) _debug((char*)#__VA_ARGS__,__VA_ARGS__)</span></span><br><span class="line">&#125;<span class="keyword">using</span> <span class="keyword">namespace</span> Debug;</span><br><span class="line"><span class="type">int</span> n,m,K;</span><br><span class="line"><span class="type">int</span> fa[maxn];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">yyy</span>&#123;</span><br><span class="line">	<span class="type">int</span> x,y,z,c;</span><br><span class="line">&#125;e[maxn],a[maxn];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">cmp</span><span class="params">(yyy x,yyy y)</span> </span>&#123;<span class="keyword">return</span> x.z==y.z?x.c&lt;y.c:x.z&lt;y.z;&#125;</span><br><span class="line"><span class="type">int</span> Value,ans=<span class="number">1e9</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">getfa</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;<span class="keyword">return</span> x==fa[x]?x:fa[x]=<span class="built_in">getfa</span>(fa[x]);&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">Kruskal</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> i,sum=<span class="number">0</span>;Value=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) fa[i]=i;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=m;i++) </span><br><span class="line">		<span class="keyword">if</span> (e[i].c) a[i]=e[i];</span><br><span class="line">		<span class="keyword">else</span> a[i]=e[i],a[i].z+=val;</span><br><span class="line">	<span class="built_in">sort</span>(a+<span class="number">1</span>,a+<span class="number">1</span>+m,cmp);</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=m;i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">getfa</span>(a[i].x)^<span class="built_in">getfa</span>(a[i].y)) &#123;</span><br><span class="line">			fa[<span class="built_in">getfa</span>(a[i].x)]=<span class="built_in">getfa</span>(a[i].y);</span><br><span class="line">			Value+=a[i].z;</span><br><span class="line">			sum+=(a[i].c==<span class="number">0</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> i,x,y,z;</span><br><span class="line">	<span class="built_in">read</span>(n);<span class="built_in">read</span>(m);<span class="built_in">read</span>(K);</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=m;i++) &#123;</span><br><span class="line">		<span class="built_in">read</span>(e[i].x),<span class="built_in">read</span>(e[i].y),<span class="built_in">read</span>(e[i].z),<span class="built_in">read</span>(e[i].c);</span><br><span class="line">		e[i].x++,e[i].y++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> l=<span class="number">-101</span>,r=<span class="number">101</span>;</span><br><span class="line">	<span class="keyword">while</span> (l+<span class="number">1</span>&lt;r) &#123;</span><br><span class="line">		<span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">Kruskal</span>(mid)&gt;=K) l=mid,ans=Value-K*mid;<span class="comment">//因为不一定二分到恰好选 k 个的情况，所以记录答案</span></span><br><span class="line">		<span class="keyword">else</span> r=m</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是观察到白边和黑边各自内部中的相对顺序并不会改变。可以提前排序两部分，后归并。复杂度就是 $O(n\log n)$。</p>
<h3 id="2-最小度限制生成树"><a href="#2-最小度限制生成树" class="headerlink" title="2.  最小度限制生成树"></a>2.  最小度限制生成树</h3><p><a href="https://www.luogu.com.cn/problem/P5633">https://www.luogu.com.cn/problem/P5633</a></p>
<p>优先选择与 $s$ 相邻的点。</p>
<h3 id="3-CF125E-MST-Company"><a href="#3-CF125E-MST-Company" class="headerlink" title="3. CF125E MST Company"></a>3. CF125E MST Company</h3><p>双倍经验。</p>
<h3 id="4-CF802O-April-Fools’-Problem-hard"><a href="#4-CF802O-April-Fools’-Problem-hard" class="headerlink" title="4. CF802O April Fools’ Problem (hard)"></a>4. CF802O April Fools’ Problem (hard)</h3><p>先判断是否有凸性。</p>
<p>二分之后，考虑反悔贪心。有两种情况：</p>
<ul>
<li>从之前没配对 $a_x$ 中选一个，代价是 $b_i+a_x$。</li>
<li>从之前的已经组成的 $(a_x,b_y)$ 拆掉，代价是 $b_i-b_y$</li>
</ul>
<p>强制权值最大的同时选的最多。复杂度 $O(n\log^2 n)$。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 500005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mk make_pair</span></span><br><span class="line"><span class="type">int</span> n,K;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf=<span class="number">2e9</span>;</span><br><span class="line"><span class="type">int</span> a[maxn],b[maxn],c[maxn];</span><br><span class="line">priority_queue&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; &gt;q;</span><br><span class="line"><span class="type">int</span> Ans,sum,ans;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> i;Ans=<span class="number">0</span>,sum=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) q.<span class="built_in">pop</span>();</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) c[i]=b[i]-val;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		q.<span class="built_in">push</span>(<span class="built_in">mk</span>(-a[i],<span class="number">1</span>));</span><br><span class="line">		<span class="keyword">if</span> (-q.<span class="built_in">top</span>().fi+c[i]&lt;=<span class="number">0</span>) &#123;</span><br><span class="line">			sum+=q.<span class="built_in">top</span>().se;</span><br><span class="line">			Ans+=c[i]-q.<span class="built_in">top</span>().fi;</span><br><span class="line">			q.<span class="built_in">pop</span>();</span><br><span class="line">			q.<span class="built_in">push</span>(<span class="built_in">mk</span>(c[i],<span class="number">0</span>));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> sum&gt;=K;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="built_in">read</span>(n);<span class="built_in">read</span>(K);</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">read</span>(a[i]);</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">read</span>(b[i]);</span><br><span class="line">	<span class="type">int</span> l=-inf,r=inf,mid;</span><br><span class="line">	<span class="keyword">while</span> (l+<span class="number">1</span>&lt;r) &#123;</span><br><span class="line">		mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">check</span>(mid)) r=mid,ans=Ans+mid*K;</span><br><span class="line">		<span class="keyword">else</span> l=mid;</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-P4983-忘情"><a href="#5-P4983-忘情" class="headerlink" title="5. P4983 忘情"></a>5. P4983 忘情</h3><h3 id="6-IOI2000-邮局-加强版"><a href="#6-IOI2000-邮局-加强版" class="headerlink" title="6.  [IOI2000] 邮局 加强版"></a>6.  [IOI2000] 邮局 加强版</h3><p>判断时用决策单调性优化。</p>
<h3 id="7-P5308-COCI2018-2019-4-Akvizna"><a href="#7-P5308-COCI2018-2019-4-Akvizna" class="headerlink" title="7. P5308 [COCI2018-2019#4] Akvizna"></a>7. P5308 [COCI2018-2019#4] Akvizna</h3><p>同上。</p>
<h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>感觉这篇写的水了一点。但是要退役了，就当记录一下好了。</p>
<p>其实也不大会有人看。</p>
]]></content>
      <tags>
        <tag>决策单调性</tag>
        <tag>学习笔记</tag>
        <tag>wqs二分</tag>
      </tags>
  </entry>
  <entry>
    <title>为什么停更了</title>
    <url>/2023/02/03/%E4%B8%BA%E4%BB%80%E4%B9%88%E5%81%9C%E6%9B%B4%E4%BA%86/</url>
    <content><![CDATA[<p>为什么停更了这么久。</p>
<p>最直接的原因就是NOIP考太烂了，今年基本没机会冲省队了。</p>
<p>再一个原因就是懒。</p>
<p>人的惰性是大于一切的。</p>
<p>最近也没做什么题。比较有意思的应该算是奶牛站的和POI的。</p>
<p>新的一年，希望能够多和陌生人说说话，少一点发癫。</p>
<p>春季测试和省选马上就要来临，博客更新的频率可能变快，至少的吧欠的补下来。<strong>即使没有人看。</strong></p>
]]></content>
      <tags>
        <tag>杂记</tag>
      </tags>
  </entry>
  <entry>
    <title>二分图最小字典序</title>
    <url>/2022/06/29/%E4%BA%8C%E5%88%86%E5%9B%BE%E6%9C%80%E5%B0%8F%E5%AD%97%E5%85%B8%E5%BA%8F/</url>
    <content><![CDATA[<p>首先求出任意一个完美匹配。</p>
<p>考虑这样一个问题：对二分图 G，已知它的一个完美匹配 T（匹配中边的集合），如何判定是否存在包含给定边 $e$ 的完美匹配？</p>
<ul>
<li><p>如果 $e$ 属于 T，显然是存在的。</p>
</li>
<li><p>否则，存在包含 $e$ 的完美匹配，当且仅当，存在经过 $e$ 的依次经过匹配边、未匹配边的环。判断是否存在这样的环只需要 $dfs $ 一遍即可。复杂度 $O(n+m)$。如果存在，把环上的匹配边变成未匹配边，未匹配边变成匹配边就能得到一个包含 $e$ 的完美匹配。</p>
</li>
</ul>
<p>证明：</p>
<blockquote>
<p>充分性：把环上的所有匹配边变成未匹配边，未匹配边变成匹配边就得到了一个包含 e 的完美匹配。</p>
<p>必要性：假设存在包含 e 的完美匹配 T’，设 S 为 T 与 T’ 的对称差，考虑 S 中的边构成的子图 G’。由于 T 和 T’ 都是完美匹配，所以每个点度数要么是 0 要么是 2。因此 G’ 是若干个简单环组成的。显然 G’ 上相邻的两条边不可能都是 T 中的边，也不可能都是 T’ 中的边。考虑经过 e 的环，显然它是一个依次经过匹配边、未匹配边的环。</p>
</blockquote>
<p>用以上算法，可以找到从当前图上编号最小的点 $u$ 出发，在保证存在完美匹配的前提下，$u$ 能匹配的编号最小的点，设这个点为 $v$。</p>
<p>注意到，在这个过程中要判断的边 $e$ 的一个端点是固定的，也就是 $u$，所以无需把每个可能的 $v$ $O(n+m) $ 地判断一遍，只需要从 $u$ 出发做一次 $dfs $ 即可。判断的同时也得到了一个包含边 (u,v) 的完美匹配。把这条边删去就得到了一个删除点 $u$ 和 $v$ 后的图的完美匹配。对删除 $u$ 和 $v$ 后的图重复上述过程即可。</p>
<p>总复杂度 $O(n^2+nm)$.</p>
<h3 id="code"><a href="#code" class="headerlink" title="code"></a>code</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> y:to[x]) </span><br><span class="line">        <span class="keyword">if</span> (cnt!=v[y]) &#123;</span><br><span class="line">            v[y]=cnt;</span><br><span class="line">            <span class="keyword">if</span> (!match[y]||<span class="built_in">dfs</span>(match[y])) <span class="keyword">return</span> match[y]=x,match[x]=y,<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> top)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> y:to[x]) </span><br><span class="line">        <span class="keyword">if</span> (v[y]!=cnt) &#123;</span><br><span class="line">            v[y]=cnt;</span><br><span class="line">            <span class="keyword">if</span> (match[y]==top||(match[y]&gt;top&amp;&amp;<span class="built_in">dfs2</span>(match[y],top)&gt;=<span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> match[x]=y,match[y]=x,y;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后 $match_i$ 就是答案</p>
<p>参考<a href="https://www.zhihu.com/question/345016360">知乎 </a>。</p>
<h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><h4 id="NOI2009-变换序列"><a href="#NOI2009-变换序列" class="headerlink" title="NOI2009 变换序列"></a><a href="https://wgyhm.github.io/post/er-fen-tu-ji-lu-noi2009bian-huan-xu-lie/">NOI2009 变换序列</a></h4><p>考虑到每个点只向右边连两个，所以说直接倒着跑一遍匈牙利就好了，似乎用不上这个东西。</p>
]]></content>
      <tags>
        <tag>二分图</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>安装 Devc++</title>
    <url>/2022/08/18/%E5%AE%89%E8%A3%85-devc/</url>
    <content><![CDATA[<p>简单记录一下配置 devc++。可能是主要给初学的人看的。</p>
<h3 id="Step-1-安装-devc"><a href="#Step-1-安装-devc" class="headerlink" title="Step 1 安装 devc++"></a>Step 1 安装 devc++</h3><p>网上随便找一个版本高一点的就好了</p>
<h3 id="Step-2-修改-mingv64"><a href="#Step-2-修改-mingv64" class="headerlink" title="Step 2 修改 mingv64"></a>Step 2 修改 mingv64</h3><p>众所周知，devc++ 已经很久没有更新了。而 github 上的 <a href="https://github.com/Embarcadero/Dev-Cpp">Embarcadero Dev-Cpp</a> 个人认为不是很好用。为了更新 g++&#x2F;gcc 的版本。我们要下载新的编译器。</p>
<p>到 mingw 官网上下一个8.2.0 或者更新的。</p>
<p>如果不想找，<a href="https://pan.baidu.com/s/1YLT-sadM11zjA_tGvr9WKA">百度网盘link</a>，提取码 g2cj </p>
<p>替换 dev 中的 mingv 即可。</p>
<h3 id="Step-3-设置环境变量"><a href="#Step-3-设置环境变量" class="headerlink" title="Step 3 设置环境变量"></a>Step 3 设置环境变量</h3><p>找到 <code>include</code> 和 <code>lib</code> 文件夹加入系统变量，<code>bin</code> 文件夹加入 path。</p>
<p>保存后开 <code>cmd</code> ，输入 <code>g++ -v</code>  判断是否加入成功。</p>
]]></content>
      <tags>
        <tag>杂项</tag>
      </tags>
  </entry>
  <entry>
    <title>对顶栈学习笔</title>
    <url>/2023/10/05/%E5%AF%B9%E9%A1%B6%E6%A0%88%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="对顶栈学习笔记"><a href="#对顶栈学习笔记" class="headerlink" title="对顶栈学习笔记"></a>对顶栈学习笔记</h1><p>对顶栈。</p>
<p>算法流程如下：</p>
<ul>
<li>以一个点为中心，维护前后缀的最大最小值。</li>
<li>如果加减前后首位且区间包含中心点，$O(1)$ 维护前后缀。</li>
<li>如果不包含中心点，暴力重构，取当前区间的中点作为中心点。</li>
</ul>
<p>考虑分析复杂度，如果一个长度为 $n$ 的序列被重构了，则至少操作了 $n&#x2F;2$ 次。所以复杂度是 $O(n)$，其中  $n$ 为操作次数。</p>
<p>对顶栈感觉可以适用于这种双指针强行让你 $O(n)$ 的题目中。如果预处理或者查询有一个可以做到 $O(n\log n)$ 或者以上，就没有使用的必要了，感觉不如 ST 表。</p>
<h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><p>JOI Open 2018 T1 Bubble Sort 2 QOJ 2643</p>
<p>翻译一下，就是让你 $O(n)$ 求一个序列中，满足：<br>$$<br>\min\limits_{i&#x3D;l}^r a_i+\max\limits_{i&#x3D;l}^r a_i&gt;r-l+1<br>$$<br>的最长区间长度。</p>
<p>考虑一个满足要求的区间 $[l,r]$，随便减去不是最大值的端点，则左式不减，右式减小。一定满足。</p>
<p>考虑一种双指针，枚举右端点 $r$，令当前的最大值为 $ans$，则 $l$ 从 $r-ans+1$ 开始向左枚举，判断合法性。</p>
<p>先不考虑判断合法性的复杂度。先考虑正确性。如果枚举到答案区间的最大值，则左端点根据单调性一定会移动答案区间的左端点。</p>
<p>然后来看端点的移动次数，每次为了保证区间的长度大于等于最大值，每次移动右端点时，左端点最多往右移动一格。左端点最多只能向左移动 $O(2n)$ 次，所以移动次数为 $O(n)$ 的。</p>
<p>现在的复杂度瓶颈在于判断区间的合法性。也就是要动态求出区间的最大值和最小值。</p>
<p>学习了对顶栈以后，可以很自然的套用上去。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 1000005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> put() putchar(<span class="string">&#x27;\n&#x27;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Tp template<span class="string">&lt;typename Ty&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Ts template<span class="string">&lt;typename Ty,typename... Ar&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">(<span class="type">int</span> &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> f=<span class="number">1</span>;x=<span class="number">0</span>;<span class="type">char</span> c=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (c&lt;<span class="string">&#x27;0&#x27;</span>||c&gt;<span class="string">&#x27;9&#x27;</span>) &#123;<span class="keyword">if</span> (c==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">-1</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span> (c&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;c&lt;=<span class="string">&#x27;9&#x27;</span>) &#123;x=x*<span class="number">10</span>+c-<span class="string">&#x27;0&#x27;</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> Debug&#123;</span><br><span class="line">	Tp <span class="type">void</span> _debug(<span class="type">char</span>* f,Ty t)&#123;cerr&lt;&lt;f&lt;&lt;<span class="string">&#x27;=&#x27;</span>&lt;&lt;t&lt;&lt;endl;&#125;</span><br><span class="line">	Ts <span class="type">void</span> _debug(<span class="type">char</span>* f,Ty x,Ar... y)&#123;<span class="keyword">while</span>(*f!=<span class="string">&#x27;,&#x27;</span>) cerr&lt;&lt;*f++;cerr&lt;&lt;<span class="string">&#x27;=&#x27;</span>&lt;&lt;x&lt;&lt;<span class="string">&quot;,&quot;</span>;_debug(f+<span class="number">1</span>,y...);&#125;</span><br><span class="line">	Tp ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; os,vector&lt;Ty&gt;&amp; V)&#123;os&lt;&lt;<span class="string">&quot;[&quot;</span>;<span class="keyword">for</span>(<span class="keyword">auto</span>&amp; vv:V) os&lt;&lt;vv&lt;&lt;<span class="string">&quot;,&quot;</span>;os&lt;&lt;<span class="string">&quot;]&quot;</span>;<span class="keyword">return</span> os;&#125;</span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> gdb(...) _debug((char*)#__VA_ARGS__,__VA_ARGS__)</span></span><br><span class="line">&#125;<span class="keyword">using</span> <span class="keyword">namespace</span> Debug;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mk make_pair</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">power</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y=mod<span class="number">-2</span>)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> sum=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (y) &#123;</span><br><span class="line">		<span class="keyword">if</span> (y&amp;<span class="number">1</span>) sum=sum*x%mod;</span><br><span class="line">		x=x*x%mod;y&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,m,a[maxn];</span><br><span class="line"><span class="type">int</span> L,mid,R,sl[maxn],sr[maxn],ml[maxn],mr[maxn];<span class="comment">//min,max</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> L,<span class="type">int</span> R)</span> </span>&#123;</span><br><span class="line">	mid=L+R&gt;&gt;<span class="number">1</span>;<span class="type">int</span> i;</span><br><span class="line">	<span class="keyword">for</span> (sl[mid]=ml[mid]=a[mid],i=mid<span class="number">-1</span>;i&gt;=L;i--) sl[i]=<span class="built_in">min</span>(sl[i+<span class="number">1</span>],a[i]),ml[i]=<span class="built_in">max</span>(ml[i+<span class="number">1</span>],a[i]);</span><br><span class="line">	<span class="keyword">for</span> (sr[mid+<span class="number">1</span>]=mr[mid+<span class="number">1</span>]=a[mid+<span class="number">1</span>],i=mid+<span class="number">2</span>;i&lt;=R;i++) sr[i]=<span class="built_in">min</span>(sr[i<span class="number">-1</span>],a[i]),mr[i]=<span class="built_in">max</span>(mr[i<span class="number">-1</span>],a[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (l==r) <span class="keyword">return</span> <span class="number">2</span>*a[l];</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">max</span>(mr[r],ml[l])+<span class="built_in">min</span>(sr[r],sl[l]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> i,ans=<span class="number">0</span>,l=<span class="number">1</span>,r;mid=<span class="number">1</span>;sl[l]=ml[l]=a[l];</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;=n;i++) sl[i]=sr[i]=ml[i]=mr[i]=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (r=<span class="number">1</span>;r&lt;=n;r++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (r&gt;mid+<span class="number">1</span>) sr[r]=<span class="built_in">min</span>(sr[r<span class="number">-1</span>],a[r]);<span class="keyword">else</span> sr[r]=a[r];</span><br><span class="line">		<span class="keyword">if</span> (r&gt;mid+<span class="number">1</span>) mr[r]=<span class="built_in">max</span>(mr[r<span class="number">-1</span>],a[r]);<span class="keyword">else</span> mr[r]=a[r];</span><br><span class="line">		<span class="keyword">if</span> (mid&lt;l||mid&gt;=r) <span class="built_in">build</span>(l,r);</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">query</span>(l,r)&lt;=r-l+<span class="number">1</span>) l++;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			sl[l<span class="number">-1</span>]=<span class="built_in">min</span>(sl[l],a[l<span class="number">-1</span>]);</span><br><span class="line">			ml[l<span class="number">-1</span>]=<span class="built_in">max</span>(ml[l],a[l<span class="number">-1</span>]);</span><br><span class="line">			<span class="keyword">while</span> (l&gt;=<span class="number">2</span>&amp;&amp;<span class="built_in">query</span>(l<span class="number">-1</span>,r)&gt;r-l+<span class="number">2</span>) &#123;</span><br><span class="line">				l--;</span><br><span class="line">				sl[l<span class="number">-1</span>]=<span class="built_in">min</span>(sl[l],a[l<span class="number">-1</span>]);</span><br><span class="line">				ml[l<span class="number">-1</span>]=<span class="built_in">max</span>(ml[l],a[l<span class="number">-1</span>]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		ans=<span class="built_in">max</span>(ans,r-l+<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> i,x,y;</span><br><span class="line">	<span class="built_in">read</span>(n);<span class="built_in">read</span>(m);</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">read</span>(a[i]);</span><br><span class="line">	<span class="built_in">solve</span>();</span><br><span class="line">	<span class="keyword">while</span> (m--) &#123;</span><br><span class="line">		<span class="built_in">read</span>(i);</span><br><span class="line">		<span class="keyword">while</span> (i--) <span class="built_in">read</span>(x),<span class="built_in">read</span>(y),<span class="built_in">swap</span>(a[x],a[y]);</span><br><span class="line">		<span class="built_in">solve</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>对顶栈</tag>
        <tag>学习笔记</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>忏悔录</title>
    <url>/2022/10/11/%E5%BF%8F%E6%82%94%E5%BD%95/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>扩展欧拉定理</title>
    <url>/2022/09/03/%E6%89%A9%E5%B1%95%E6%AC%A7%E6%8B%89%E5%AE%9A%E7%90%86/</url>
    <content><![CDATA[<h3 id="费马小定理"><a href="#费马小定理" class="headerlink" title="费马小定理"></a>费马小定理</h3><p>对于素数 $p$，$(a,p)$ 互质，有<br>$$<br>a^{p-1}\equiv1\pmod p<br>$$</p>
<h3 id="欧拉定理"><a href="#欧拉定理" class="headerlink" title="欧拉定理"></a>欧拉定理</h3><p>对于 $(a,m)&#x3D;1$ ，有<br>$$<br>a^{\varphi(m)} \equiv 1\pmod m<br>$$</p>
<h3 id="扩展欧拉定理"><a href="#扩展欧拉定理" class="headerlink" title="扩展欧拉定理"></a>扩展欧拉定理</h3><p>不用考虑 $a,m$ 是否互质<br>$$<br>a^b&#x3D;\begin{cases}a^b&amp;b&lt;\varphi(m) \a^{b \bmod \varphi(m)+\varphi(m)}&amp;  b\ge \varphi(m)\end{cases}<br>$$</p>
]]></content>
      <tags>
        <tag>学习笔记</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>插入Dp</title>
    <url>/2022/09/22/%E6%8F%92%E5%85%A5dp/</url>
    <content><![CDATA[<p>一种 dp trick</p>
<p>常常在算贡献时，与排列相邻两个数的相对大小有关。这时候我们将排列从小到大插入，状态为有几个连着的“块”。分新建块，插入块头快尾，合并块。</p>
<p>常常要讨论转移的合法性。</p>
<h4 id="CEOI2016-kangaroo"><a href="#CEOI2016-kangaroo" class="headerlink" title="[CEOI2016] kangaroo"></a>[CEOI2016] kangaroo</h4><p>令 $f[i][j]$ 表示已经插入前 $i$ 个数，共有 $j$ 个块。</p>
<p>先不考虑头尾的限制。</p>
<ul>
<li>新建块，可以建在 $j$ 个空隙中，$f[i][j]+&#x3D;f[i-1][j-1]\times j$。如果头尾已经填了，那么最头上和最后面都不能新建。</li>
<li>合并块，从 $f[i][j+1]$ 转移过来，有 $j$ 个可以合并的空隙。$f[i][j]+&#x3D;f[i-1][j+1]*j$</li>
</ul>
<p>头尾特判。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 2005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> put() putchar(<span class="string">&#x27;\n&#x27;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Tp template<span class="string">&lt;typename Ty&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Ts template<span class="string">&lt;typename Ty,typename... Ar&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(<span class="type">int</span> &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> f=<span class="number">1</span>;x=<span class="number">0</span>;<span class="type">char</span> c=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (c&lt;<span class="string">&#x27;0&#x27;</span>||c&gt;<span class="string">&#x27;9&#x27;</span>) &#123;<span class="keyword">if</span> (c==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">-1</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span> (c&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;c&lt;=<span class="string">&#x27;9&#x27;</span>) &#123;x=x*<span class="number">10</span>+c-<span class="string">&#x27;0&#x27;</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> Debug&#123;</span><br><span class="line">	Tp <span class="type">void</span> _debug(<span class="type">char</span>* f,Ty t)&#123;cerr&lt;&lt;f&lt;&lt;<span class="string">&#x27;=&#x27;</span>&lt;&lt;t&lt;&lt;endl;&#125;</span><br><span class="line">	Ts <span class="type">void</span> _debug(<span class="type">char</span>* f,Ty x,Ar... y)&#123;<span class="keyword">while</span>(*f!=<span class="string">&#x27;,&#x27;</span>) cerr&lt;&lt;*f++;cerr&lt;&lt;<span class="string">&#x27;=&#x27;</span>&lt;&lt;x&lt;&lt;<span class="string">&quot;,&quot;</span>;_debug(f+<span class="number">1</span>,y...);&#125;</span><br><span class="line">	Tp ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; os,vector&lt;Ty&gt;&amp; V)&#123;os&lt;&lt;<span class="string">&quot;[&quot;</span>;<span class="keyword">for</span>(<span class="keyword">auto</span>&amp; vv:V) os&lt;&lt;vv&lt;&lt;<span class="string">&quot;,&quot;</span>;os&lt;&lt;<span class="string">&quot;]&quot;</span>;<span class="keyword">return</span> os;&#125;</span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> gdb(...) _debug(#__VA_ARGS__,__VA_ARGS__)</span></span><br><span class="line">&#125;<span class="keyword">using</span> <span class="keyword">namespace</span> Debug;</span><br><span class="line"><span class="type">int</span> f[maxn][maxn];</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> i,j,n,s,t;</span><br><span class="line">	<span class="built_in">read</span>(n);<span class="built_in">read</span>(s);<span class="built_in">read</span>(t);</span><br><span class="line">	f[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (j=<span class="number">1</span>;j&lt;=i;j++)&#123;</span><br><span class="line">			<span class="keyword">if</span> (i==s||i==t) f[i][j]=(f[i<span class="number">-1</span>][j]+f[i<span class="number">-1</span>][j<span class="number">-1</span>])%mod;</span><br><span class="line">			<span class="keyword">else</span> f[i][j]=((j-(i&gt;s)-(i&gt;t))*f[i<span class="number">-1</span>][j<span class="number">-1</span>]+j*f[i<span class="number">-1</span>][j+<span class="number">1</span>])%mod;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,f[n][<span class="number">1</span>]);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="CF704B-Ant-Man"><a href="#CF704B-Ant-Man" class="headerlink" title="CF704B Ant Man"></a>CF704B Ant Man</h4><p>首先将 $a+&#x3D;x,b-&#x3D;x,c+&#x3D;x,d-&#x3D;x$</p>
<p>分三种情况：新建、插入、合并情况讨论。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 5005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> put() putchar(<span class="string">&#x27;\n&#x27;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Tp template<span class="string">&lt;typename Ty&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Ts template<span class="string">&lt;typename Ty,typename... Ar&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(<span class="type">int</span> &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> f=<span class="number">1</span>;x=<span class="number">0</span>;<span class="type">char</span> c=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (c&lt;<span class="string">&#x27;0&#x27;</span>||c&gt;<span class="string">&#x27;9&#x27;</span>) &#123;<span class="keyword">if</span> (c==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">-1</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span> (c&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;c&lt;=<span class="string">&#x27;9&#x27;</span>) &#123;x=x*<span class="number">10</span>+c-<span class="string">&#x27;0&#x27;</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> Debug&#123;</span><br><span class="line">	Tp <span class="type">void</span> _debug(<span class="type">char</span>* f,Ty t)&#123;cerr&lt;&lt;f&lt;&lt;<span class="string">&#x27;=&#x27;</span>&lt;&lt;t&lt;&lt;endl;&#125;</span><br><span class="line">	Ts <span class="type">void</span> _debug(<span class="type">char</span>* f,Ty x,Ar... y)&#123;<span class="keyword">while</span>(*f!=<span class="string">&#x27;,&#x27;</span>) cerr&lt;&lt;*f++;cerr&lt;&lt;<span class="string">&#x27;=&#x27;</span>&lt;&lt;x&lt;&lt;<span class="string">&quot;,&quot;</span>;_debug(f+<span class="number">1</span>,y...);&#125;</span><br><span class="line">	Tp ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; os,vector&lt;Ty&gt;&amp; V)&#123;os&lt;&lt;<span class="string">&quot;[&quot;</span>;<span class="keyword">for</span>(<span class="keyword">auto</span>&amp; vv:V) os&lt;&lt;vv&lt;&lt;<span class="string">&quot;,&quot;</span>;os&lt;&lt;<span class="string">&quot;]&quot;</span>;<span class="keyword">return</span> os;&#125;</span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> gdb(...) _debug(#__VA_ARGS__,__VA_ARGS__)</span></span><br><span class="line">&#125;<span class="keyword">using</span> <span class="keyword">namespace</span> Debug;</span><br><span class="line"><span class="type">int</span> a[maxn],b[maxn],c[maxn],d[maxn];</span><br><span class="line"><span class="type">int</span> f[maxn][maxn],s,t,n,e[maxn]; </span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> i,j,x;</span><br><span class="line">	<span class="built_in">memset</span>(f,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(f));</span><br><span class="line">	<span class="built_in">read</span>(n);<span class="built_in">read</span>(s);<span class="built_in">read</span>(t);</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">read</span>(e[i]);</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">read</span>(a[i]);</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">read</span>(b[i]);</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">read</span>(c[i]);</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">read</span>(d[i]);</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		x=e[i];</span><br><span class="line">		c[i]+=x;b[i]-=x;a[i]+=x;d[i]-=x;</span><br><span class="line">	&#125;</span><br><span class="line">	f[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (j=<span class="number">1</span>;<span class="built_in">j</span>&lt;=i;j++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (i==s) &#123;</span><br><span class="line">				<span class="keyword">if</span> (j&gt;(i&gt;s)) f[i][j]=<span class="built_in">min</span>(f[i][j],f[i<span class="number">-1</span>][j<span class="number">-1</span>]+d[i]);</span><br><span class="line">				f[i][j]=<span class="built_in">min</span>(f[i][j],f[i<span class="number">-1</span>][j]+c[i]);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (i==t) &#123;</span><br><span class="line">				<span class="keyword">if</span> (j&gt;(i&gt;t)) f[i][j]=<span class="built_in">min</span>(f[i][j],f[i<span class="number">-1</span>][j<span class="number">-1</span>]+b[i]);</span><br><span class="line">				f[i][j]=<span class="built_in">min</span>(f[i][j],f[i<span class="number">-1</span>][j]+a[i]);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">if</span> (j&gt;(i&gt;t)+(i&gt;s)) f[i][j]=<span class="built_in">min</span>(f[i][j],f[i<span class="number">-1</span>][j<span class="number">-1</span>]+b[i]+d[i]);<span class="comment">//记得判断</span></span><br><span class="line">				<span class="keyword">if</span> (j&gt;(i&gt;t)) f[i][j]=<span class="built_in">min</span>(f[i][j],f[i<span class="number">-1</span>][j]+a[i]+d[i]);</span><br><span class="line">				<span class="keyword">if</span> (j&gt;(i&gt;s)) f[i][j]=<span class="built_in">min</span>(f[i][j],f[i<span class="number">-1</span>][j]+b[i]+c[i]);</span><br><span class="line">				f[i][j]=<span class="built_in">min</span>(f[i][j],f[i<span class="number">-1</span>][j+<span class="number">1</span>]+a[i]+c[i]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">//	gdb(f[1][1],f[2][1]);</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,f[n][<span class="number">1</span>]);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="CF1515E-Phoenix-and-Computers"><a href="#CF1515E-Phoenix-and-Computers" class="headerlink" title="CF1515E Phoenix and Computers"></a>CF1515E Phoenix and Computers</h4><p>有插入 dp 的 $O(n^2)$ 做法。</p>
]]></content>
      <tags>
        <tag>dp</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>斜率优化学习笔记</title>
    <url>/2022/11/14/%E6%96%9C%E7%8E%87%E4%BC%98%E5%8C%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="斜率优化学习笔记"><a href="#斜率优化学习笔记" class="headerlink" title="斜率优化学习笔记"></a>斜率优化学习笔记</h2><h3 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h3><p>很早以前写的了，看着当时写的很认真，所以发到自己的博客上去。</p>
<h3 id="〇、前言"><a href="#〇、前言" class="headerlink" title="〇、前言"></a>〇、前言</h3><p>本来最近一段时间是想搞网络流的。结果最近几天老师要讲斜率优化，加上之前想学但是没看懂，就有了这篇学习笔记。</p>
<p>感谢 <a href="https://www.cnblogs.com/terribleterrible/p/9669614.html">这篇博客 </a>让我看懂了斜率优化。</p>
<h3 id="一、基本概念"><a href="#一、基本概念" class="headerlink" title="一、基本概念"></a>一、基本概念</h3><p>目前我所了解的，斜率优化是用来优化 $dp$，形如：<br>$$<br>f_i&#x3D;\min &#x2F; \max{f_j+A_i\times B_j+C_j+D_i}<br>$$<br>看起来与单调队列的：<br>$$<br>f_i&#x3D;\min&#x2F;\max{f_j+A_i+B_j}<br>$$<br>有点类似，因为斜率优化正是利用单调队列来实现的。</p>
<p>不过这不重要。重要的是理解思想。</p>
<h3 id="二、算法介绍"><a href="#二、算法介绍" class="headerlink" title="二、算法介绍"></a>二、算法介绍</h3><p>首先看一道经典例题：</p>
<h4 id="P3195-HNOI2008-玩具装箱"><a href="#P3195-HNOI2008-玩具装箱" class="headerlink" title="P3195 [HNOI2008]玩具装箱"></a><a href="https://www.luogu.com.cn/problem/P3195">P3195 [HNOI2008]玩具装箱</a></h4><p>设 $f_i$ 为以 $i$ 结尾的最小总费用。不难想到 $n^2$ 的 $dp$ 转移方程，如果想不到的话建议巩固 $dp$ 基础：<br>$$<br>f_i&#x3D;\min\limits_{0\le j&lt;i}{f_j+(sum_i+i-sum_j-j-L-1)^2}<br>$$<br>将与 $i$ 相关的放在一起，与 $j$ 相关和常数项的放在一起。事实上，常数项也可以和 $i$ 相关的放在一起。</p>
<p>令 $A&#x3D;sum_i+i,B&#x3D;sum_j+j+L+1$，则原式化简为：<br>$$<br>f_i&#x3D;\min\limits_{0\le j&lt;i}{f_j+(A-B)^2}&#x3D;\min\limits_{0\le j&lt;i}{f_j+A^2-2AB+B^2}<br>$$<br>为了方便，把 $\min$ 去了，然后把与只 $j$ 相关的项扔到等式右边，其他在左边：<br>$$<br>2A\times B+f_i-A^2&#x3D;f_j+B^2<br>$$</p>
<p>$$<br>\begin{matrix}\underbrace{2A}\k\end{matrix}\times \begin{matrix}\underbrace{B}\x\end{matrix}+\begin{matrix}\underbrace{f_i-A^2}\b\end{matrix}&#x3D;\begin{matrix}\underbrace{f_j+B^2}\y\end{matrix}<br>$$</p>
<p><strong>问题转化成了：我们可以将经过许多点 $P_j(B_j,f_j+B_j^2)$  ，斜率为 $2A$ 的直线，所得的最小截距$(f_i-A^2)$的点为最佳转移点。</strong></p>
<p>如何求这最佳转移点呢，还是要对于每次转移，$O(n)$ 的时间扫一遍吗？</p>
<p>我们先看一个问题，如下图，对于经过两个点 $N(a_1,b_1),M(a_2,b_2)$ ，$a_1&lt;a_2$，斜率都为 $k$ 的直线，什么时候经过 $N$ 的截距小呢？什么时候经过 $M$ 点的截距小呢？</p>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/m9o01eif.png"></p>
<p>考虑先写出直线方程 ：</p>
<p>对于 $N$点 ，$y-b_1&#x3D;k(x-a_1)$ ，化简得 截距$B_1&#x3D;b_1-k\cdot a_1$</p>
<p>对于 $M$点，$y-b_2&#x3D;k(x-a_2)$ ，化简得 截距$B_2&#x3D;b_2-k\cdot a_2$</p>
<p>如果 $N$ 点截距小，则 $B_1&lt;B_2$ 解得 $k&lt;\dfrac{b_1-b_2}{a_1-a_2}$</p>
<p>如果 $M$ 点截距小，则 $B_1&gt;B_2$ 解得 $k&gt;\dfrac{b_1-b_2}{a_1-a_2}$</p>
<p>回到原题，我们发现 $A&#x3D;sum_i+i$ 是单调递增的。也就是说，斜率 $k$ 随着转移点 $i$ 的增大而增大。</p>
<p><strong>对于斜率 $k$ 不单调递增的情况下，我们后文会接着讨论。</strong></p>
<p>对于两个点 $P_j(a_j,b_j)$ 和 $P_k(a_k,b_k)$ ，$a_j&lt;a_k$ ，如果此时 $k&lt;\dfrac{b_j-b_k}{a_j-a_k}$ ，那么转移 $j$ 点，反之转移 $k$ 点，而且之后再也不会转移到 $j$ 点。类似一个弹出操作。你可能会想到用一个数据结构维护这个弹出操作，是什么呢？</p>
<p>正是我们前文讲到的单调队列！</p>
<p>巧的是，每个转换而来的点  $P_j(B_j,f_j+B_j^2)$ ，其中 $B_j$ 也都是递增的，这表明着可以将点 $P_j$ 插入队尾而不需要插入中间的某一位置。</p>
<p><strong>对于 $B_j$ 不单调递增的情况下，我们后文会接着讨论。而且现在我也没有遇到过。</strong> </p>
<p>现在，已经转移好了 $i$ 点，可是如何将 $i$ 点从队尾加入了这单调队列，转移其他的点呢？</p>
<p>如下图，假设我们现在又有三个点，分别是 $P_1(a_1,b_1),P_2(a_2,b_2)$ 和我们将要加入的点 $P_3(a_3,b_3)$，其中 $a_1&lt;a_2&lt;a_3$。</p>
<p>为了方便叙述，我们定义 $k_1&#x3D;\dfrac{b_1-b_2}{a_1-a_2},k_2&#x3D;\dfrac{b_2-b_3}{a_2-a_3},k_3&#x3D;\dfrac{b_1-b_3}{a_1-a_3}$。</p>
<ol>
<li>对于 $k_1&lt;k_2$ 的情况</li>
</ol>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/6t8liw1z.png"><br>对于斜率 $k$：</p>
<ul>
<li><p>如果使 $P_1$ 截距最小，$k&lt;k_1$</p>
</li>
<li><p>如果使 $P_2$ 截距最小，$k_1\le k&lt;k_2$</p>
</li>
<li><p>如果使 $P_3$ 截距最小，$k2\le k$</p>
</li>
</ul>
<ol start="2">
<li>对于 $k_1&gt;k_2$ 的情况</li>
</ol>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/akwunqko.png"></p>
<p>对于斜率 $k$：</p>
<ul>
<li><p>如果使 $P_1$ 截距最小，$k&lt;k_3$</p>
</li>
<li><p>如果使 $P_2$ 截距最小，无解，所以无论如何，最小截距也就是最优转移点，<strong>一定</strong>不是 $P_2$。</p>
</li>
<li><p>如果使 $P_3$ 截距最小，$k3\le k$</p>
</li>
</ul>
<p><strong>所以，我们要在单调队列中维护斜率严格递增的一个点集，具体的，维护一个下凸包。这是取 $\min$ 的情况。相同的，取 $\max$ 就得维护一个上凸包。</strong></p>
<p>回顾一下整个流程：</p>
<ol>
<li>如果队列前两个点的斜率小于 $k$，则踢出队首。</li>
<li>取队首作为转移点。</li>
<li>将转移点 $i$ 入队之前，维护一个斜率递增的单调队列。如果下降，则弹出队尾。</li>
</ol>
<p>代码就很简单了。</p>
<p>Code:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 100005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rg register</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> put() putchar(<span class="string">&#x27;\n&#x27;</span>)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(<span class="type">int</span> &amp;x)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> f=<span class="number">1</span>;x=<span class="number">0</span>;<span class="type">char</span> c=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span> (c&lt;<span class="string">&#x27;0&#x27;</span>||c&gt;<span class="string">&#x27;9&#x27;</span>) &#123;<span class="keyword">if</span> (c==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">-1</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">while</span> (c&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;c&lt;=<span class="string">&#x27;9&#x27;</span>) &#123;x=x*<span class="number">10</span>+c-<span class="string">&#x27;0&#x27;</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,l,head,tail,q[maxn];</span><br><span class="line"><span class="type">int</span> sum[maxn],A[maxn],B[maxn],a[maxn],f[maxn];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">double</span> <span class="title">X</span><span class="params">(<span class="type">int</span> i)</span></span>&#123;<span class="keyword">return</span> B[i];&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">double</span> <span class="title">Y</span><span class="params">(<span class="type">int</span> i)</span></span>&#123;<span class="keyword">return</span> f[i]+B[i]*B[i];&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">double</span> <span class="title">slope</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> j)</span></span>&#123;<span class="keyword">return</span> (<span class="built_in">Y</span>(i)-<span class="built_in">Y</span>(j))/(<span class="built_in">X</span>(i)-<span class="built_in">X</span>(j));&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//	freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);</span></span><br><span class="line">    rg <span class="type">int</span> i;</span><br><span class="line">    <span class="built_in">read</span>(n);<span class="built_in">read</span>(l);</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">read</span>(a[i]),sum[i]=sum[i<span class="number">-1</span>]+a[i];</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;=n;i++) A[i]=sum[i]+i,B[i]=sum[i]+i+l+<span class="number">1</span>;</span><br><span class="line">    head=tail=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">    	<span class="keyword">while</span> (head&lt;tail&amp;&amp;<span class="number">2</span>*A[i]&gt;=<span class="built_in">slope</span>(q[head],q[head+<span class="number">1</span>])) head++;</span><br><span class="line">        <span class="comment">//弹出队首</span></span><br><span class="line">    	f[i]=f[q[head]]+A[i]*A[i]<span class="number">-2</span>*A[i]*B[q[head]]+B[q[head]]*B[q[head]];</span><br><span class="line">        <span class="comment">//Update</span></span><br><span class="line">    	<span class="keyword">while</span> (head&lt;tail&amp;&amp;<span class="built_in">slope</span>(q[tail<span class="number">-1</span>],q[tail])&gt;=<span class="built_in">slope</span>(q[tail],i)) tail--;</span><br><span class="line">        <span class="comment">//维护上凸包</span></span><br><span class="line">    	q[++tail]=i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,f[n]);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="三、例题讲解"><a href="#三、例题讲解" class="headerlink" title="三、例题讲解"></a>三、例题讲解</h3><h4 id="P2365-任务安排"><a href="#P2365-任务安排" class="headerlink" title="P2365 任务安排"></a><a href="https://www.luogu.com.cn/problem/P2365">P2365 任务安排</a></h4><p>虽然可以用 $O(n^2)$ 草过去，但是为了巩固斜率优化还是推荐大家再写一遍。</p>
<p>容易想到 $n^2 dp:$<br>$$<br>f_i&#x3D;\min\limits_{0\le j&lt;i}{f_j+s\times(sumC_n-sumC_j)+sumT_i\times(sumC_i-sumC_j)}<br>$$<br>看到有 $i$ 和 $j$ 的乘积，考虑斜率优化：</p>
<p>$$<br>f_i&#x3D;{f_j+s\times sumC_n-s\times sumC_j+sumT_i\times sumC_i-sumT_i\times sumC_j)}<br>$$<br>与 $j$ 有关的扔到右边：</p>
<p>$$<br>\begin{matrix}\underbrace{sumT_i+s}\k\end{matrix}\times \begin{matrix}\underbrace{sumC_j}\x\end{matrix}+\begin{matrix}\underbrace{f_i-sumT_i\times sumC_i}\b\end{matrix}&#x3D;\begin{matrix}\underbrace{f_j+s\times sumC_n}\y\end{matrix}<br>$$<br>经过猜想+测试，以下整理也是可以的：</p>
<p>$$<br>\begin{matrix}\underbrace{sumT_i}\k\end{matrix}\times \begin{matrix}\underbrace{sumC_j}\x\end{matrix}+\begin{matrix}\underbrace{f_i-sumT_i\times sumC_i}\b\end{matrix}&#x3D;\begin{matrix}\underbrace{f_j+s\times sumC_n-s\times sumC_j}\y\end{matrix}<br>$$<br><strong>换言之，我们只需要把 $i,j$ 相关的相乘的项作为斜率 $k$ 。</strong></p>
<p>Code:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 100005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rg register</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> put() putchar(<span class="string">&#x27;\n&#x27;</span>)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(<span class="type">int</span> &amp;x)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> f=<span class="number">1</span>;x=<span class="number">0</span>;<span class="type">char</span> c=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span> (c&lt;<span class="string">&#x27;0&#x27;</span>||c&gt;<span class="string">&#x27;9&#x27;</span>) &#123;<span class="keyword">if</span> (c==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">-1</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">while</span> (c&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;c&lt;=<span class="string">&#x27;9&#x27;</span>) &#123;x=x*<span class="number">10</span>+c-<span class="string">&#x27;0&#x27;</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,head=<span class="number">1</span>,tail=<span class="number">1</span>,q[maxn];</span><br><span class="line"><span class="type">int</span> f[maxn],s,sumT[maxn],sumC[maxn],A[maxn],B[maxn];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">double</span> <span class="title">X</span><span class="params">(<span class="type">int</span> i)</span></span>&#123;<span class="keyword">return</span> sumC[i];&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">double</span> <span class="title">Y</span><span class="params">(<span class="type">int</span> i)</span></span>&#123;<span class="keyword">return</span> f[i]+s*(sumC[n]-sumC[i]);&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">double</span> <span class="title">slope</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> j)</span></span>&#123;<span class="keyword">return</span> (<span class="built_in">Y</span>(i)-<span class="built_in">Y</span>(j))/(<span class="built_in">X</span>(i)-<span class="built_in">X</span>(j));&#125;<span class="comment">//字面意思</span></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	rg <span class="type">int</span> i,x,y;</span><br><span class="line">	<span class="built_in">read</span>(n);<span class="built_in">read</span>(s);</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		<span class="built_in">read</span>(x);<span class="built_in">read</span>(y);</span><br><span class="line">		sumT[i]=sumT[i<span class="number">-1</span>]+x;</span><br><span class="line">		sumC[i]=sumC[i<span class="number">-1</span>]+y;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">    	<span class="keyword">while</span> (head&lt;tail&amp;&amp;sumT[i]+s&gt;=<span class="built_in">slope</span>(q[head],q[head+<span class="number">1</span>])) head++;</span><br><span class="line">        <span class="comment">//将斜率&lt;=k的弹出队列</span></span><br><span class="line">    	f[i]=f[q[head]]+s*(sumC[n]-sumC[q[head]])+sumT[i]*sumC[i]-sumT[i]*sumC[q[head]];</span><br><span class="line">        <span class="comment">//Update</span></span><br><span class="line">    	<span class="keyword">while</span> (head&lt;tail&amp;&amp;<span class="built_in">slope</span>(q[tail<span class="number">-1</span>],q[tail])&gt;=<span class="built_in">slope</span>(q[tail],i)) tail--;</span><br><span class="line">        <span class="comment">//维护上凸包</span></span><br><span class="line">    	q[++tail]=i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,f[n]);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>咕咕咕</p>
]]></content>
      <tags>
        <tag>dp</tag>
        <tag>学习笔记</tag>
        <tag>斜率优化</tag>
      </tags>
  </entry>
  <entry>
    <title>树同构学习笔记</title>
    <url>/2023/02/03/%E6%A0%91%E5%90%8C%E6%9E%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>为什么想到这个算法。之前打ICPC的时候，有一道判两个树是不是同构的问题。由于 fls 把哈希方法背错了。还好 zj 最后乱搞了一个哈希搞过去了。不然卡不到AU线了。</p>
<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>对于一棵树，不妨考虑有根的情况。令一个点及其子树的哈希值为 $h_x$。其计算方式为：<br>$$<br>h_x&#x3D;\sum_{y\in son_x} h_y*size_y<br>$$<br>只会把两个不同构的判成同构的，当且仅当：</p>
<ul>
<li>哈希冲突</li>
<li>两个树大小不同</li>
</ul>
<p>我们可以人为的记录一棵树的节点个数，来增加正确率。</p>
<p>事实上好像有保证正确率的做法，反正这个做法单次是 $O(n)$ 的。</p>
<h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><h4 id="树同构（-BJOI2015-树的同构）"><a href="#树同构（-BJOI2015-树的同构）" class="headerlink" title="树同构（[BJOI2015]树的同构）"></a>树同构（[BJOI2015]树的同构）</h4><p>无根树。以其重心为根。重心最多只有两个。复杂度是 $O(n^2)$ 的。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 1005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> put() putchar(<span class="string">&#x27;\n&#x27;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Tp template<span class="string">&lt;typename Ty&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Ts template<span class="string">&lt;typename Ty,typename... Ar&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(<span class="type">int</span> &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> f=<span class="number">1</span>;x=<span class="number">0</span>;<span class="type">char</span> c=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (c&lt;<span class="string">&#x27;0&#x27;</span>||c&gt;<span class="string">&#x27;9&#x27;</span>) &#123;<span class="keyword">if</span> (c==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">-1</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span> (c&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;c&lt;=<span class="string">&#x27;9&#x27;</span>) &#123;x=x*<span class="number">10</span>+c-<span class="string">&#x27;0&#x27;</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> Debug&#123;</span><br><span class="line">	Tp <span class="type">void</span> _debug(<span class="type">char</span>* f,Ty t)&#123;cerr&lt;&lt;f&lt;&lt;<span class="string">&#x27;=&#x27;</span>&lt;&lt;t&lt;&lt;endl;&#125;</span><br><span class="line">	Ts <span class="type">void</span> _debug(<span class="type">char</span>* f,Ty x,Ar... y)&#123;<span class="keyword">while</span>(*f!=<span class="string">&#x27;,&#x27;</span>) cerr&lt;&lt;*f++;cerr&lt;&lt;<span class="string">&#x27;=&#x27;</span>&lt;&lt;x&lt;&lt;<span class="string">&quot;,&quot;</span>;_debug(f+<span class="number">1</span>,y...);&#125;</span><br><span class="line">	Tp ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; os,vector&lt;Ty&gt;&amp; V)&#123;os&lt;&lt;<span class="string">&quot;[&quot;</span>;<span class="keyword">for</span>(<span class="keyword">auto</span>&amp; vv:V) os&lt;&lt;vv&lt;&lt;<span class="string">&quot;,&quot;</span>;os&lt;&lt;<span class="string">&quot;]&quot;</span>;<span class="keyword">return</span> os;&#125;</span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> gdb(...) _debug((char*)#__VA_ARGS__,__VA_ARGS__)</span></span><br><span class="line">&#125;<span class="keyword">using</span> <span class="keyword">namespace</span> Debug;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">	<span class="type">int</span> siz,w;</span><br><span class="line">&#125;g[maxn];</span><br><span class="line"><span class="type">int</span> prime[maxn],cnt,vis[maxn];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">getprime</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> i,j;vis[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">2</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!vis[i]) prime[++cnt]=i;</span><br><span class="line">		<span class="keyword">for</span> (j=<span class="number">1</span>;j&lt;=cnt&amp;&amp;prime[j]*i&lt;=n;j++) &#123;</span><br><span class="line">			vis[i*prime[j]]=<span class="number">1</span>;</span><br><span class="line">			<span class="keyword">if</span> (i%prime[j]==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;to[maxn];</span><br><span class="line"><span class="type">int</span> siz[maxn],Max[maxn],root;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> pre,<span class="type">int</span> SUM)</span> </span>&#123;</span><br><span class="line">	Max[x]=<span class="number">0</span>,siz[x]=<span class="number">1</span>;<span class="type">int</span> i;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> y:to[x]) <span class="keyword">if</span> (y^pre) &#123;</span><br><span class="line">		<span class="built_in">dfs</span>(y,x,SUM);</span><br><span class="line">		siz[x]+=siz[y];</span><br><span class="line">		Max[x]=<span class="built_in">max</span>(Max[x],siz[y]);</span><br><span class="line">	&#125;</span><br><span class="line">	Max[x]=<span class="built_in">max</span>(Max[x],SUM-siz[x]);</span><br><span class="line">	<span class="keyword">if</span> (!root||Max[root]&gt;Max[x]) root=x; </span><br><span class="line">&#125;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">998244353</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="type">int</span> w[<span class="number">105</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ull <span class="title">calc</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> pre)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> i;ull sum=<span class="number">1</span>;siz[x]=<span class="number">1</span>;</span><br><span class="line">	vector&lt;ull&gt;a;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> y:to[x]) <span class="keyword">if</span> (y^pre) a.<span class="built_in">push_back</span>(<span class="built_in">calc</span>(y,x)*prime[siz[y]]%mod),siz[x]+=siz[y];</span><br><span class="line">	<span class="built_in">sort</span>(a.<span class="built_in">begin</span>(),a.<span class="built_in">end</span>());</span><br><span class="line">	<span class="type">int</span> len=a.<span class="built_in">size</span>();</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i++) sum=(sum+a[i])%mod;</span><br><span class="line">	<span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> Cas)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> i,x,y,n,len=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">read</span>(n);</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) to[i].<span class="built_in">clear</span>();</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="built_in">read</span>(x);<span class="keyword">if</span> (x) &#123;</span><br><span class="line">			to[x].<span class="built_in">push_back</span>(i);</span><br><span class="line">			to[i].<span class="built_in">push_back</span>(x);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	root=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">0</span>,n);</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) <span class="keyword">if</span> (Max[i]==Max[root]) w[++len]=<span class="built_in">calc</span>(i,<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">sort</span>(w+<span class="number">1</span>,w+<span class="number">1</span>+len);</span><br><span class="line">	g[Cas].siz=n,g[Cas].w=w[<span class="number">1</span>];</span><br><span class="line"><span class="comment">//	gdb(Cas,g[Cas].siz,g[Cas].w);</span></span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> T,i,j;</span><br><span class="line">	<span class="built_in">read</span>(T);</span><br><span class="line">	<span class="built_in">getprime</span>(<span class="number">1000</span>);<span class="comment">//gdb(cnt);</span></span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=T;i++) <span class="built_in">solve</span>(i);</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=T;i++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (j=<span class="number">1</span>;j&lt;=i;j++) <span class="keyword">if</span> (g[i].siz==g[j].siz&amp;&amp;g[i].w==g[j].w) &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,j);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>学习笔记</tag>
        <tag>哈希</tag>
        <tag>树同构</tag>
      </tags>
  </entry>
  <entry>
    <title>生成树小节</title>
    <url>/2023/08/18/%E7%94%9F%E6%88%90%E6%A0%91%E5%B0%8F%E7%BB%93/</url>
    <content><![CDATA[<h1 id="生成树小结"><a href="#生成树小结" class="headerlink" title="生成树小结"></a>生成树小结</h1><p>参考 fls 7.18 的课件，收获颇多。</p>
<h2 id="Boruvka-算法"><a href="#Boruvka-算法" class="headerlink" title="Boruvka 算法"></a>Boruvka 算法</h2><p>不知道怎么读。</p>
<p>Boruvka 算法可以看作 Prim 的<strong>并行版本</strong>，它基于两个事实：</p>
<ul>
<li><p>已经加入最小生成树的边的两端点可以看作一个点。</p>
</li>
<li><p>和每个点相连的最小的边一定在最小生成树中。</p>
</li>
</ul>
<p>算法流程如下：</p>
<ul>
<li><p>初始时将每个点视为一个联通块，每一轮处理对于每个联通块找到到其它联通块最小的边。</p>
</li>
<li><p>将这些边加入MST中，当联通块只有一个时结束，否则回到第一步</p>
</li>
</ul>
<p>时间复杂度可以从两方面证明：</p>
<ul>
<li>每次结束后联通块个数至多为原来的一半，至多 $O(\log n )$。</li>
<li>每次结束后最小联通块的大小至少为原来的两倍，只会进行 $O(\log n)$ 次。</li>
</ul>
<p>总时间复杂度 $O(m\log m)$。</p>
<p>在<strong>特殊性质的完全图上具有优势</strong>。</p>
<h3 id="1-CF1550F-Jumping-Around"><a href="#1-CF1550F-Jumping-Around" class="headerlink" title="1. CF1550F Jumping Around"></a>1. CF1550F Jumping Around</h3><h4 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h4><p>数轴上顺次有 $n$ 个点 $a_1 &lt; a_2 &lt; \cdots &lt; a_n$。</p>
<p>有一只小青蛙，初始时在 $a_s$ 处。小青蛙有两个参数：步长 $d$ 和灵活程度 $k$。其中，步长 $d$ 是确定的，而灵活程度 $k$ 是可以调整的。</p>
<p>小青蛙可以从某个点跳到另一个点。但这是有要求的：小青蛙能从 $a_i$ 跳到 $a_j$，当且仅当 $d-k\leq |a_i-a_j|\leq d+k$。</p>
<p>给定 $a_1,…,a_n$ 和 $d$。你需要回答 $q$ 次询问，每次询问给定一个灵活程度 $k$ 和一个下标 $i$，你需要回答：此时的小青蛙能否跳到 $a_i$？</p>
<p>保证 $1\leq n,q\leq 2\times 10^5$，$1\leq s,i\leq n$，$1\leq a_i,d,k\leq 10^6$，$a_1 &lt; a_2 &lt; \cdots &lt; a_n$。</p>
<p>5s , 250MB</p>
<h4 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h4><p>观察到 $d-k\le |a_i-a_j|\le d+k\iff ||a_i-a_j|-d|\le k$</p>
<p>不妨把 $(i,j)$ 连边，$||a_i-a_j|-d|$ 作为边权。两点在最小生成树上的简单路径上的最大边权即为互通所需要的最小灵活程度。</p>
<p>这是一个具有特殊性质的完全图。</p>
<p>钦定 $a_i\ge a_j$，则边权为 $|a_i-a_j-d|&#x3D;|(a_i-d)-a_j|$</p>
<p>考虑 Boruvka 算法，每次找到 $a_i-d$ 左右最近的且不在一个连通块的数，用 set 维护是这个过程，每次是 $O(n\log n)$ 的。链表则是 $O(n)$ 的。</p>
<p>这里使用了链表。建出最小生成树后，以 $s$ 为根遍历一遍树即可。</p>
<p>复杂度 $O(n\log n)$。</p>
<h4 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h4><p>由于使用链表，所以代码又臭又长。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 200005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> put() putchar(<span class="string">&#x27;\n&#x27;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Tp template<span class="string">&lt;typename Ty&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Ts template<span class="string">&lt;typename Ty,typename... Ar&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(<span class="type">int</span> &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> f=<span class="number">1</span>;x=<span class="number">0</span>;<span class="type">char</span> c=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (c&lt;<span class="string">&#x27;0&#x27;</span>||c&gt;<span class="string">&#x27;9&#x27;</span>) &#123;<span class="keyword">if</span> (c==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">-1</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span> (c&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;c&lt;=<span class="string">&#x27;9&#x27;</span>) &#123;x=x*<span class="number">10</span>+c-<span class="string">&#x27;0&#x27;</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> Debug&#123;</span><br><span class="line">	Tp <span class="type">void</span> _debug(<span class="type">char</span>* f,Ty t)&#123;cerr&lt;&lt;f&lt;&lt;<span class="string">&#x27;=&#x27;</span>&lt;&lt;t&lt;&lt;endl;&#125;</span><br><span class="line">	Ts <span class="type">void</span> _debug(<span class="type">char</span>* f,Ty x,Ar... y)&#123;<span class="keyword">while</span>(*f!=<span class="string">&#x27;,&#x27;</span>) cerr&lt;&lt;*f++;cerr&lt;&lt;<span class="string">&#x27;=&#x27;</span>&lt;&lt;x&lt;&lt;<span class="string">&quot;,&quot;</span>;_debug(f+<span class="number">1</span>,y...);&#125;</span><br><span class="line">	Tp ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; os,vector&lt;Ty&gt;&amp; V)&#123;os&lt;&lt;<span class="string">&quot;[&quot;</span>;<span class="keyword">for</span>(<span class="keyword">auto</span>&amp; vv:V) os&lt;&lt;vv&lt;&lt;<span class="string">&quot;,&quot;</span>;os&lt;&lt;<span class="string">&quot;]&quot;</span>;<span class="keyword">return</span> os;&#125;</span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> gdb(...) _debug((char*)#__VA_ARGS__,__VA_ARGS__)</span></span><br><span class="line">&#125;<span class="keyword">using</span> <span class="keyword">namespace</span> Debug;</span><br><span class="line"><span class="type">int</span> fa[maxn],n,q,d,s;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf=<span class="number">1e9</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">getfa</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">assert</span>(x&gt;=<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span> (x&lt;<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> x==fa[x]?x:fa[x]=<span class="built_in">getfa</span>(fa[x]);</span><br><span class="line">&#125;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;to[maxn];</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> M 1000005</span></span><br><span class="line"><span class="type">int</span> a[maxn],t[M],nex[M],pre[M],tot;</span><br><span class="line"><span class="type">int</span> w[maxn],v[maxn],z[maxn],pree[M],nexx[M];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">solve</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> las=<span class="number">0</span>,i,tmp,id,now=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;=a[n]+<span class="number">1</span>;i++) &#123;</span><br><span class="line">		pre[i]=now;</span><br><span class="line">		<span class="keyword">if</span> (t[i]) &#123;</span><br><span class="line">			<span class="keyword">if</span> (!now||<span class="built_in">getfa</span>(t[i])!=<span class="built_in">getfa</span>(t[now])) las=now;</span><br><span class="line">			now=i;</span><br><span class="line">		&#125; </span><br><span class="line">		pree[i]=las;</span><br><span class="line">	&#125;  </span><br><span class="line">	las=now=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (i=a[n]+<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--) &#123;</span><br><span class="line">		nex[i]=now;</span><br><span class="line">		<span class="keyword">if</span> (t[i]) &#123;</span><br><span class="line">			<span class="keyword">if</span> (!now||<span class="built_in">getfa</span>(t[i])!=<span class="built_in">getfa</span>(t[now])) las=now;</span><br><span class="line">			now=i;</span><br><span class="line">		&#125;</span><br><span class="line">		nexx[i]=las;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) w[i]=<span class="number">0</span>,z[i]=<span class="number">1e9</span>;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		id=<span class="built_in">getfa</span>(i);</span><br><span class="line">		tmp=pre[<span class="built_in">max</span>(<span class="number">0</span>,a[i]-d+<span class="number">1</span>)];</span><br><span class="line">		<span class="keyword">if</span> (a[i]-d&gt;=<span class="number">1</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (tmp&amp;&amp;<span class="built_in">getfa</span>(i)!=<span class="built_in">getfa</span>(t[tmp])) &#123;</span><br><span class="line">				tmp=t[tmp];</span><br><span class="line">				<span class="keyword">if</span> (!w[id]||z[id]&gt;<span class="built_in">abs</span>(a[i]-d-a[tmp])) &#123;</span><br><span class="line">					w[id]=tmp,v[id]=i,z[id]=<span class="built_in">abs</span>(<span class="built_in">abs</span>(a[i]-a[tmp])-d);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (tmp&amp;&amp;pree[tmp]&amp;&amp;<span class="built_in">getfa</span>(i)!=<span class="built_in">getfa</span>(t[pree[tmp]])) &#123;</span><br><span class="line">				tmp=t[pree[tmp]];</span><br><span class="line">				<span class="keyword">if</span> (!w[id]||z[id]&gt;<span class="built_in">abs</span>(a[i]-d-a[tmp])) &#123;</span><br><span class="line">					w[id]=tmp,v[id]=i,z[id]=<span class="built_in">abs</span>(<span class="built_in">abs</span>(a[i]-a[tmp])-d);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		tmp=nex[<span class="built_in">max</span>(<span class="number">0</span>,a[i]-d<span class="number">-1</span>)];</span><br><span class="line">		<span class="keyword">if</span> (tmp&amp;&amp;<span class="built_in">getfa</span>(i)!=<span class="built_in">getfa</span>(t[tmp])&amp;&amp;tmp&lt;=a[i]) &#123;</span><br><span class="line">			tmp=t[tmp];</span><br><span class="line">			<span class="keyword">if</span> (!w[id]||z[id]&gt;<span class="built_in">abs</span>(-a[tmp]+a[i]-d)) &#123;</span><br><span class="line">				w[id]=tmp,v[id]=i,z[id]=<span class="built_in">abs</span>(<span class="built_in">abs</span>(a[i]-a[tmp])-d);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> (tmp&amp;&amp;nexx[tmp]&amp;&amp;<span class="built_in">getfa</span>(i)!=<span class="built_in">getfa</span>(t[nexx[tmp]])&amp;&amp;nexx[tmp]&lt;=a[i]) &#123;</span><br><span class="line">				tmp=t[nexx[tmp]];</span><br><span class="line">				<span class="keyword">if</span> (!w[id]||z[id]&gt;<span class="built_in">abs</span>(-a[tmp]+a[i]-d)) &#123;</span><br><span class="line">					w[id]=tmp,v[id]=i,z[id]=<span class="built_in">abs</span>(<span class="built_in">abs</span>(a[i]-a[tmp])-d);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;	</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		id=<span class="built_in">getfa</span>(i);</span><br><span class="line">		tmp=pre[<span class="built_in">min</span>(a[n]+<span class="number">1</span>,a[i]+d+<span class="number">1</span>)];</span><br><span class="line">		<span class="keyword">if</span> (tmp&amp;&amp;<span class="built_in">getfa</span>(i)!=<span class="built_in">getfa</span>(t[tmp])&amp;&amp;tmp&gt;=a[i]) &#123;</span><br><span class="line">			tmp=t[tmp];</span><br><span class="line">			<span class="keyword">if</span> (!w[id]||z[id]&gt;<span class="built_in">abs</span>(<span class="built_in">abs</span>(a[i]-a[tmp])-d)) &#123;</span><br><span class="line">				w[id]=tmp,v[id]=i,z[id]=<span class="built_in">abs</span>(<span class="built_in">abs</span>(a[i]-a[tmp])-d);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (tmp&amp;&amp;pree[tmp]&amp;&amp;<span class="built_in">getfa</span>(i)!=<span class="built_in">getfa</span>(t[pree[tmp]])&amp;&amp;pree[tmp]&gt;=a[i]) &#123;</span><br><span class="line">			tmp=t[pree[tmp]];	</span><br><span class="line">			<span class="keyword">if</span> (!w[id]||z[id]&gt;<span class="built_in">abs</span>(<span class="built_in">abs</span>(a[i]-a[tmp])-d)) &#123;</span><br><span class="line">				w[id]=tmp,v[id]=i,z[id]=<span class="built_in">abs</span>(<span class="built_in">abs</span>(a[i]-a[tmp])-d);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		tmp=nex[<span class="built_in">min</span>(a[n]+<span class="number">1</span>,a[i]+d<span class="number">-1</span>)];</span><br><span class="line">		<span class="keyword">if</span> (a[i]+d&lt;=a[n]) &#123;</span><br><span class="line">			<span class="keyword">if</span> (tmp&amp;&amp;<span class="built_in">getfa</span>(i)!=<span class="built_in">getfa</span>(t[tmp])) &#123;</span><br><span class="line">				tmp=t[tmp];</span><br><span class="line">				<span class="keyword">if</span> (!w[id]||z[id]&gt;<span class="built_in">abs</span>(<span class="built_in">abs</span>(a[i]-a[tmp])-d)) &#123;</span><br><span class="line">					w[id]=tmp,v[id]=i,z[id]=<span class="built_in">abs</span>(<span class="built_in">abs</span>(a[i]-a[tmp])-d);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (tmp&amp;&amp;nexx[tmp]&amp;&amp;<span class="built_in">getfa</span>(i)!=<span class="built_in">getfa</span>(t[nexx[tmp]])) &#123;</span><br><span class="line">				tmp=t[nexx[tmp]];	</span><br><span class="line">				<span class="keyword">if</span> (!w[id]||z[id]&gt;<span class="built_in">abs</span>(<span class="built_in">abs</span>(a[i]-a[tmp])-d)) &#123;</span><br><span class="line">					w[id]=tmp,v[id]=i,z[id]=<span class="built_in">abs</span>(<span class="built_in">abs</span>(a[i]-a[tmp])-d);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;	</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="type">int</span> id=<span class="built_in">getfa</span>(i);</span><br><span class="line">		<span class="keyword">if</span> (w[id]&amp;&amp;id!=<span class="built_in">getfa</span>(w[id])) &#123;</span><br><span class="line">			<span class="built_in">assert</span>(z[id]==<span class="built_in">abs</span>(<span class="built_in">abs</span>(a[v[id]]-a[w[id]])-d));</span><br><span class="line">			tot--;</span><br><span class="line">			fa[id]=<span class="built_in">getfa</span>(w[id]);</span><br><span class="line">			to[v[id]].<span class="built_in">push_back</span>(w[id]);</span><br><span class="line">			to[w[id]].<span class="built_in">push_back</span>(v[id]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> dis[maxn];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> pre)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> y:to[x]) <span class="keyword">if</span> (y^pre) &#123;</span><br><span class="line">		dis[y]=<span class="built_in">max</span>(dis[x],<span class="built_in">abs</span>(<span class="built_in">abs</span>(a[x]-a[y])-d));</span><br><span class="line">		<span class="built_in">dfs</span>(y,x);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> i,x,y;</span><br><span class="line">	<span class="built_in">read</span>(n);<span class="built_in">read</span>(q);<span class="built_in">read</span>(s);<span class="built_in">read</span>(d);</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">read</span>(a[i]),fa[i]=i,t[a[i]]=i;</span><br><span class="line">	tot=n;</span><br><span class="line">	<span class="keyword">while</span> (tot&gt;<span class="number">1</span>) <span class="built_in">solve</span>();</span><br><span class="line">	dis[s]=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">dfs</span>(s,<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">while</span> (q--) &#123;</span><br><span class="line">		<span class="built_in">read</span>(x);<span class="built_in">read</span>(y);</span><br><span class="line">		<span class="built_in">puts</span>(dis[x]&lt;=y?<span class="string">&quot;Yes&quot;</span>:<span class="string">&quot;No&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-CF1305G-Kuroni-and-Antihype"><a href="#2-CF1305G-Kuroni-and-Antihype" class="headerlink" title="2. CF1305G Kuroni and Antihype"></a>2. CF1305G Kuroni and Antihype</h3><h3 id="Description-1"><a href="#Description-1" class="headerlink" title="Description"></a>Description</h3><p>现在有 $n$ 个人，并且给出他们的年龄。两个人是朋友，当且仅当两个人年龄的<strong>按位与</strong>结果为 $0$。</p>
<p>现在，有一个传销组织，每个人有两种操作：</p>
<ol>
<li><p>主动加入传销组织，这样的话，传销组织不会给你钱；</p>
</li>
<li><p>邀请自己的一个朋友加入传销组织，这样的话，传销组织会奖励你数值等于你的年龄的钱。（当然，执行该操作的人必须已经进入传销组织了）</p>
</li>
</ol>
<p>每个人只可以进入传销组织一次。</p>
<p>求如果 $n$ 个人通力合作，传销组织支付给这 $n$ 个人的钱数之和最大是多少。</p>
<p>$1\le n\le 2\times 10^5,0\le a_i\le 2\times 10^5$</p>
<p>3s , 250MB</p>
<h4 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution"></a>Solution</h4><p>建立虚点 $n+1$ ，$a_{n+1}&#x3D;0$。</p>
<p>两个点 $i,j$ 连边当且仅当按位与为 $0$，权值为 $a_i+a_j$。</p>
<p>找出最大生成树。最后答案减去 $\sum a_i$。容易发现这么做是对的，而且很妙。</p>
<p>考虑 Boruvka 算法，每次找到与自己不在一个连通块，且按位与为 $0$ 的最大的数。可以用 SOSdp 维护不在同一个连通块的最大值和不严格次大值。</p>
<p>复杂度 $O((2^{B}B+n)\log n)$，本题中 $B&#x3D;\log w&#x3D;18$。</p>
<h4 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 200005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> put() putchar(<span class="string">&#x27;\n&#x27;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Tp template<span class="string">&lt;typename Ty&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Ts template<span class="string">&lt;typename Ty,typename... Ar&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(<span class="type">int</span> &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> f=<span class="number">1</span>;x=<span class="number">0</span>;<span class="type">char</span> c=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (c&lt;<span class="string">&#x27;0&#x27;</span>||c&gt;<span class="string">&#x27;9&#x27;</span>) &#123;<span class="keyword">if</span> (c==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">-1</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span> (c&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;c&lt;=<span class="string">&#x27;9&#x27;</span>) &#123;x=x*<span class="number">10</span>+c-<span class="string">&#x27;0&#x27;</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> Debug&#123;</span><br><span class="line">	Tp <span class="type">void</span> _debug(<span class="type">char</span>* f,Ty t)&#123;cerr&lt;&lt;f&lt;&lt;<span class="string">&#x27;=&#x27;</span>&lt;&lt;t&lt;&lt;endl;&#125;</span><br><span class="line">	Ts <span class="type">void</span> _debug(<span class="type">char</span>* f,Ty x,Ar... y)&#123;<span class="keyword">while</span>(*f!=<span class="string">&#x27;,&#x27;</span>) cerr&lt;&lt;*f++;cerr&lt;&lt;<span class="string">&#x27;=&#x27;</span>&lt;&lt;x&lt;&lt;<span class="string">&quot;,&quot;</span>;_debug(f+<span class="number">1</span>,y...);&#125;</span><br><span class="line">	Tp ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; os,vector&lt;Ty&gt;&amp; V)&#123;os&lt;&lt;<span class="string">&quot;[&quot;</span>;<span class="keyword">for</span>(<span class="keyword">auto</span>&amp; vv:V) os&lt;&lt;vv&lt;&lt;<span class="string">&quot;,&quot;</span>;os&lt;&lt;<span class="string">&quot;]&quot;</span>;<span class="keyword">return</span> os;&#125;</span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> gdb(...) _debug((char*)#__VA_ARGS__,__VA_ARGS__)</span></span><br><span class="line">&#125;<span class="keyword">using</span> <span class="keyword">namespace</span> Debug;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> base=<span class="number">18</span>,N=<span class="number">1</span>&lt;&lt;base;</span><br><span class="line"><span class="type">int</span> n,a[maxn];</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf=<span class="number">1e12</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">yyy</span>&#123;</span><br><span class="line">	<span class="type">int</span> id,w;</span><br><span class="line">	<span class="built_in">yyy</span>(<span class="type">int</span> a=<span class="number">0</span>,<span class="type">int</span> b=-inf) &#123;id=a;w=b;&#125;</span><br><span class="line">&#125;rt[<span class="number">5</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">cmp</span><span class="params">(yyy x,yyy y)</span> </span>&#123;<span class="keyword">return</span> x.w&gt;y.w;&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">	yyy x,y;</span><br><span class="line">	node <span class="keyword">operator</span> +(<span class="type">const</span> node &amp;tmp) <span class="type">const</span> &#123;</span><br><span class="line">		rt[<span class="number">0</span>]=x,rt[<span class="number">1</span>]=y,rt[<span class="number">2</span>]=tmp.x,rt[<span class="number">3</span>]=tmp.y;</span><br><span class="line">		<span class="built_in">sort</span>(rt,rt+<span class="number">4</span>,cmp);</span><br><span class="line">		node ans;</span><br><span class="line">		ans.x=rt[<span class="number">0</span>];</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">3</span>;i++) <span class="keyword">if</span> (rt[i].id!=rt[<span class="number">0</span>].id) &#123;ans.y=rt[i];<span class="keyword">break</span>;&#125;</span><br><span class="line">		<span class="keyword">return</span> ans;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;f[N+<span class="number">5</span>];</span><br><span class="line"><span class="type">int</span> fa[maxn],tot,w[maxn],ans,v[maxn];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">getfa</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;<span class="keyword">return</span> x==fa[x]?x:fa[x]=<span class="built_in">getfa</span>(fa[x]);&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">solve</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> i,j;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) w[i]=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;N;i++) f[i].x=f[i].y=<span class="built_in">yyy</span>(<span class="number">0</span>,-inf);</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		node tmp;</span><br><span class="line">		tmp.x=<span class="built_in">yyy</span>(<span class="built_in">getfa</span>(i),a[i]);</span><br><span class="line">		f[a[i]]=f[a[i]]+tmp;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;base;i++) 	</span><br><span class="line">		<span class="keyword">for</span> (j=<span class="number">0</span>;j&lt;N;j++) <span class="keyword">if</span> ((j&gt;&gt;i)&amp;<span class="number">1</span>)&#123;</span><br><span class="line">			f[j]=f[j]+f[j^(<span class="number">1</span>&lt;&lt;i)];</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="type">int</span> T=(N<span class="number">-1</span>)^a[i];</span><br><span class="line">		<span class="type">int</span> id=<span class="built_in">getfa</span>(i);</span><br><span class="line">		<span class="keyword">if</span> (f[T].x.id!=id) &#123;</span><br><span class="line">			<span class="keyword">if</span> (w[id]&lt;a[i]+f[T].x.w) &#123;</span><br><span class="line">				w[id]=a[i]+f[T].x.w;</span><br><span class="line">				v[id]=<span class="built_in">getfa</span>(f[T].x.id);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> (w[id]&lt;a[i]+f[T].y.w) &#123;</span><br><span class="line">				w[id]=a[i]+f[T].y.w;</span><br><span class="line">				v[id]=<span class="built_in">getfa</span>(f[T].y.id);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) <span class="keyword">if</span> (i==<span class="built_in">getfa</span>(i)) &#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">getfa</span>(i)^<span class="built_in">getfa</span>(v[i])) &#123;</span><br><span class="line">			fa[<span class="built_in">getfa</span>(i)]=<span class="built_in">getfa</span>(v[i]);</span><br><span class="line">			ans+=w[i];</span><br><span class="line">			tot--;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="built_in">read</span>(n);</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">read</span>(a[i]),ans-=a[i];</span><br><span class="line">	n++;tot=n;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) fa[i]=i;</span><br><span class="line">	<span class="keyword">while</span> (tot&gt;<span class="number">1</span>) <span class="built_in">solve</span>();</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-IOI2021-Keys"><a href="#3-IOI2021-Keys" class="headerlink" title="3. IOI2021 Keys"></a>3. IOI2021 Keys</h3><p>待补</p>
<h2 id="生成树的特殊求法-x2F-性质"><a href="#生成树的特殊求法-x2F-性质" class="headerlink" title="生成树的特殊求法&#x2F;性质"></a>生成树的特殊求法&#x2F;性质</h2><p>有一个奇怪定理：</p>
<p>如果一张图的<strong>边集</strong>分为若干个子集，保证子集的交为原边集，则所有边子集的 MST 构成的边集的 MST 为原图的 MST。</p>
<p>有点绕，但是很好用。</p>
<h3 id="1-THUPC2022初赛-A-最小公倍树"><a href="#1-THUPC2022初赛-A-最小公倍树" class="headerlink" title="1. THUPC2022初赛 A 最小公倍树"></a>1. THUPC2022初赛 A 最小公倍树</h3><h4 id="Description-2"><a href="#Description-2" class="headerlink" title="Description"></a>Description</h4><p> 点 $(i,j)$ 的边权为 $lcm(i,j)$ ，求点在 $[L,R]$ 中的最小生成树。</p>
<p>$1\le L\le R\le 10^6,R-L\le 10^5$</p>
<p>1s , 512MB</p>
<h4 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution"></a>Solution</h4><p>枚举公约数 $d$。$\forall i\in [L,R],d|i$ 的数组成的集合中，令其中最小的数为 $x$，最小生成树为其他点 $y$ 连向点 $x$，边权为 $\dfrac{xy}{d}$。因为求的是最小生成树，即使 $d$ 不是 $x,y$ 的最大公约数也不会对答案造成影响。</p>
<p>复杂度 $O(n\ln \log n)$，其中边的数量是 $O(n\ln n)$ 的。</p>
<h4 id="Code-2"><a href="#Code-2" class="headerlink" title="Code"></a>Code</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 1000005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> put() putchar(<span class="string">&#x27;\n&#x27;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Tp template<span class="string">&lt;typename Ty&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Ts template<span class="string">&lt;typename Ty,typename... Ar&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(<span class="type">int</span> &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> f=<span class="number">1</span>;x=<span class="number">0</span>;<span class="type">char</span> c=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (c&lt;<span class="string">&#x27;0&#x27;</span>||c&gt;<span class="string">&#x27;9&#x27;</span>) &#123;<span class="keyword">if</span> (c==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">-1</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span> (c&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;c&lt;=<span class="string">&#x27;9&#x27;</span>) &#123;x=x*<span class="number">10</span>+c-<span class="string">&#x27;0&#x27;</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> Debug&#123;</span><br><span class="line">	Tp <span class="type">void</span> _debug(<span class="type">char</span>* f,Ty t)&#123;cerr&lt;&lt;f&lt;&lt;<span class="string">&#x27;=&#x27;</span>&lt;&lt;t&lt;&lt;endl;&#125;</span><br><span class="line">	Ts <span class="type">void</span> _debug(<span class="type">char</span>* f,Ty x,Ar... y)&#123;<span class="keyword">while</span>(*f!=<span class="string">&#x27;,&#x27;</span>) cerr&lt;&lt;*f++;cerr&lt;&lt;<span class="string">&#x27;=&#x27;</span>&lt;&lt;x&lt;&lt;<span class="string">&quot;,&quot;</span>;_debug(f+<span class="number">1</span>,y...);&#125;</span><br><span class="line">	Tp ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; os,vector&lt;Ty&gt;&amp; V)&#123;os&lt;&lt;<span class="string">&quot;[&quot;</span>;<span class="keyword">for</span>(<span class="keyword">auto</span>&amp; vv:V) os&lt;&lt;vv&lt;&lt;<span class="string">&quot;,&quot;</span>;os&lt;&lt;<span class="string">&quot;]&quot;</span>;<span class="keyword">return</span> os;&#125;</span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> gdb(...) _debug((char*)#__VA_ARGS__,__VA_ARGS__)</span></span><br><span class="line">&#125;<span class="keyword">using</span> <span class="keyword">namespace</span> Debug;</span><br><span class="line"><span class="type">int</span> L,R;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">	<span class="type">int</span> x,y,z;</span><br><span class="line">&#125;e[<span class="number">10000005</span>];</span><br><span class="line"><span class="type">int</span> ans,fa[maxn],tot;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">cmp</span><span class="params">(node x,node y)</span> </span>&#123;<span class="keyword">return</span> x.z&lt;y.z;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">getfa</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;<span class="keyword">return</span> x==fa[x]?x:fa[x]=<span class="built_in">getfa</span>(fa[x]);&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> i,j;</span><br><span class="line">	<span class="built_in">read</span>(L);<span class="built_in">read</span>(R);</span><br><span class="line">	<span class="keyword">for</span> (j=<span class="number">1</span>;j&lt;=R;j++) &#123;</span><br><span class="line">		<span class="type">int</span> minn=(L<span class="number">-1</span>)/j*j+j;</span><br><span class="line">		<span class="keyword">if</span> (minn&gt;R) <span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">for</span> (i=minn+j;i&lt;=R;i+=j) ++tot,e[tot]=(node)&#123;minn,i,minn/j*i&#125;;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=R;i++) fa[i]=i;</span><br><span class="line">	<span class="built_in">sort</span>(e+<span class="number">1</span>,e+<span class="number">1</span>+tot,cmp);</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=tot;i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">getfa</span>(e[i].x)!=<span class="built_in">getfa</span>(e[i].y)) &#123;</span><br><span class="line">			fa[<span class="built_in">getfa</span>(e[i].x)]=<span class="built_in">getfa</span>(e[i].y);</span><br><span class="line">			ans+=e[i].z;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-AT3611-Tree-MST"><a href="#2-AT3611-Tree-MST" class="headerlink" title="2. AT3611 Tree MST"></a>2. AT3611 Tree MST</h3><h4 id="Description-3"><a href="#Description-3" class="headerlink" title="Description"></a>Description</h4><p>给定一棵 $n$ 个节点的树，现有有一张完全图，两点 $x,y$ 之间的边长为 $w_x+w_y+dis_{x,y}$，其中 $dis$ 表示树上两点的距离。</p>
<p>求完全图的最小生成树。</p>
<p>$n \leq 2 \times 10^5$。</p>
<p>5s , 256MB</p>
<h4 id="Solution-3"><a href="#Solution-3" class="headerlink" title="Solution"></a>Solution</h4><p>由于对路径的形态没有要求，很自然的联想到点分治。</p>
<p>考虑点分治的过程，现在要求经过点 $r$ 的路径的 MST。枚举存在于不同子树中的两个点 $x,y$，$w_x+w_y+dis_{x,y}&#x3D;(w_x+d_x)+(w_y+d_y)$ ，其中 $d_x$ 是 $x$ 到根 $r$ 的距离.</p>
<p>令树上 $w_x+d_x$ 最小的点为 $i$ 。对于跟 $i$ 不同的子树中，与 $i$ 相连显然是不劣的。对于跟 $i$ 在相同的子树中的节点，之后递归以后会出现更优的边，由于最后要求的是最小生成树，所以跟 $i$ 相连并不会对结果产生影响。</p>
<p>复杂度 $O(n\log^2n)$ ，其中边的数量是 $O(n\log n)$ 的。</p>
<h4 id="Code-3"><a href="#Code-3" class="headerlink" title="Code"></a>Code</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 200005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> put() putchar(<span class="string">&#x27;\n&#x27;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Tp template<span class="string">&lt;typename Ty&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Ts template<span class="string">&lt;typename Ty,typename... Ar&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(<span class="type">int</span> &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> f=<span class="number">1</span>;x=<span class="number">0</span>;<span class="type">char</span> c=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (c&lt;<span class="string">&#x27;0&#x27;</span>||c&gt;<span class="string">&#x27;9&#x27;</span>) &#123;<span class="keyword">if</span> (c==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">-1</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span> (c&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;c&lt;=<span class="string">&#x27;9&#x27;</span>) &#123;x=x*<span class="number">10</span>+c-<span class="string">&#x27;0&#x27;</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> Debug&#123;</span><br><span class="line">	Tp <span class="type">void</span> _debug(<span class="type">char</span>* f,Ty t)&#123;cerr&lt;&lt;f&lt;&lt;<span class="string">&#x27;=&#x27;</span>&lt;&lt;t&lt;&lt;endl;&#125;</span><br><span class="line">	Ts <span class="type">void</span> _debug(<span class="type">char</span>* f,Ty x,Ar... y)&#123;<span class="keyword">while</span>(*f!=<span class="string">&#x27;,&#x27;</span>) cerr&lt;&lt;*f++;cerr&lt;&lt;<span class="string">&#x27;=&#x27;</span>&lt;&lt;x&lt;&lt;<span class="string">&quot;,&quot;</span>;_debug(f+<span class="number">1</span>,y...);&#125;</span><br><span class="line">	Tp ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; os,vector&lt;Ty&gt;&amp; V)&#123;os&lt;&lt;<span class="string">&quot;[&quot;</span>;<span class="keyword">for</span>(<span class="keyword">auto</span>&amp; vv:V) os&lt;&lt;vv&lt;&lt;<span class="string">&quot;,&quot;</span>;os&lt;&lt;<span class="string">&quot;]&quot;</span>;<span class="keyword">return</span> os;&#125;</span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> gdb(...) _debug((char*)#__VA_ARGS__,__VA_ARGS__)</span></span><br><span class="line">&#125;<span class="keyword">using</span> <span class="keyword">namespace</span> Debug;</span><br><span class="line"><span class="type">int</span> n,w[maxn];</span><br><span class="line"><span class="type">int</span> h[maxn],head=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">yyy</span>&#123;</span><br><span class="line">	<span class="type">int</span> to,z,w;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">		to=y;z=h[x];h[x]=head;w=val;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;a[maxn*<span class="number">2</span>];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">	<span class="type">int</span> x,y,z;</span><br><span class="line">&#125;e[maxn*<span class="number">20</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">cmp</span><span class="params">(node x,node y)</span> </span>&#123;<span class="keyword">return</span> x.z&lt;y.z;&#125;</span><br><span class="line"><span class="type">int</span> root,tot,siz[maxn],Max[maxn],vis[maxn];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">clear</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> pre)</span> </span>&#123;</span><br><span class="line">	siz[x]=<span class="number">1</span>;Max[x]=<span class="number">0</span>;<span class="type">int</span> i,y;</span><br><span class="line">	<span class="keyword">for</span> (i=h[x];i;i=a[i].z) <span class="keyword">if</span> (a[i].to!=pre&amp;&amp;!vis[y=a[i].to]) &#123;</span><br><span class="line">		<span class="built_in">clear</span>(y,x);</span><br><span class="line">		siz[x]+=siz[y];</span><br><span class="line">		Max[x]=<span class="built_in">max</span>(Max[x],siz[y]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> pre,<span class="type">int</span> SUM)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="keyword">for</span> (i=h[x];i;i=a[i].z) <span class="keyword">if</span> (a[i].to!=pre&amp;&amp;!vis[a[i].to]) &#123;</span><br><span class="line">		<span class="built_in">dfs1</span>(a[i].to,x,SUM);</span><br><span class="line">	&#125;</span><br><span class="line">	Max[x]=<span class="built_in">max</span>(Max[x],SUM-siz[x]);</span><br><span class="line">	<span class="keyword">if</span> (!root||Max[root]&gt;Max[x]) root=x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">getroot</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">	root=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">clear</span>(x,<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">dfs1</span>(x,<span class="number">0</span>,siz[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> dis[maxn],fa[maxn];</span><br><span class="line"><span class="type">int</span> minn,ans;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">getfa</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;<span class="keyword">return</span> x==fa[x]?x:fa[x]=<span class="built_in">getfa</span>(fa[x]);&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> pre)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="keyword">if</span> (!minn||dis[x]+w[x]&lt;dis[minn]+w[minn]) minn=x;</span><br><span class="line">	<span class="keyword">for</span> (i=h[x];i;i=a[i].z) <span class="keyword">if</span> (a[i].to!=pre&amp;&amp;!vis[a[i].to]) &#123;</span><br><span class="line">		dis[a[i].to]=dis[x]+a[i].w;</span><br><span class="line">		<span class="built_in">dfs</span>(a[i].to,x);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">dfs3</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> pre)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="keyword">if</span> (x^minn) e[++tot]=(node)&#123;minn,x,dis[x]+dis[minn]+w[x]+w[minn]&#125;;</span><br><span class="line">	<span class="keyword">for</span> (i=h[x];i;i=a[i].z) <span class="keyword">if</span> (a[i].to!=pre&amp;&amp;!vis[a[i].to]) &#123;</span><br><span class="line">		<span class="built_in">dfs3</span>(a[i].to,x);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	vis[x]=<span class="number">1</span>;dis[x]=<span class="number">0</span>;minn=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">dfs</span>(x,<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">dfs3</span>(x,<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">for</span> (i=h[x];i;i=a[i].z) <span class="keyword">if</span> (!vis[a[i].to]) &#123;</span><br><span class="line">		<span class="built_in">getroot</span>(a[i].to);</span><br><span class="line">		<span class="built_in">solve</span>(root);</span><br><span class="line">	&#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> i,x,y,z;</span><br><span class="line">	<span class="built_in">read</span>(n);</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">read</span>(w[i]);</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;n;i++) &#123;</span><br><span class="line">		<span class="built_in">read</span>(x);<span class="built_in">read</span>(y);<span class="built_in">read</span>(z);</span><br><span class="line">		a[++head].<span class="built_in">add</span>(x,y,z);</span><br><span class="line">		a[++head].<span class="built_in">add</span>(y,x,z);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">getroot</span>(<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">solve</span>(root);</span><br><span class="line">	<span class="built_in">sort</span>(e+<span class="number">1</span>,e+<span class="number">1</span>+tot,cmp);</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) fa[i]=i;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=tot;i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">getfa</span>(e[i].x)!=<span class="built_in">getfa</span>(e[i].y)) &#123;</span><br><span class="line">			fa[<span class="built_in">getfa</span>(e[i].x)]=<span class="built_in">getfa</span>(e[i].y);</span><br><span class="line">			ans+=e[i].z;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-CF888G-Xor-MST"><a href="#3-CF888G-Xor-MST" class="headerlink" title="3. CF888G Xor-MST"></a>3. CF888G Xor-MST</h3><h4 id="Description-4"><a href="#Description-4" class="headerlink" title="Description"></a>Description</h4><p>给定 $n$ 个结点的无向完全图。每个点有一个点权为 $a_i$。连接 $i$ 号结点和 $j$ 号结点的边的边权为 $a_i\oplus a_j$。求这个图的 MST 的权值。</p>
<p>$1\le n\le 2\times 10^5$，$0\le a_i&lt; 2^{30}$。</p>
<p>2s , 250MB</p>
<h4 id="Solution-4"><a href="#Solution-4" class="headerlink" title="Solution"></a>Solution</h4><p>建立 01Trie。</p>
<p>回忆一下 Kruskal 的过程，是按照边权从小到大合并的。我们可以考虑模拟这个从小到大的过程。</p>
<p>在一个点处将左右儿子合并成一个联通块一定是正确的。因为到更上面合并权值还要更大。</p>
<p>现在我们要查询两个点集之间的最小 xor。由于 01Trie 只有 $O(\log v)$ 层，暴力将一侧的点拿出来到另一边查询最小的 xor 值复杂度就是 $O(n\log ^2v)$ 的，不需要启发式合并。</p>
<h4 id="Code-4"><a href="#Code-4" class="headerlink" title="Code"></a>Code</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rg register</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 200005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> put() putchar(<span class="string">&#x27;\n&#x27;</span>)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(<span class="type">int</span> &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> f=<span class="number">1</span>;x=<span class="number">0</span>;<span class="type">char</span> c=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (c&lt;<span class="string">&#x27;0&#x27;</span>||c&gt;<span class="string">&#x27;9&#x27;</span>) &#123;<span class="keyword">if</span> (c==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">-1</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span> (c&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;c&lt;=<span class="string">&#x27;9&#x27;</span>) &#123;x=x*<span class="number">10</span>+c-<span class="string">&#x27;0&#x27;</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> cnt,root,n,a[maxn],g[maxn],tot,ans;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">yyy</span>&#123;</span><br><span class="line">    <span class="type">int</span> ls,rs,size,val;</span><br><span class="line">&#125;f[maxn*<span class="number">30</span>];</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> base=<span class="number">31</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> &amp;rt,<span class="type">int</span> x,<span class="type">int</span> deep)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!rt) rt=++cnt;f[rt].size++;</span><br><span class="line">	<span class="keyword">if</span> (deep&lt;<span class="number">0</span>) &#123;f[rt].val=x;<span class="keyword">return</span>;&#125;</span><br><span class="line">	<span class="keyword">if</span> ((x&gt;&gt;deep)&amp;<span class="number">1</span>) <span class="built_in">insert</span>(f[rt].rs,x,deep<span class="number">-1</span>);</span><br><span class="line">	<span class="keyword">else</span> <span class="built_in">insert</span>(f[rt].ls,x,deep<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> rt,<span class="type">int</span> deep)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (deep&lt;<span class="number">0</span>) &#123;g[++tot]=f[rt].val;<span class="keyword">return</span>;&#125;</span><br><span class="line">	<span class="keyword">if</span> (f[rt].ls) <span class="built_in">dfs2</span>(f[rt].ls,deep<span class="number">-1</span>);</span><br><span class="line">	<span class="keyword">if</span> (f[rt].rs) <span class="built_in">dfs2</span>(f[rt].rs,deep<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> rt,<span class="type">int</span> x,<span class="type">int</span> deep)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (deep&lt;<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (x&amp;(<span class="number">1ll</span>&lt;&lt;deep)) &#123;</span><br><span class="line">		<span class="keyword">if</span> (f[rt].rs) <span class="keyword">return</span> <span class="built_in">query</span>(f[rt].rs,x,deep<span class="number">-1</span>);</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">query</span>(f[rt].ls,x,deep<span class="number">-1</span>)+(<span class="number">1ll</span>&lt;&lt;deep);  </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (f[rt].ls) <span class="keyword">return</span> <span class="built_in">query</span>(f[rt].ls,x,deep<span class="number">-1</span>);</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">query</span>(f[rt].rs,x,deep<span class="number">-1</span>)+(<span class="number">1ll</span>&lt;&lt;deep);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> rt,<span class="type">int</span> deep)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (f[rt].size&lt;=<span class="number">1</span>||deep&lt;<span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">if</span> (f[rt].ls) <span class="built_in">dfs</span>(f[rt].ls,deep<span class="number">-1</span>);</span><br><span class="line">	<span class="keyword">if</span> (f[rt].rs) <span class="built_in">dfs</span>(f[rt].rs,deep<span class="number">-1</span>);</span><br><span class="line">	<span class="keyword">if</span> (f[rt].ls&amp;&amp;f[rt].rs) &#123;</span><br><span class="line">		rg <span class="type">int</span> i,tmp,Min=<span class="number">1e18</span>;tot=<span class="number">0</span>;</span><br><span class="line">		<span class="built_in">dfs2</span>(f[rt].ls,deep<span class="number">-1</span>);</span><br><span class="line">		<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=tot;i++) tmp=<span class="built_in">query</span>(f[rt].rs,g[i],deep<span class="number">-1</span>),Min=<span class="built_in">min</span>(tmp,Min);</span><br><span class="line">		ans+=Min+(<span class="number">1ll</span>&lt;&lt;deep);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    rg <span class="type">int</span> i;</span><br><span class="line">    <span class="built_in">read</span>(n);cnt=root=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">read</span>(a[i]),<span class="built_in">insert</span>(root,a[i],base);</span><br><span class="line">    <span class="built_in">dfs</span>(root,base);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-CF1687B-Railway-System"><a href="#4-CF1687B-Railway-System" class="headerlink" title="4. CF1687B Railway System"></a>4. CF1687B Railway System</h3><h4 id="Description-5"><a href="#Description-5" class="headerlink" title="Description"></a>Description</h4><p>交互题，交互库有一张图，每次询问若干条边，交互库返回这些边的最大生成树的权值。</p>
<p>不超过 $2m $ 次询问报告最小生成树。</p>
<p>$n\le 200,m\le 500$</p>
<p>1s , 250MB</p>
<h4 id="Solution-5"><a href="#Solution-5" class="headerlink" title="Solution"></a>Solution</h4><p>先用 $m$ 次问出每条边的权值。</p>
<p>把这 $m$ 条边从小到大排序，如果这条边 $i$ 有贡献，则这条边连接的两个点在排序后 $[1,i)$ 组成的图中并不连通。</p>
<p>询问 $[1,i]$ 组成的最大生成树的权值，通过权值增加来判断这条边原来的两个点是不是联通。</p>
<h4 id="Code-5"><a href="#Code-5" class="headerlink" title="Code"></a>Code</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 1005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> put() putchar(<span class="string">&#x27;\n&#x27;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Tp template<span class="string">&lt;typename Ty&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Ts template<span class="string">&lt;typename Ty,typename... Ar&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(<span class="type">int</span> &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> f=<span class="number">1</span>;x=<span class="number">0</span>;<span class="type">char</span> c=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (c&lt;<span class="string">&#x27;0&#x27;</span>||c&gt;<span class="string">&#x27;9&#x27;</span>) &#123;<span class="keyword">if</span> (c==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">-1</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span> (c&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;c&lt;=<span class="string">&#x27;9&#x27;</span>) &#123;x=x*<span class="number">10</span>+c-<span class="string">&#x27;0&#x27;</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> Debug&#123;</span><br><span class="line">	Tp <span class="type">void</span> _debug(<span class="type">char</span>* f,Ty t)&#123;cerr&lt;&lt;f&lt;&lt;<span class="string">&#x27;=&#x27;</span>&lt;&lt;t&lt;&lt;endl;&#125;</span><br><span class="line">	Ts <span class="type">void</span> _debug(<span class="type">char</span>* f,Ty x,Ar... y)&#123;<span class="keyword">while</span>(*f!=<span class="string">&#x27;,&#x27;</span>) cerr&lt;&lt;*f++;cerr&lt;&lt;<span class="string">&#x27;=&#x27;</span>&lt;&lt;x&lt;&lt;<span class="string">&quot;,&quot;</span>;_debug(f+<span class="number">1</span>,y...);&#125;</span><br><span class="line">	Tp ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; os,vector&lt;Ty&gt;&amp; V)&#123;os&lt;&lt;<span class="string">&quot;[&quot;</span>;<span class="keyword">for</span>(<span class="keyword">auto</span>&amp; vv:V) os&lt;&lt;vv&lt;&lt;<span class="string">&quot;,&quot;</span>;os&lt;&lt;<span class="string">&quot;]&quot;</span>;<span class="keyword">return</span> os;&#125;</span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> gdb(...) _debug((char*)#__VA_ARGS__,__VA_ARGS__)</span></span><br><span class="line">&#125;<span class="keyword">using</span> <span class="keyword">namespace</span> Debug;</span><br><span class="line"><span class="type">int</span> n,m,ans;</span><br><span class="line">string s,t;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">yyy</span>&#123;</span><br><span class="line">	<span class="type">int</span> id,w;</span><br><span class="line">&#125;a[maxn];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">cmp</span><span class="params">(yyy x,yyy y)</span> </span>&#123;<span class="keyword">return</span> x.w&lt;y.w;&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line"><span class="comment">//	freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);</span></span><br><span class="line">	<span class="type">int</span> i,x,y;</span><br><span class="line">	<span class="built_in">read</span>(n);<span class="built_in">read</span>(m);</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=m;i++) s+=<span class="string">&quot;0&quot;</span>;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;m;i++) &#123;</span><br><span class="line">		t=s;t[i]=<span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;? &quot;</span>&lt;&lt;t&lt;&lt;endl;</span><br><span class="line">		<span class="built_in">fflush</span>(stdout);</span><br><span class="line">		<span class="built_in">read</span>(a[i].w);a[i].id=i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">sort</span>(a,a+m,cmp);</span><br><span class="line">	t=s;</span><br><span class="line">	<span class="type">int</span> las=<span class="number">0</span>,now;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;m;i++) &#123;</span><br><span class="line">		t[a[i].id]=<span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;? &quot;</span>&lt;&lt;t&lt;&lt;endl;</span><br><span class="line">		<span class="built_in">fflush</span>(stdout);</span><br><span class="line">		<span class="built_in">read</span>(now);</span><br><span class="line">		<span class="keyword">if</span> (now-las==a[i].w) ans+=a[i].w;</span><br><span class="line">		las=now;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;! &quot;</span>&lt;&lt;ans;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-CF1120D-Power-Tree"><a href="#5-CF1120D-Power-Tree" class="headerlink" title="5. CF1120D Power Tree"></a>5. CF1120D Power Tree</h3><h4 id="Description-6"><a href="#Description-6" class="headerlink" title="Description"></a>Description</h4><p>给定一棵 $n$ 个点的有根树，$1$ 为根。定义 $u$ 为叶子当且仅当它<strong>不是根</strong>且度数为 $1$。</p>
<p>你可以选择花费 $w_u$ 的代价控制 $u$ 点。当一个点被控制时你可以选择给它的子树内的叶子的点权都加上一个值 $v$ 。你需要控制若干个点，使得花费的代价尽量少，无论怎样规定叶子的初始点权，都可以通过操作你选择的点来让所有叶子的点权清空。</p>
<p>你需要输出代价和的最小值以及所有点，满足它存在于某一种最优选择中。</p>
<p>$n\le 2\times 10^5$</p>
<p>2s , 512MB</p>
<h4 id="Solution-6"><a href="#Solution-6" class="headerlink" title="Solution"></a>Solution</h4><p>求出叶子节点的 dfs 序。子树加变成在差分数组上的两个点加减，满足之和不变。连接这两个点。</p>
<p>如果满足无论神秘初始点权都可以让叶子节点清空，则需要满足叶子节点在新的图上都联通。</p>
<p>求最小生成树即可。</p>
<h4 id="Code-6"><a href="#Code-6" class="headerlink" title="Code"></a>Code</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 200005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> put() putchar(<span class="string">&#x27;\n&#x27;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Tp template<span class="string">&lt;typename Ty&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Ts template<span class="string">&lt;typename Ty,typename... Ar&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(<span class="type">int</span> &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> f=<span class="number">1</span>;x=<span class="number">0</span>;<span class="type">char</span> c=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (c&lt;<span class="string">&#x27;0&#x27;</span>||c&gt;<span class="string">&#x27;9&#x27;</span>) &#123;<span class="keyword">if</span> (c==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">-1</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span> (c&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;c&lt;=<span class="string">&#x27;9&#x27;</span>) &#123;x=x*<span class="number">10</span>+c-<span class="string">&#x27;0&#x27;</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> Debug&#123;</span><br><span class="line">	Tp <span class="type">void</span> _debug(<span class="type">char</span>* f,Ty t)&#123;cerr&lt;&lt;f&lt;&lt;<span class="string">&#x27;=&#x27;</span>&lt;&lt;t&lt;&lt;endl;&#125;</span><br><span class="line">	Ts <span class="type">void</span> _debug(<span class="type">char</span>* f,Ty x,Ar... y)&#123;<span class="keyword">while</span>(*f!=<span class="string">&#x27;,&#x27;</span>) cerr&lt;&lt;*f++;cerr&lt;&lt;<span class="string">&#x27;=&#x27;</span>&lt;&lt;x&lt;&lt;<span class="string">&quot;,&quot;</span>;_debug(f+<span class="number">1</span>,y...);&#125;</span><br><span class="line">	Tp ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; os,vector&lt;Ty&gt;&amp; V)&#123;os&lt;&lt;<span class="string">&quot;[&quot;</span>;<span class="keyword">for</span>(<span class="keyword">auto</span>&amp; vv:V) os&lt;&lt;vv&lt;&lt;<span class="string">&quot;,&quot;</span>;os&lt;&lt;<span class="string">&quot;]&quot;</span>;<span class="keyword">return</span> os;&#125;</span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> gdb(...) _debug((char*)#__VA_ARGS__,__VA_ARGS__)</span></span><br><span class="line">&#125;<span class="keyword">using</span> <span class="keyword">namespace</span> Debug;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mk make_pair</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">power</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y=mod<span class="number">-2</span>)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> sum=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (y) &#123;</span><br><span class="line">		<span class="keyword">if</span> (y&amp;<span class="number">1</span>) sum=sum*x%mod;</span><br><span class="line">		x=x*x%mod;y&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,w[maxn];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">yyy</span>&#123;</span><br><span class="line">	<span class="type">int</span> x,y,z,id;</span><br><span class="line">&#125;e[maxn];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">cmp</span><span class="params">(yyy x,yyy y)</span> </span>&#123;<span class="keyword">return</span> x.z&lt;y.z;&#125;</span><br><span class="line"><span class="type">int</span> fa[maxn];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">getfa</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;<span class="keyword">return</span> x==fa[x]?x:fa[x]=<span class="built_in">getfa</span>(fa[x]);&#125;</span><br><span class="line"><span class="type">int</span> l[maxn],r[maxn],times,ans,Ans[maxn],tot;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;to[maxn];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> pre)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="keyword">if</span> (x!=<span class="number">1</span>&amp;&amp;to[x].<span class="built_in">size</span>()==<span class="number">1</span>) l[x]=++times;</span><br><span class="line">	<span class="keyword">else</span> l[x]=times+<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> y:to[x]) <span class="keyword">if</span> (y^pre) &#123;</span><br><span class="line">		<span class="built_in">dfs</span>(y,x);</span><br><span class="line">	&#125;</span><br><span class="line">	r[x]=times;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;1.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">	<span class="type">int</span> i,x,y,j,k;</span><br><span class="line">	<span class="built_in">read</span>(n);</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">read</span>(w[i]);</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n+<span class="number">1</span>;i++) fa[i]=i;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;n;i++) <span class="built_in">read</span>(x),<span class="built_in">read</span>(y),to[x].<span class="built_in">push_back</span>(y),to[y].<span class="built_in">push_back</span>(x);</span><br><span class="line">	<span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) e[i].x=l[i],e[i].y=r[i]+<span class="number">1</span>,e[i].z=w[i],e[i].id=i;<span class="comment">//,gdb(e[i].x,e[i].y,e[i].z,e[i].id);</span></span><br><span class="line">	<span class="built_in">sort</span>(e+<span class="number">1</span>,e+<span class="number">1</span>+n,cmp);</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (k=i;e[k+<span class="number">1</span>].z==e[i].z&amp;&amp;k&lt;n;k++);</span><br><span class="line">		<span class="keyword">for</span> (j=i;j&lt;=k;j++) <span class="keyword">if</span> (<span class="built_in">getfa</span>(e[j].x)!=<span class="built_in">getfa</span>(e[j].y)) Ans[++tot]=e[j].id;<span class="comment">//,gdb(tot,e[j].id,i,k);</span></span><br><span class="line">		<span class="keyword">for</span> (j=i;j&lt;=k;j++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (<span class="built_in">getfa</span>(e[j].x)!=<span class="built_in">getfa</span>(e[j].y)) &#123;</span><br><span class="line">				fa[<span class="built_in">getfa</span>(e[j].x)]=<span class="built_in">getfa</span>(e[j].y);</span><br><span class="line">				ans+=e[j].z;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		i=k;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld %lld\n&quot;</span>,ans,tot);</span><br><span class="line">	<span class="built_in">sort</span>(Ans+<span class="number">1</span>,Ans+<span class="number">1</span>+tot);</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=tot;i++) <span class="built_in">printf</span>(<span class="string">&quot;%lld &quot;</span>,Ans[i]);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Kruskal-重构树"><a href="#Kruskal-重构树" class="headerlink" title="Kruskal 重构树"></a>Kruskal 重构树</h2><p>这玩意我之前就会，就不细讲了。</p>
<ol>
<li><p>NOI2018 归程</p>
</li>
<li><p>CF1628E Groceries in Meteor Town</p>
</li>
<li><p>CF1416D Graph and Queries</p>
</li>
</ol>
<p>​	以时间为顺序的重构树。</p>
]]></content>
      <tags>
        <tag>学习笔记</tag>
        <tag>生成树</tag>
        <tag>Boruvka</tag>
      </tags>
  </entry>
  <entry>
    <title>简单Dp选讲</title>
    <url>/2022/10/13/%E7%AE%80%E5%8D%95dp%E9%80%89%E8%AE%B2/</url>
    <content><![CDATA[<p>最近学了点简单的数位 dp。</p>
<p>虽然常数略大一点，但是记搜是真的好写而且还不怎么动脑子&#x2F;se</p>
<h4 id="P4999-烦人的数学作业"><a href="#P4999-烦人的数学作业" class="headerlink" title="P4999 烦人的数学作业"></a>P4999 烦人的数学作业</h4><p>记录当前第几位，是否到上界。</p>
<p>没了。</p>
<h4 id="P1836-数页码"><a href="#P1836-数页码" class="headerlink" title="P1836 数页码"></a>P1836 数页码</h4><p>同上</p>
<h4 id="P6218-USACO06NOV-Round-Numbers-S"><a href="#P6218-USACO06NOV-Round-Numbers-S" class="headerlink" title="P6218 [USACO06NOV] Round Numbers S"></a>P6218 [USACO06NOV] Round Numbers S</h4><p>记录当前是第几位，有几个 $0$ ，是否到上界，有无前导 $0$。</p>
<h4 id="P4317-花神的数论题"><a href="#P4317-花神的数论题" class="headerlink" title="P4317 花神的数论题"></a>P4317 花神的数论题</h4><p>记录当前是第几位，有几个 $1$ ，是否到上界。</p>
<h4 id="P3147-USACO16OPEN-262144-P"><a href="#P3147-USACO16OPEN-262144-P" class="headerlink" title="P3147 [USACO16OPEN]262144 P"></a>P3147 [USACO16OPEN]262144 P</h4><p>模拟赛原题。</p>
<p>似乎有更简单的做法。反正我的做法就是先从小到大枚举一下当前是第几个数，设为 $k$，然后连续且都等于 $k$ 的块合并。如果是偶数，那么这个对左边和右边都有贡献。如果是奇数，作为分割点。每次递归（分治？）的时候记录左边和右边有几个等于 $k$ 的。</p>
<p>然后只有一个块之类的特判一下？</p>
<p>比较抽象，就贴个代码好了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 1000005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> put() putchar(<span class="string">&#x27;\n&#x27;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Tp template<span class="string">&lt;typename Ty&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Ts template<span class="string">&lt;typename Ty,typename... Ar&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(<span class="type">int</span> &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> f=<span class="number">1</span>;x=<span class="number">0</span>;<span class="type">char</span> c=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (c&lt;<span class="string">&#x27;0&#x27;</span>||c&gt;<span class="string">&#x27;9&#x27;</span>) &#123;<span class="keyword">if</span> (c==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">-1</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span> (c&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;c&lt;=<span class="string">&#x27;9&#x27;</span>) &#123;x=x*<span class="number">10</span>+c-<span class="string">&#x27;0&#x27;</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> Debug&#123;</span><br><span class="line">	Tp <span class="type">void</span> _debug(<span class="type">char</span>* f,Ty t)&#123;cerr&lt;&lt;f&lt;&lt;<span class="string">&#x27;=&#x27;</span>&lt;&lt;t&lt;&lt;endl;&#125;</span><br><span class="line">	Ts <span class="type">void</span> _debug(<span class="type">char</span>* f,Ty x,Ar... y)&#123;<span class="keyword">while</span>(*f!=<span class="string">&#x27;,&#x27;</span>) cerr&lt;&lt;*f++;cerr&lt;&lt;<span class="string">&#x27;=&#x27;</span>&lt;&lt;x&lt;&lt;<span class="string">&quot;,&quot;</span>;_debug(f+<span class="number">1</span>,y...);&#125;</span><br><span class="line">	Tp ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; os,vector&lt;Ty&gt;&amp; V)&#123;os&lt;&lt;<span class="string">&quot;[&quot;</span>;<span class="keyword">for</span>(<span class="keyword">auto</span>&amp; vv:V) os&lt;&lt;vv&lt;&lt;<span class="string">&quot;,&quot;</span>;os&lt;&lt;<span class="string">&quot;]&quot;</span>;<span class="keyword">return</span> os;&#125;</span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> gdb(...) _debug(#__VA_ARGS__,__VA_ARGS__)</span></span><br><span class="line">&#125;<span class="keyword">using</span> <span class="keyword">namespace</span> Debug;</span><br><span class="line"><span class="type">int</span> n,a[maxn],rt[maxn];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">	<span class="type">int</span> l,r;</span><br><span class="line">	<span class="built_in">node</span>(<span class="type">int</span> a=<span class="number">0</span>,<span class="type">int</span> b=<span class="number">0</span>) &#123;l=a;r=b;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> deep,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> numl,<span class="type">int</span> numr)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (l&gt;r) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">assert</span>(deep&lt;=<span class="number">40</span>);</span><br><span class="line"><span class="comment">//	gdb(deep,l,r,numl,numr);</span></span><br><span class="line"><span class="comment">//	if (l==r) return a[l]+(int)log2(numr+numl+1); </span></span><br><span class="line">	<span class="type">int</span> i,tot=<span class="number">1</span>,ans=<span class="number">0</span>,tmp,j;</span><br><span class="line">	vector&lt;node&gt;g;</span><br><span class="line">	g.<span class="built_in">push_back</span>(<span class="built_in">node</span>(<span class="number">0</span>,<span class="number">0</span>));</span><br><span class="line">	g.<span class="built_in">push_back</span>(<span class="built_in">node</span>(l-numl,l<span class="number">-1</span>));</span><br><span class="line"><span class="comment">//	g[1].l=l-numl,g[1].r=l-1;</span></span><br><span class="line">	<span class="keyword">for</span> (i=l;i&lt;=r;i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (a[i]==deep) &#123;</span><br><span class="line">			<span class="keyword">if</span> (g[tot].r==i<span class="number">-1</span>) g[tot].r++;</span><br><span class="line">			<span class="keyword">else</span> ++tot,g.<span class="built_in">push_back</span>(<span class="built_in">node</span>(i,i));<span class="comment">//g[tot].l=g[tot].r=i;</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (g[tot].r==r) g[tot].r+=numr;</span><br><span class="line">	<span class="keyword">else</span> ++tot,g.<span class="built_in">push_back</span>(<span class="built_in">node</span>(r+<span class="number">1</span>,r+numr));<span class="comment">//g[tot].l=r+1,g[tot].r=r+numr;</span></span><br><span class="line">	<span class="keyword">if</span> (tot==<span class="number">1</span>) <span class="keyword">return</span> deep+(<span class="type">int</span>)(<span class="built_in">log2</span>(g[<span class="number">1</span>].r-g[<span class="number">1</span>].l+<span class="number">1</span>));</span><br><span class="line">	<span class="type">int</span> las=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">2</span>;i&lt;=tot;i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (i!=tot&amp;&amp;(g[i].r-g[i].l+<span class="number">1</span>)%<span class="number">2</span>==<span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">		<span class="type">int</span> cnt=g[las].r;</span><br><span class="line">		<span class="keyword">for</span> (j=g[las].r+<span class="number">1</span>;j&lt;=g[i].l<span class="number">-1</span>;j++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (a[j]==deep&amp;&amp;rt[cnt]==deep) rt[cnt]=deep+<span class="number">1</span>;</span><br><span class="line">			<span class="keyword">else</span> rt[++cnt]=a[j];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (j=g[las].r+<span class="number">1</span>;j&lt;=cnt;j++) a[j]=rt[j];</span><br><span class="line">		<span class="type">int</span> tmp=<span class="built_in">solve</span>(deep+<span class="number">1</span>,g[las].r+<span class="number">1</span>,cnt,(g[las].r-g[las].l+<span class="number">1</span>)/<span class="number">2</span>,(g[i].r-g[i].l+<span class="number">1</span>)/<span class="number">2</span>);</span><br><span class="line">		ans=<span class="built_in">max</span>(ans,tmp);las=i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="built_in">read</span>(n);<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">read</span>(a[i]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,<span class="built_in">solve</span>(<span class="number">1</span>,<span class="number">1</span>,n,<span class="number">0</span>,<span class="number">0</span>));</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="P4127-AHOI2009-同类分布"><a href="#P4127-AHOI2009-同类分布" class="headerlink" title="P4127 [AHOI2009]同类分布"></a>P4127 [AHOI2009]同类分布</h4><p>考虑到各位数字之和最大只有 $9\times \log_{10}N&#x3D;9\times 18$ ，所以枚举各位数字之和，记为 $mod$。</p>
<p>记录当前在第几位，当前数字模 $mod$ 的值，当前各位数字之和，是否到上界。</p>
<h4 id="P4124-CQOI2016-手机号码"><a href="#P4124-CQOI2016-手机号码" class="headerlink" title="P4124 [CQOI2016]手机号码"></a>P4124 [CQOI2016]手机号码</h4><p>板子。</p>
<h4 id="P3413-SAC-1-萌数"><a href="#P3413-SAC-1-萌数" class="headerlink" title="P3413 SAC#1 - 萌数"></a>P3413 SAC#1 - 萌数</h4><p>如果有回文串，那么必定有长度为 $2$ 或者 $3$ 的回文子串。</p>
<p>这题还需要记录是否有前导 $0$。</p>
<h4 id="P6754-BalticOI-2013-Day1-Palindrome-Free-Numbers"><a href="#P6754-BalticOI-2013-Day1-Palindrome-Free-Numbers" class="headerlink" title="P6754 [BalticOI 2013 Day1] Palindrome-Free Numbers"></a>P6754 [BalticOI 2013 Day1] Palindrome-Free Numbers</h4><p>双倍经验。</p>
<h4 id="P3311-SDOI2014-数数"><a href="#P3311-SDOI2014-数数" class="headerlink" title="P3311 [SDOI2014] 数数"></a>P3311 [SDOI2014] 数数</h4><p>先对于集合中的数建 AC自动机。</p>
<p>记录当前第几位，在AC自动机上的状态，是否。如果当前在AC自动机上的状态是某个串的结尾，则直接返回 $0$。</p>
<p>贴个代码.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 1505</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> put() putchar(<span class="string">&#x27;\n&#x27;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Tp template<span class="string">&lt;typename Ty&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Ts template<span class="string">&lt;typename Ty,typename... Ar&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(<span class="type">int</span> &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> f=<span class="number">1</span>;x=<span class="number">0</span>;<span class="type">char</span> c=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (c&lt;<span class="string">&#x27;0&#x27;</span>||c&gt;<span class="string">&#x27;9&#x27;</span>) &#123;<span class="keyword">if</span> (c==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">-1</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span> (c&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;c&lt;=<span class="string">&#x27;9&#x27;</span>) &#123;x=x*<span class="number">10</span>+c-<span class="string">&#x27;0&#x27;</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> Debug&#123;</span><br><span class="line">	Tp <span class="type">void</span> _debug(<span class="type">char</span>* f,Ty t)&#123;cerr&lt;&lt;f&lt;&lt;<span class="string">&#x27;=&#x27;</span>&lt;&lt;t&lt;&lt;endl;&#125;</span><br><span class="line">	Ts <span class="type">void</span> _debug(<span class="type">char</span>* f,Ty x,Ar... y)&#123;<span class="keyword">while</span>(*f!=<span class="string">&#x27;,&#x27;</span>) cerr&lt;&lt;*f++;cerr&lt;&lt;<span class="string">&#x27;=&#x27;</span>&lt;&lt;x&lt;&lt;<span class="string">&quot;,&quot;</span>;_debug(f+<span class="number">1</span>,y...);&#125;</span><br><span class="line">	Tp ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; os,vector&lt;Ty&gt;&amp; V)&#123;os&lt;&lt;<span class="string">&quot;[&quot;</span>;<span class="keyword">for</span>(<span class="keyword">auto</span>&amp; vv:V) os&lt;&lt;vv&lt;&lt;<span class="string">&quot;,&quot;</span>;os&lt;&lt;<span class="string">&quot;]&quot;</span>;<span class="keyword">return</span> os;&#125;</span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> gdb(...) _debug(#__VA_ARGS__,__VA_ARGS__)</span></span><br><span class="line">&#125;<span class="keyword">using</span> <span class="keyword">namespace</span> Debug;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">yyy</span>&#123;</span><br><span class="line">	<span class="type">int</span> flag,fail,nex[<span class="number">11</span>];</span><br><span class="line">&#125;a[<span class="number">1505</span>*<span class="number">10</span>];</span><br><span class="line"><span class="type">int</span> root,n,m,cnt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">insert</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> i,len=s.<span class="built_in">size</span>(),now=root;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;len;i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!a[now].nex[s[i]-<span class="string">&#x27;0&#x27;</span>]) a[now].nex[s[i]-<span class="string">&#x27;0&#x27;</span>]=++cnt;</span><br><span class="line">		now=a[now].nex[s[i]-<span class="string">&#x27;0&#x27;</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	a[now].flag=<span class="number">1</span>;</span><br><span class="line"><span class="comment">//	gdb(now); </span></span><br><span class="line">&#125;</span><br><span class="line">queue&lt;<span class="type">int</span>&gt;q;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">getfail</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;=<span class="number">9</span>;i++) <span class="keyword">if</span> (a[root].nex[i]) q.<span class="built_in">push</span>(a[root].nex[i]);</span><br><span class="line">	<span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">		<span class="type">int</span> x=q.<span class="built_in">front</span>();q.<span class="built_in">pop</span>();</span><br><span class="line">		<span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;=<span class="number">9</span>;i++) </span><br><span class="line">			<span class="keyword">if</span> (a[x].nex[i]) a[a[x].nex[i]].fail=a[a[x].fail].nex[i],q.<span class="built_in">push</span>(a[x].nex[i]);</span><br><span class="line">			<span class="keyword">else</span> a[x].nex[i]=a[a[x].fail].nex[i];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">string c[<span class="number">105</span>];</span><br><span class="line"><span class="type">int</span> f[<span class="number">1202</span>][<span class="number">1505</span>],nums[maxn],tot;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> now,<span class="type">int</span> pus,<span class="type">int</span> lim,<span class="type">int</span> lead)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (a[pus].flag) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (lead) pus=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (now&gt;tot) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (!lim&amp;&amp;!lead&amp;&amp;f[now][pus]!=<span class="number">-1</span>) <span class="keyword">return</span> f[now][pus]; </span><br><span class="line">	<span class="type">int</span> i,ret=<span class="number">0</span>,res=lim?nums[now]:<span class="number">9</span>;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;=res;i++) &#123;</span><br><span class="line">		ret+=<span class="built_in">dfs</span>(now+<span class="number">1</span>,a[pus].nex[i],lim&amp;&amp;i==res,lead&amp;&amp;i==<span class="number">0</span>);ret%=mod;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> lim?ret:f[now][pus]=ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">	string sn;</span><br><span class="line">	<span class="built_in">memset</span>(f,<span class="number">-1</span>,<span class="built_in">sizeof</span>(f));</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	cin&gt;&gt;sn;<span class="built_in">read</span>(m);</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=m;i++) cin&gt;&gt;c[i],<span class="built_in">insert</span>(c[i]);</span><br><span class="line">	<span class="built_in">getfail</span>();</span><br><span class="line">	<span class="keyword">for</span> (tot=sn.<span class="built_in">size</span>(),i=<span class="number">1</span>;i&lt;=tot;i++) nums[i]=sn[i<span class="number">-1</span>]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,(<span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>)+mod<span class="number">-1</span>)%mod);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="CF1710C-XOR-Triangle"><a href="#CF1710C-XOR-Triangle" class="headerlink" title="CF1710C XOR Triangle"></a>CF1710C XOR Triangle</h4><p>对于 $x,y,z$ 上同一位的 $a,b,c$ ，我们发现 $a\bigoplus b+b\bigoplus c \ge a\bigoplus c$，所以只要满足 $a\bigoplus b+b\bigoplus c &gt; a\bigoplus c$ ，即可保证 $x\bigoplus y+y\bigoplus z &gt; x\bigoplus z$ 。</p>
<p>显然这个式子是轮换的，所以说当且仅当满足三个条件的数可以被记录答案。</p>
<p>因为是二进制下的数，所以如果没有记忆化是否达到上界多出来的常数是不可忽略的。就多开三维分别记录一下。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 200005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> put() putchar(<span class="string">&#x27;\n&#x27;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Tp template<span class="string">&lt;typename Ty&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Ts template<span class="string">&lt;typename Ty,typename... Ar&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(<span class="type">int</span> &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> f=<span class="number">1</span>;x=<span class="number">0</span>;<span class="type">char</span> c=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (c&lt;<span class="string">&#x27;0&#x27;</span>||c&gt;<span class="string">&#x27;9&#x27;</span>) &#123;<span class="keyword">if</span> (c==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">-1</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span> (c&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;c&lt;=<span class="string">&#x27;9&#x27;</span>) &#123;x=x*<span class="number">10</span>+c-<span class="string">&#x27;0&#x27;</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> Debug&#123;</span><br><span class="line">	Tp <span class="type">void</span> _debug(<span class="type">char</span>* f,Ty t)&#123;cerr&lt;&lt;f&lt;&lt;<span class="string">&#x27;=&#x27;</span>&lt;&lt;t&lt;&lt;endl;&#125;</span><br><span class="line">	Ts <span class="type">void</span> _debug(<span class="type">char</span>* f,Ty x,Ar... y)&#123;<span class="keyword">while</span>(*f!=<span class="string">&#x27;,&#x27;</span>) cerr&lt;&lt;*f++;cerr&lt;&lt;<span class="string">&#x27;=&#x27;</span>&lt;&lt;x&lt;&lt;<span class="string">&quot;,&quot;</span>;_debug(f+<span class="number">1</span>,y...);&#125;</span><br><span class="line">	Tp ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; os,vector&lt;Ty&gt;&amp; V)&#123;os&lt;&lt;<span class="string">&quot;[&quot;</span>;<span class="keyword">for</span>(<span class="keyword">auto</span>&amp; vv:V) os&lt;&lt;vv&lt;&lt;<span class="string">&quot;,&quot;</span>;os&lt;&lt;<span class="string">&quot;]&quot;</span>;<span class="keyword">return</span> os;&#125;</span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> gdb(...) _debug(#__VA_ARGS__,__VA_ARGS__)</span></span><br><span class="line">&#125;<span class="keyword">using</span> <span class="keyword">namespace</span> Debug;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">998244353</span>;</span><br><span class="line"><span class="type">int</span> f[maxn][<span class="number">2</span>][<span class="number">2</span>][<span class="number">2</span>][<span class="number">2</span>][<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> nums[maxn],tot;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> now,<span class="type">int</span> flag1,<span class="type">int</span> flag2,<span class="type">int</span> flag3,<span class="type">int</span> lim1,<span class="type">int</span> lim2,<span class="type">int</span> lim3)</span> </span>&#123;</span><br><span class="line"><span class="comment">//	gdb(now,flag1,flag2,flag3);</span></span><br><span class="line">	<span class="keyword">if</span> (now&gt;tot) <span class="keyword">return</span> flag1&amp;&amp;flag2&amp;&amp;flag3;</span><br><span class="line">	<span class="keyword">if</span> (f[now][lim1][lim2][lim3][flag1][flag2][flag3]!=<span class="number">-1</span>) <span class="keyword">return</span> f[now][lim1][lim2][lim3][flag1][flag2][flag3]; </span><br><span class="line">	</span><br><span class="line">	<span class="type">int</span> ret=<span class="number">0</span>,i,j,k,x,y,z;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;=(lim1?nums[now]:<span class="number">1</span>);i++)</span><br><span class="line">		<span class="keyword">for</span> (j=<span class="number">0</span>;j&lt;=(lim2?nums[now]:<span class="number">1</span>);j++)</span><br><span class="line">			<span class="keyword">for</span> (k=<span class="number">0</span>;k&lt;=(lim3?nums[now]:<span class="number">1</span>);k++)&#123;</span><br><span class="line">				x=i^j;y=j^k;z=i^k;</span><br><span class="line">				ret+=<span class="built_in">dfs</span>(now+<span class="number">1</span>,flag1|(x+y&gt;z),flag2|(x+z&gt;y),flag3|(y+z&gt;x),lim1&amp;&amp;i==nums[now],lim2&amp;&amp;j==nums[now],lim3&amp;&amp;k==nums[now]);</span><br><span class="line">				ret%=mod;</span><br><span class="line">			&#125;</span><br><span class="line">	<span class="keyword">return</span> f[now][lim1][lim2][lim3][flag1][flag2][flag3]=ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(f,<span class="number">-1</span>,<span class="built_in">sizeof</span>(f));</span><br><span class="line">	<span class="type">int</span> i;string s;</span><br><span class="line">	cin&gt;&gt;s;tot=s.<span class="built_in">size</span>();</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=tot;i++) nums[i]=s[i<span class="number">-1</span>]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line"><span class="comment">//	gdb(tot);</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,<span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>));</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="CF55D-Beautiful-numbers"><a href="#CF55D-Beautiful-numbers" class="headerlink" title="CF55D Beautiful numbers"></a>CF55D Beautiful numbers</h4><p>由 $1$ 到 $9$ 之中任意选取数的 $\text{lcm}$ 只有 $48$ 个，记为 $p$ ，尝试枚举。</p>
<p>记录当前在第几位，当前每位的 $\text{lcm}$ ，当前数模 $p$ 的值，是否达到上界。</p>
<p>复杂度是 $48\times 18 \times 48\times 2520\times T\times 2$ ，还不包括上界带来的常数，所以是不可接受的。</p>
<p>考虑去除枚举。记录当前在第几位，当前每位的 $\text{lcm}$ ，当前数模 $2520$ 的值，是否达到上界。</p>
<p>只要判断模 $2520$ 的值是否能被每位的 $\text{lcm}$ 整除即可。</p>
<p>然后发现如果每次都初始化会 TLE。</p>
<p>多出来的时间复杂度不仅仅在初始化上，更在于每次都需要重新计算。</p>
<p>因为我的写法把最高位设为 $1$ ，因为不同数位数不一样，所以 $1$ 所代表当前第几位也就不一样，不初始化就会 WA。解决这个问题，只需要将 第一位设为个位，然后记忆化搜索的时候从高位到低位即可。</p>
<p>似乎代码还更加简洁了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> put() putchar(<span class="string">&#x27;\n&#x27;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Tp template<span class="string">&lt;typename Ty&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Ts template<span class="string">&lt;typename Ty,typename... Ar&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(<span class="type">int</span> &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> f=<span class="number">1</span>;x=<span class="number">0</span>;<span class="type">char</span> c=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (c&lt;<span class="string">&#x27;0&#x27;</span>||c&gt;<span class="string">&#x27;9&#x27;</span>) &#123;<span class="keyword">if</span> (c==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">-1</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span> (c&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;c&lt;=<span class="string">&#x27;9&#x27;</span>) &#123;x=x*<span class="number">10</span>+c-<span class="string">&#x27;0&#x27;</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> Debug&#123;</span><br><span class="line">	Tp <span class="type">void</span> _debug(<span class="type">char</span>* f,Ty t)&#123;cerr&lt;&lt;f&lt;&lt;<span class="string">&#x27;=&#x27;</span>&lt;&lt;t&lt;&lt;endl;&#125;</span><br><span class="line">	Ts <span class="type">void</span> _debug(<span class="type">char</span>* f,Ty x,Ar... y)&#123;<span class="keyword">while</span>(*f!=<span class="string">&#x27;,&#x27;</span>) cerr&lt;&lt;*f++;cerr&lt;&lt;<span class="string">&#x27;=&#x27;</span>&lt;&lt;x&lt;&lt;<span class="string">&quot;,&quot;</span>;_debug(f+<span class="number">1</span>,y...);&#125;</span><br><span class="line">	Tp ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; os,vector&lt;Ty&gt;&amp; V)&#123;os&lt;&lt;<span class="string">&quot;[&quot;</span>;<span class="keyword">for</span>(<span class="keyword">auto</span>&amp; vv:V) os&lt;&lt;vv&lt;&lt;<span class="string">&quot;,&quot;</span>;os&lt;&lt;<span class="string">&quot;]&quot;</span>;<span class="keyword">return</span> os;&#125;</span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> gdb(...) _debug(#__VA_ARGS__,__VA_ARGS__)</span></span><br><span class="line">&#125;<span class="keyword">using</span> <span class="keyword">namespace</span> Debug;</span><br><span class="line"><span class="type">int</span> nums[<span class="number">22</span>],tot;</span><br><span class="line"><span class="type">int</span> id[<span class="number">2525</span>],t[<span class="number">2525</span>],cnt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span> </span>&#123;<span class="keyword">return</span> !y?x:<span class="built_in">gcd</span>(y,x%y);&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> now,<span class="type">int</span> sum)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (now==<span class="number">10</span>) <span class="keyword">return</span> t[++cnt]=sum,<span class="built_in">void</span>();</span><br><span class="line">	<span class="built_in">init</span>(now+<span class="number">1</span>,sum/<span class="built_in">gcd</span>(sum,now)*now);</span><br><span class="line">	<span class="built_in">init</span>(now+<span class="number">1</span>,sum);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> f[<span class="number">23</span>][<span class="number">51</span>][<span class="number">2525</span>];</span><br><span class="line"><span class="type">int</span> mod=<span class="number">2520</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> now,<span class="type">int</span> lcm,<span class="type">int</span> sum,<span class="type">int</span> lim)</span> </span>&#123;</span><br><span class="line"><span class="comment">//	gdb(now,lcm,sum,lim,id[lcm]);</span></span><br><span class="line">	<span class="keyword">if</span> (!now) &#123;</span><br><span class="line">		<span class="keyword">if</span> (sum%lcm==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (!lim&amp;&amp;f[now][id[lcm]][sum]!=<span class="number">-1</span>) <span class="keyword">return</span> f[now][id[lcm]][sum];</span><br><span class="line">	<span class="type">int</span> res=lim?nums[now]:<span class="number">9</span>,i,ret=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;=res;i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (i) ret+=<span class="built_in">dfs</span>(now<span class="number">-1</span>,lcm/<span class="built_in">gcd</span>(i,lcm)*i,(sum*<span class="number">10</span>+i)%mod,lim&amp;&amp;i==res);</span><br><span class="line">		<span class="keyword">else</span> ret+=<span class="built_in">dfs</span>(now<span class="number">-1</span>,lcm,sum*<span class="number">10</span>%mod,lim&amp;&amp;i==res);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> lim?ret:(f[now][id[lcm]][sum]=ret); </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (n==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="type">int</span> nw=n;tot=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (nw) nums[++tot]=nw%<span class="number">10</span>,nw/=<span class="number">10</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">dfs</span>(tot,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> i,T,l,r;</span><br><span class="line">	<span class="built_in">memset</span>(f,<span class="number">-1</span>,<span class="built_in">sizeof</span>(f));</span><br><span class="line">	<span class="built_in">init</span>(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">sort</span>(t+<span class="number">1</span>,t+<span class="number">1</span>+cnt);</span><br><span class="line">	cnt=<span class="built_in">unique</span>(t+<span class="number">1</span>,t+<span class="number">1</span>+cnt)-t<span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=cnt;i++) id[t[i]]=i;</span><br><span class="line">	<span class="built_in">read</span>(T);</span><br><span class="line">	<span class="keyword">while</span> (T--) &#123;</span><br><span class="line">		<span class="built_in">read</span>(l);<span class="built_in">read</span>(r);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,<span class="built_in">solve</span>(r)-<span class="built_in">solve</span>(l<span class="number">-1</span>));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>dp</tag>
        <tag>数位dp</tag>
      </tags>
  </entry>
  <entry>
    <title>线性规划学习笔记</title>
    <url>/2022/06/29/%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="线性规划学习笔记"><a href="#线性规划学习笔记" class="headerlink" title="线性规划学习笔记"></a>线性规划学习笔记</h1><h2 id="〇、前言"><a href="#〇、前言" class="headerlink" title="〇、前言"></a>〇、前言</h2><p>本文是我对线性规划的一个整理。</p>
<p>主要参考了 <a href="https://www.cnblogs.com/zzqsblog/p/5457091.html">zzq的博客</a> ，2016年国家集训队的两篇论文。</p>
<h2 id="一、定义"><a href="#一、定义" class="headerlink" title="一、定义"></a>一、定义</h2><h3 id="1-标准型线性规划"><a href="#1-标准型线性规划" class="headerlink" title="1. 标准型线性规划"></a>1. 标准型线性规划</h3><p>最大化 ：</p>
<p>$$<br>\sum\limits_{i&#x3D;1}^nc_ix_i<br>$$</p>
<p>$$<br>s.t. \sum\limits_{i&#x3D;1}^n a_{j,i}x_i\le b_j,1\le j\le m<br>$$</p>
<p>$$<br>x_i\ge 0,1\le i\le n<br>$$</p>
<p>为了避免在求解过程中由于正负号带来的变换不等号问题，于是有了另一种表示方式——松弛型。</p>
<h3 id="2-松弛型线性规划"><a href="#2-松弛型线性规划" class="headerlink" title="2. 松弛型线性规划"></a>2. 松弛型线性规划</h3><p>最大化</p>
<p>$$<br>\sum\limits_{i&#x3D;1}^nc_ix_i<br>$$</p>
<p>$$<br>s.t. x_{i+n}&#x3D;b_i-\sum\limits_{j&#x3D;1}^n a_{i,j}x_j,1\le i\le m<br>$$</p>
<p>$$<br>x_j\ge 0,1\le j\le n+m<br>$$</p>
<h2 id="二、求解——单纯形算法-Simplex-algorithm"><a href="#二、求解——单纯形算法-Simplex-algorithm" class="headerlink" title="二、求解——单纯形算法(Simplex algorithm)"></a>二、求解——单纯形算法(Simplex algorithm)</h2><p><strong>求解范围：$b_i\ge0$</strong></p>
<h3 id="1-定义"><a href="#1-定义" class="headerlink" title="1. 定义"></a>1. 定义</h3><ul>
<li><p>在松弛型等式左侧的变量我们成为 <strong>基变量</strong>。</p>
</li>
<li><p>在松弛型等式右侧的变量我们称为 <strong>非基变量</strong>。</p>
</li>
</ul>
<p>线性规划中每一组限制都隐藏这一组<strong>基本解</strong>，对于 $x_{i+n}&#x3D;b_i-\sum\limits_{j&#x3D;1}^n a_{i,j}x_j,1\le i\le m$，有基本解 $x_{i+n}&#x3D;b_i,x_j&#x3D;0$。</p>
<h3 id="2-算法概述"><a href="#2-算法概述" class="headerlink" title="2. 算法概述"></a>2. 算法概述</h3><p>单纯形算法有两个基本的操作 —— <strong>转轴操作（Pivot）</strong> 和 **求解过程 (Simplex)**。</p>
<h4 id="Pivot"><a href="#Pivot" class="headerlink" title="Pivot"></a>Pivot</h4><p>转轴操作是对于一组限制中一个基变量 $x_A$ 和一个非基变量 $x_B$ 代换的操作。</p>
<p>我们称 $x_A$ 为<strong>换入变量</strong>，$x_B$ 为<strong>换出变量</strong>。</p>
<p>具体的说：</p>
<p>$$<br>x_{A}&#x3D;b_i-\sum\limits_{j&#x3D;1}^n a_{i,j}x_j<br>$$<br>把 $x_B$ 代换到等式左边，得：</p>
<p>$$<br>x_B&#x3D;\dfrac{b_i-x_A-\sum\limits_{j&#x3D;1,j\not &#x3D; B}^na_{i,j}x_j}{a_{i,B}}<br>$$<br> 当然在选择的时候要确保 $a_{i,B}\not&#x3D; 0$。</p>
<p>用这条等式代替原等式，然后<strong>将这条等式依次带入其他等式和要优化的结果</strong>。</p>
<h4 id="Simplex"><a href="#Simplex" class="headerlink" title="Simplex"></a>Simplex</h4><p>Simplex 就是单纯形算法的主过程，从一个基本解出发，经过一系列的转轴操作，达到最优解。通过选择特定的换入变量和换出变量，使每一次转轴操作都能使目标函数增大，直到达到全局最优解。</p>
<p><strong>基本过程：</strong></p>
<ul>
<li>选择一个满足 $c_e \ge 0$ 的非基变量 $x_e$。</li>
<li>找到那个满足 $a_{l,e} &gt; 0$ 且 $\dfrac{b_l}{a_{l,e}}$ 最小的基变量 $x_{n+l}$。</li>
<li>执行 $pivot(l,e)$ 然后回到第一步。</li>
</ul>
<p>每次选择一个增大后可以使当前状态变优的变量，将其增加到有一个基变量变成 $0$ 位置，然后互换他们的位置。</p>
<p>第二步取最小的目的是一个<strong>贪心优化</strong>，可以使 $pivot$ 的<strong>次数降低许多</strong>。</p>
<p>该过程在一下两种情况下会终止：</p>
<ul>
<li>找不到一个合法的 $e$ ，显然现在已经找到了<strong>最优解</strong>。可以手模一组数据。</li>
<li>找不到一个合法的 $l$ ，此时的<strong>最优解是</strong> $\infty$ 。</li>
</ul>
<p>可能还是有点懵，我们拿论文里的例子模拟一下。</p>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/awc4atz6.png"></p>
<p>至于为什么是负号。如果看的仔细的话，前面线性规划的式子，每个 $a_{i,j}$ 之前都有个负号。</p>
<p>对于 $x_1$ ，显然在第三个限制 $\dfrac{b_3}{a_{3,1}}$ 最小。所以 $x_1$ 和 $x_6$ 互换位置，有了下边：</p>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/22hg3cwk.png"></p>
<p>再对于 $x_3$ ，对于第 $2$ 条限制最小，$x_3$ 和 $x_5$ 互换位置。</p>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/8uux4okk.png"></p>
<p>对于 $x_2$ 也是同理。</p>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/gwwdbe9i.png"></p>
<p>现在，由于 $c_i&lt; 0,1\le i\le n，x_i\ge 0$ ，显然 $x_3&#x3D;x_5&#x3D;x_6&#x3D;0$ 原式有最大值。最大值就是 $28$。基变量的值就是 $b_i$ 。此时的最优解就是 $x&#x3D;{8,4,0,18,0,0}$。</p>
<p>单纯形算法的核心思想就是这样，把 $c_i\le 0$ ，使得所有的非基变量都为 $0$ 。这就解释了为什么只能把 $b_i$ 全部搞成正的，负的反而会使答案边小。</p>
<h3 id="3-初始化过程"><a href="#3-初始化过程" class="headerlink" title="3. 初始化过程"></a>3. 初始化过程</h3><p>前文提到了 $Simplex$ 只能在 $b_i\ge 0$ 的时候进行。如果 $b_i&lt;0$ 呢？这时候就要进行初始化。</p>
<p>具体的，初始化常见的有两种方法：新建一个<strong>辅助线性规划</strong>或者<strong>通过 $pivot$ 进行初始化</strong>。本文只介绍后一种方法。</p>
<p>根据 $pivot$ 的过程，在 $a_{i,B}&gt;0$ 的情况下，$b_i$ 的正负性并不会被改变。所以当 $b_i$ 为负数时，只需要找到一个 $a_{i,j}&lt;0$ 进行转轴操作即可改变 $b_i$ 的正负性。</p>
<p>当然，如果 $b_i&lt;0$ 时，并没有找到 $a_{i,j}&lt;0$ ，此时整个线性规划<strong>无解</strong>。  </p>
<h2 id="三、实现"><a href="#三、实现" class="headerlink" title="三、实现"></a>三、实现</h2><p>代码细节比较多。</p>
<p><strong>对于我这种写法，$a_{i,j},i&gt;0,j&gt;0$ 一定要取相反数！</strong></p>
<p>其中 $id_i$ 是指取第 $i$ 条限制基变量的原序号。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">double</span> eps=<span class="number">1e-8</span>;</span><br><span class="line"><span class="type">int</span> id[maxn*<span class="number">2</span>];</span><br><span class="line"><span class="type">double</span> a[maxn][maxn],vv[maxn];</span><br><span class="line"><span class="type">int</span> n,m,op;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">dcmp</span><span class="params">(<span class="type">double</span> x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (x&gt;eps) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (x&lt;-eps) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> Semplex&#123;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Pivot</span><span class="params">(<span class="type">int</span> r,<span class="type">int</span> c)</span></span>&#123;</span><br><span class="line">    	rg <span class="type">int</span> i,j;<span class="type">double</span> x=-a[r][c];</span><br><span class="line">    	<span class="built_in">swap</span>(id[n+r],id[c]);a[r][c]=<span class="number">-1</span>;</span><br><span class="line">		<span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;=n;i++) a[r][i]/=x;</span><br><span class="line">    	<span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;=m;i++)&#123;</span><br><span class="line">    		<span class="keyword">if</span> (<span class="built_in">dcmp</span>(a[i][c])&amp;&amp;i!=r)&#123;</span><br><span class="line">    			x=a[i][c];a[i][c]=<span class="number">0</span>;</span><br><span class="line">    			<span class="keyword">for</span> (j=<span class="number">0</span>;j&lt;=n;j++) a[i][j]+=x*a[r][j]; </span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">init</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">		rg <span class="type">int</span> x,y,i;</span><br><span class="line">		<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) id[i]=i;</span><br><span class="line">		<span class="keyword">while</span> (<span class="number">1</span>)&#123;</span><br><span class="line">			x=y=<span class="number">0</span>;</span><br><span class="line">			<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=m;i++) </span><br><span class="line">			    <span class="keyword">if</span> (<span class="built_in">dcmp</span>(a[i][<span class="number">0</span>])&lt;<span class="number">0</span>&amp;&amp;(!x||<span class="built_in">rand</span>()&amp;<span class="number">1</span>)) x=i;</span><br><span class="line">			<span class="keyword">if</span> (!x) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">			    <span class="keyword">if</span> (<span class="built_in">dcmp</span>(a[x][i])&gt;<span class="number">0</span>&amp;&amp;(!y||<span class="built_in">rand</span>()&amp;<span class="number">1</span>)) &#123;y=i;<span class="keyword">break</span>;&#125;</span><br><span class="line">			<span class="keyword">if</span> (!y) &#123;<span class="built_in">puts</span>(<span class="string">&quot;Infeasible&quot;</span>);<span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line">			<span class="built_in">Pivot</span>(x,y);</span><br><span class="line">		&#125;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Semplex</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">		rg <span class="type">int</span> i,x,y,f;</span><br><span class="line">		<span class="keyword">if</span> (!<span class="built_in">init</span>()) <span class="keyword">return</span>;</span><br><span class="line">		<span class="keyword">while</span> (<span class="number">1</span>)&#123;</span><br><span class="line">			x=y=<span class="number">0</span>;f=<span class="number">1</span>;rg <span class="type">double</span> w,t;</span><br><span class="line">		    <span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) </span><br><span class="line">		        <span class="keyword">if</span> (<span class="built_in">dcmp</span>(a[<span class="number">0</span>][i])&gt;<span class="number">0</span>&amp;&amp;(!x||<span class="built_in">rand</span>()&amp;<span class="number">1</span>)) x=i;</span><br><span class="line">		    <span class="keyword">if</span> (!x) <span class="keyword">break</span>;</span><br><span class="line">		    <span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">		        <span class="keyword">if</span> (<span class="built_in">dcmp</span>(a[i][x])&lt;<span class="number">0</span>&amp;&amp;(w=-a[i][<span class="number">0</span>]/a[i][x],f||t&gt;w)) y=i,f=<span class="number">0</span>,t=w;</span><br><span class="line">		    <span class="keyword">if</span> (!y) &#123;<span class="built_in">puts</span>(<span class="string">&quot;Unbounded&quot;</span>);<span class="keyword">return</span>;&#125;</span><br><span class="line">		    <span class="built_in">Pivot</span>(y,x);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%.9lf\n&quot;</span>,a[<span class="number">0</span>][<span class="number">0</span>]);</span><br><span class="line">		<span class="keyword">if</span> (!op) <span class="keyword">return</span>;</span><br><span class="line">		<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) vv[i]=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (i=n+<span class="number">1</span>;i&lt;=n+m;i++) vv[id[i]]=a[i-n][<span class="number">0</span>];</span><br><span class="line">		<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">printf</span>(<span class="string">&quot;%.9lf &quot;</span>,vv[i]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    rg <span class="type">int</span> i,j;</span><br><span class="line">    <span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="number">0</span>));</span><br><span class="line">    <span class="built_in">read</span>(n);<span class="built_in">read</span>(m);<span class="built_in">read</span>(op);</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%lf&quot;</span>,&amp;a[<span class="number">0</span>][i]);</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=m;<span class="built_in">scanf</span>(<span class="string">&quot;%lf&quot;</span>,&amp;a[i][<span class="number">0</span>]),i++)</span><br><span class="line">        <span class="keyword">for</span> (j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%lf&quot;</span>,&amp;a[i][j]),a[i][j]*=<span class="number">-1</span>;</span><br><span class="line">    Semplex::<span class="built_in">Semplex</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="四、对偶问题"><a href="#四、对偶问题" class="headerlink" title="四、对偶问题"></a>四、对偶问题</h2><p>给定一个原始线性规划：</p>
<p>最大化 ：</p>
<p>$$<br>\sum\limits_{i&#x3D;1}^nc_ix_i<br>$$</p>
<p>$$<br>s.t. \sum\limits_{i&#x3D;1}^n a_{j,i}x_i\le b_j,1\le j\le m<br>$$</p>
<p>$$<br>x_i\ge 0,1\le i\le n<br>$$</p>
<p>定义它的对偶线性规划为：</p>
<p>最小化：</p>
<p>$$<br>\sum\limits_{j&#x3D;1}^mb_jy_j<br>$$</p>
<p>$$<br>s.t.\sum\limits_{j&#x3D;1}^m a_{i,j}y_j\ge c_i,1\le i\le n<br>$$</p>
<p>$$<br>y_j\ge 0,1\le j\le m<br>$$</p>
<p>其最优解相同。</p>
<h2 id="五、例题"><a href="#五、例题" class="headerlink" title="五、例题"></a>五、例题</h2><h3 id="NOI2008-志愿者招募"><a href="#NOI2008-志愿者招募" class="headerlink" title="[NOI2008] 志愿者招募"></a>[NOI2008] 志愿者招募</h3><p>设 $M_{i,j}$ 表示第 $i$ 类志愿者在第 $j$ 天能否工作，$x_i$ 表示第 $i$ 类志愿者的数量。</p>
<p>易列出原始线性规划：</p>
<p>最小化</p>
<p>$$<br>\sum\limits_{i&#x3D;1}^m x_ic_i<br>$$</p>
<p>$$<br>s.t.\ \sum\limits_{i&#x3D;1}^m M_{j,i}x_i\ge a_j ,1\le j\le m<br>$$</p>
<p>$$<br>x_i\ge 0,1\le i\le m<br>$$</p>
<p>转化为其对偶线性规划：</p>
<p>最大化</p>
<p>$$<br>\sum\limits_{j&#x3D;1}^n y_ja_j<br>$$</p>
<p>$$<br>s.t.\ \sum\limits_{j&#x3D;1}^n M_{i,j}y_j\le c_i,1\le i\le m<br>$$</p>
<p>$$<br>y_j\ge 0,1\le j\le n<br>$$</p>
<p>$Code:$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    rg <span class="type">int</span> i,j,l,r;</span><br><span class="line">    <span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="number">0</span>));</span><br><span class="line">    <span class="built_in">read</span>(n);<span class="built_in">read</span>(m);</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%lf&quot;</span>,&amp;a[<span class="number">0</span>][i]);</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">    	<span class="built_in">read</span>(l);<span class="built_in">read</span>(r);<span class="built_in">scanf</span>(<span class="string">&quot;%lf&quot;</span>,&amp;a[i][<span class="number">0</span>]);</span><br><span class="line">    	<span class="keyword">for</span> (j=l;j&lt;=r;j++) a[i][j]=<span class="number">-1.0</span>;<span class="comment">//一定要取负号！！！！！！</span></span><br><span class="line">	&#125;</span><br><span class="line">    Semplex::<span class="built_in">Semplex</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ZJOI2013-防守战线"><a href="#ZJOI2013-防守战线" class="headerlink" title="[ZJOI2013]防守战线"></a>[ZJOI2013]防守战线</h3><p>板子</p>
<h3 id="SHOI2004-最小生成树"><a href="#SHOI2004-最小生成树" class="headerlink" title="[SHOI2004]最小生成树"></a>[SHOI2004]最小生成树</h3><p>非常显然，树边不增，非树边不减。</p>
<p>考虑到非树边一定大于等于在最小生成树的路径上的边权，所以直接列约束条件。</p>
<p>注意到线性规划的一列只有两个非零值，非常浪费空间，所以用 $map$ 代替。</p>
<p>$$<br>d+\sum\limits_{i&#x3D;1}^nc_ix_{id_i},id_i\in [1,n+m],c_i&lt; 0<br>$$</p>
]]></content>
      <tags>
        <tag>学习笔记</tag>
        <tag>线性规划</tag>
      </tags>
  </entry>
  <entry>
    <title>计算时间复杂度</title>
    <url>/2022/08/28/%E8%AE%A1%E7%AE%97%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>首先，注意几个符号：</p>
<p>符号 $\Theta$ 既是上界也是下界。</p>
<p>符号 $O$ 表示上界。</p>
<p>   符号 $\Omega$ 表示下界。</p>
<h3 id="Master-定理"><a href="#Master-定理" class="headerlink" title="Master 定理"></a>Master 定理</h3><p>又称为主定理，具体内容如下：</p>
<p>$T(n)&#x3D;aT(n&#x2F;b)+f(n)$，则：</p>
<ol>
<li><p>$f(n)&lt;O(n^{\log_b^a} )\Longrightarrow T(n)&#x3D;\Theta(n^)$。</p>
</li>
<li><p>$f(n)&#x3D;\Theta(n^{\log_b^a}\log^kn) \Longrightarrow T(n)&#x3D;\Theta(n^{\log_b^a}\log^{k+1}n)$</p>
</li>
<li><p>假设存在常数 $ϵ&gt;0$ ，有 $f(n)&#x3D;Ω(n^{log_b^a+ϵ})$，同时存在常数 $c&lt;1$ 以及充分大的 $n$ 满足 $af(n&#x2F;b)≤cf(n)$ ,那么 $T(n)&#x3D;Θ(f(n))$。</p>
</li>
</ol>
<p>注意第三个情况，有一些情况是不可以用的，如：</p>
<p>$T(n)&#x3D;4T(n&#x2F;2)+\frac{n^2}{\log n}$</p>
<p>正确答案是 $\Theta(n^2\log\log n)$。</p>
<h3 id="XXX-定理"><a href="#XXX-定理" class="headerlink" title="XXX 定理"></a>XXX 定理</h3><p>在算法导论上看到的，定理名字忘记了，内容如下：</p>
<p>$T(n)&#x3D;\sum\limits a_iT(n\cdot b_i)+f(n)$</p>
<p>其中 $0&lt;b_i&lt;1$。</p>
<p>令实数 $p$ 为 $\sum\limits a_ib_i^p&#x3D;1$ 的解，可以证明是存在解的。</p>
<p>$$T(n)&#x3D;\Theta(n^p(1+\int_1^n \dfrac{f(x)}{x^{p+1}}dx))$$</p>
<p>用法比主定理更广，也没有很多的限制。</p>
<p>例如：</p>
<p>$T(n)&#x3D;T(\dfrac{n}{3})+2T(\dfrac{2n}{3})+O(n\log n)$</p>
<p>此时 $p&#x3D;2$ ,$T(n)&#x3D;\Theta(n^2)$。</p>
<h2 id="万金油：数学归纳法"><a href="#万金油：数学归纳法" class="headerlink" title="万金油：数学归纳法"></a>万金油：数学归纳法</h2><p>猜测 $T(n)&#x3D;g(n)$，然后瞎搞。</p>
<p>可能有用的 <a href="https://www.luogu.com.cn/discuss/352811?page=1">link</a></p>
]]></content>
      <tags>
        <tag>学习笔记</tag>
        <tag>复杂度</tag>
      </tags>
  </entry>
  <entry>
    <title>长链剖分学习笔记</title>
    <url>/2022/06/29/%E9%95%BF%E9%93%BE%E5%89%96%E5%88%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h3 id="长链剖分"><a href="#长链剖分" class="headerlink" title="长链剖分"></a>长链剖分</h3><p>构造方法：类似于轻重链剖分，把子树最大深度最大的儿子作为重儿子。</p>
<h4 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h4><ul>
<li>一个节点到它所在的长链的链底部的路径，为从这个节点到它子树每个子树所有节点的路径中，最长的一条。</li>
<li>一个节点到根的路径，最多经过 $O(\sqrt n )$ 的链</li>
<li>任意节点 $u$ 的第 $k$ 级祖先 $v$ 所在链的长度一定大于 $k$。</li>
<li>所有链长之和是 $O(n)$ 的。</li>
</ul>
<h3 id="树上-k-级祖先"><a href="#树上-k-级祖先" class="headerlink" title="树上 k 级祖先"></a>树上 k 级祖先</h3><p>找到一个 $i$，满足 $2^i\le k&lt; 2^{i+1}$ ，把 $x$ 向上跳 $2^i$ 级。设还剩下 $k’&#x3D;k-2^i$</p>
<p>因为 $k-2^i&#x3D;k’&lt;2^i$ ，而 $x$ 所在链的长度大于等于 $2^i$ ，所以只需要预处理出每条链的长度 $len$，链的顶端向下的 $len$ 个儿子，向上的 $len$ 个祖先。就可以做到 $O(1)$ 查询了。</p>
<p>当时需要 $O(n\log n)$ 预处理出倍增数组。所以总的复杂度是 $O(n\log n)+O(q)$ 的。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 500005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> put() putchar(<span class="string">&#x27;\n&#x27;</span>)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(<span class="type">int</span> &amp;x)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> f=<span class="number">1</span>;x=<span class="number">0</span>;<span class="type">char</span> c=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span> (c&lt;<span class="string">&#x27;0&#x27;</span>||c&gt;<span class="string">&#x27;9&#x27;</span>) &#123;<span class="keyword">if</span> (c==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">-1</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">while</span> (c&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;c&lt;=<span class="string">&#x27;9&#x27;</span>) &#123;x=x*<span class="number">10</span>+c-<span class="string">&#x27;0&#x27;</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ui unsigned int</span></span><br><span class="line">ui s;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ui <span class="title">get</span><span class="params">(ui x)</span> </span>&#123;</span><br><span class="line">	x ^= x &lt;&lt; <span class="number">13</span>;</span><br><span class="line">	x ^= x &gt;&gt; <span class="number">17</span>;</span><br><span class="line">	x ^= x &lt;&lt; <span class="number">5</span>;</span><br><span class="line">	<span class="keyword">return</span> s = x; </span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,q;</span><br><span class="line"><span class="type">int</span> h[maxn],head=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">yyy</span>&#123;</span><br><span class="line">	<span class="type">int</span> to,z;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">		to=y;z=h[x];h[x]=head;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;a[maxn*<span class="number">2</span>];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;ff[maxn],fs[maxn];</span><br><span class="line"><span class="type">int</span> fa[maxn][<span class="number">21</span>],top[maxn],deep[maxn],lg[maxn],hh[maxn],son[maxn],maxdeep[maxn];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> pre)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> i;deep[x]=deep[pre]+<span class="number">1</span>;fa[x][<span class="number">0</span>]=pre;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=lg[deep[x]];i++) fa[x][i]=fa[fa[x][i<span class="number">-1</span>]][i<span class="number">-1</span>];</span><br><span class="line">	<span class="keyword">for</span> (i=h[x];i;i=a[i].z) &#123;</span><br><span class="line">		<span class="built_in">dfs</span>(a[i].to,x);</span><br><span class="line">		<span class="keyword">if</span> (maxdeep[x]&lt;maxdeep[a[i].to]+<span class="number">1</span>) &#123;</span><br><span class="line">	    	maxdeep[x]=maxdeep[a[i].to]+<span class="number">1</span>;</span><br><span class="line">	    	son[x]=a[i].to;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> pre,<span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> i;top[x]=v;</span><br><span class="line">	<span class="keyword">if</span> (x^v) fs[v].<span class="built_in">push_back</span>(x);</span><br><span class="line">	<span class="keyword">if</span> (!son[x]) <span class="keyword">return</span> ;</span><br><span class="line">	<span class="built_in">dfs2</span>(son[x],x,v);</span><br><span class="line">	<span class="keyword">for</span> (i=h[x];i;i=a[i].z) </span><br><span class="line">		<span class="keyword">if</span> (a[i].to^son[x])&#123;</span><br><span class="line">			<span class="built_in">dfs2</span>(a[i].to,x,a[i].to);</span><br><span class="line">			<span class="type">int</span> j,now=x;</span><br><span class="line">		    <span class="keyword">for</span> (j=<span class="number">1</span>;j&lt;=maxdeep[a[i].to];j++) </span><br><span class="line">		        <span class="keyword">if</span> (!now) <span class="keyword">break</span>;</span><br><span class="line">		        <span class="keyword">else</span> ff[a[i].to].<span class="built_in">push_back</span>(now),now=fa[now][<span class="number">0</span>];</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line"><span class="comment">//	freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);</span></span><br><span class="line">    <span class="type">int</span> i,j,now,x,k,root;</span><br><span class="line">    ll ans=<span class="number">0</span>,lasans=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">read</span>(n);<span class="built_in">read</span>(q);<span class="built_in">scanf</span>(<span class="string">&quot;%u&quot;</span>,&amp;s);</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">    	<span class="built_in">read</span>(x);</span><br><span class="line">    	<span class="keyword">if</span> (!x) root=i;</span><br><span class="line">    	<span class="keyword">else</span> a[++head].<span class="built_in">add</span>(x,i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">2</span>;i&lt;=n;i++) lg[i]=lg[i/<span class="number">2</span>]+<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (h[<span class="number">0</span>]=<span class="number">0</span>,i=<span class="number">1</span>;i&lt;=n;i++) hh[i]=<span class="number">1</span>&lt;&lt;lg[i];</span><br><span class="line">	<span class="built_in">dfs</span>(root,<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">dfs2</span>(root,<span class="number">0</span>,root);</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=q;i++) &#123;</span><br><span class="line">    	x=((<span class="built_in">get</span>(s)^lasans)%n)+<span class="number">1</span>;k=(<span class="built_in">get</span>(s)^lasans)%deep[x];</span><br><span class="line">    	<span class="keyword">if</span> (k==<span class="number">0</span>) &#123;lasans=x;ans^=(i*lasans);<span class="keyword">continue</span>;&#125;</span><br><span class="line">    	x=fa[x][lg[k]];k=k-hh[k]+deep[top[x]]-deep[x];<span class="type">int</span> now=top[x];</span><br><span class="line">    	<span class="keyword">if</span> (k==<span class="number">0</span>) lasans=now;</span><br><span class="line">    	<span class="keyword">else</span> <span class="keyword">if</span> (k&lt;<span class="number">0</span>) lasans=fs[now][-k<span class="number">-1</span>];</span><br><span class="line">    	<span class="keyword">else</span> lasans=ff[now][k<span class="number">-1</span>];</span><br><span class="line">    	ans^=(i*lasans);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="长链剖分优化-dp"><a href="#长链剖分优化-dp" class="headerlink" title="长链剖分优化 dp"></a>长链剖分优化 dp</h3><p>一般来说，满足 $dp$ 的状态与深度有关，可以考虑用长链剖分优化 $dp$。</p>
<p>具体来说，每次继承重儿子的状态，对于每个非重儿子，一定是一个链的顶端，暴力合并。</p>
<p>继承的复杂度是 $O(1)$ ，所有的非重儿子，复杂度是 $O(\sum len_i)&#x3D;O(n)$ ，$len_i$ 是第 $i$ 条链的长度。</p>
<h4 id="CF1009F"><a href="#CF1009F" class="headerlink" title="CF1009F"></a>CF1009F</h4>]]></content>
      <tags>
        <tag>长链剖分</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
</search>
